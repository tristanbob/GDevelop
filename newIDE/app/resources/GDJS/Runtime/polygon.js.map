{
  "version": 3,
  "sources": ["../../../../../GDJS/Runtime/polygon.ts"],
  "sourcesContent": ["/*\n * GDevelop JS Platform\n * Copyright 2013-2016 Florian Rival (Florian.Rival@gmail.com). All rights reserved.\n * This project is released under the MIT License.\n */\nnamespace gdjs {\n  export type CollisionTestResult = {\n    collision: boolean;\n    move_axis: FloatPoint;\n  };\n\n  export type RaycastTestResult = {\n    collision: boolean;\n    closeX: float;\n    closeY: float;\n    closeSqDist: float;\n    farX: float;\n    farY: float;\n    farSqDist: float;\n  };\n\n  /** Build a new object to store collision test results. */\n  const makeNewCollisionTestResult = (): CollisionTestResult => {\n    return { collision: false, move_axis: [0, 0] };\n  };\n\n  /** Build a new object to store raycast test results. */\n  const makeNewRaycastTestResult = (): RaycastTestResult => {\n    return {\n      collision: false,\n      closeX: 0,\n      closeY: 0,\n      closeSqDist: 0,\n      farX: 0,\n      farY: 0,\n      farSqDist: 0,\n    };\n  };\n\n  /**\n   * Arrays and data structure that are (re)used by Polygon.collisionTest to\n   * avoid any allocation.\n   */\n  const collisionTestStatics: {\n    minMaxA: FloatPoint;\n    minMaxB: FloatPoint;\n    edge: FloatPoint;\n    axis: FloatPoint;\n    move_axis: FloatPoint;\n    result: CollisionTestResult;\n  } = {\n    minMaxA: [0, 0],\n    minMaxB: [0, 0],\n    edge: [0, 0],\n    axis: [0, 0],\n    move_axis: [0, 0],\n    result: makeNewCollisionTestResult(),\n  };\n\n  /**\n   * Arrays and data structure that are (re)used by Polygon.raycastTest to\n   * avoid any allocation.\n   */\n  const raycastTestStatics: {\n    p: FloatPoint;\n    q: FloatPoint;\n    r: FloatPoint;\n    s: FloatPoint;\n    deltaQP: FloatPoint;\n    axis: FloatPoint;\n    result: RaycastTestResult;\n  } = {\n    p: [0, 0],\n    q: [0, 0],\n    r: [0, 0],\n    s: [0, 0],\n    deltaQP: [0, 0],\n    axis: [0, 0],\n    result: makeNewRaycastTestResult(),\n  };\n\n  /**\n   * Polygon represents a polygon which can be used to create collisions masks for RuntimeObject.\n   */\n  export class Polygon {\n    /**\n     * The vertices of the polygon\n     */\n    vertices: Array<FloatPoint> = [];\n\n    /**\n     * The edges of the polygon. This property is only valid after calling\n     * computeEdges, and remains valid until vertices are modified.\n     */\n    edges: Array<FloatPoint> = [];\n\n    /**\n     * The center of the polygon. This property is only valid after calling\n     * computeCenter, and remains valid until vertices are modified.\n     */\n    center: FloatPoint = [0, 0];\n\n    move(x: float, y: float): void {\n      for (let i = 0, len = this.vertices.length; i < len; ++i) {\n        this.vertices[i][0] += x;\n        this.vertices[i][1] += y;\n      }\n    }\n\n    rotate(angle: float): void {\n      let t: float = 0;\n\n      //We want a clockwise rotation\n      const cosa = Math.cos(-angle);\n      const sina = Math.sin(-angle);\n      for (let i = 0, len = this.vertices.length; i < len; ++i) {\n        t = this.vertices[i][0];\n        this.vertices[i][0] = t * cosa + this.vertices[i][1] * sina;\n        this.vertices[i][1] = -t * sina + this.vertices[i][1] * cosa;\n      }\n    }\n\n    computeEdges(): void {\n      //Ensure edge array has the right size (and avoid recreating an edge array).\n      while (this.edges.length < this.vertices.length) {\n        this.edges.push([0, 0]);\n      }\n      if (this.edges.length != this.vertices.length) {\n        this.edges.length = this.vertices.length;\n      }\n      for (let i = 0, len = this.vertices.length; i < len; ++i) {\n        const v1 = this.vertices[i];\n        const v2 = i + 1 >= len ? this.vertices[0] : this.vertices[i + 1];\n        this.edges[i][0] = v2[0] - v1[0];\n        this.edges[i][1] = v2[1] - v1[1];\n      }\n    }\n\n    isConvex(): boolean {\n      this.computeEdges();\n      const edgesLen = this.edges.length;\n      if (edgesLen < 3) {\n        return false;\n      }\n      const zProductIsPositive =\n        this.edges[0][0] * this.edges[0 + 1][1] -\n          this.edges[0][1] * this.edges[0 + 1][0] >\n        0;\n      for (let i = 1; i < edgesLen - 1; ++i) {\n        const zCrossProduct =\n          this.edges[i][0] * this.edges[i + 1][1] -\n          this.edges[i][1] * this.edges[i + 1][0];\n        if (zCrossProduct > 0 !== zProductIsPositive) {\n          return false;\n        }\n      }\n      const lastZCrossProduct =\n        this.edges[edgesLen - 1][0] * this.edges[0][1] -\n        this.edges[edgesLen - 1][1] * this.edges[0][0];\n      if (lastZCrossProduct > 0 !== zProductIsPositive) {\n        return false;\n      }\n      return true;\n    }\n\n    computeCenter(): FloatPoint {\n      this.center[0] = 0;\n      this.center[1] = 0;\n      const len = this.vertices.length;\n      for (let i = 0; i < len; ++i) {\n        this.center[0] += this.vertices[i][0];\n        this.center[1] += this.vertices[i][1];\n      }\n      this.center[0] /= len;\n      this.center[1] /= len;\n      return this.center;\n    }\n\n    static createRectangle(width: float, height: float): gdjs.Polygon {\n      const rect = new gdjs.Polygon();\n      rect.vertices.push([-width / 2.0, -height / 2.0]);\n      rect.vertices.push([+width / 2.0, -height / 2.0]);\n      rect.vertices.push([+width / 2.0, +height / 2.0]);\n      rect.vertices.push([-width / 2.0, +height / 2.0]);\n      return rect;\n    }\n\n    /**\n     * Do a collision test between two polygons.\n     * Please note that polygons must *convexes*!\n     *\n     * You can read the result but do not keep a reference to it as it's a static object\n     * reused between function calls. If you need to keep the results, use `copyCollisionTestResult`.\n     *\n     * Uses <a href=\"http://en.wikipedia.org/wiki/Hyperplane_separation_theorem\">Separating Axis Theorem </a>.<br>\n     * Based on <a href=\"http://www.codeproject.com/Articles/15573/2D-Polygon-Collision-Detection\">this</a>\n     * and <a href=\"http://stackoverflow.com/questions/5742329/problem-with-collision-response-sat\">this</a> article.\n     *\n     * @return A collision result. `collision` property is equal to true if polygons are overlapping. Do NOT keep a reference to this.\n     * @param p1 The first polygon\n     * @param p2 The second polygon\n     * @param ignoreTouchingEdges If true, then edges that are touching each other, without the polygons actually overlapping, won't be considered in collision.\n     */\n    static collisionTest(\n      p1: gdjs.Polygon,\n      p2: gdjs.Polygon,\n      ignoreTouchingEdges: boolean\n    ): CollisionTestResult {\n      //Algorithm core :\n      p1.computeEdges();\n      p2.computeEdges();\n      let edge = collisionTestStatics.edge;\n      const move_axis = collisionTestStatics.move_axis;\n      const result = collisionTestStatics.result;\n      let minDist = Number.MAX_VALUE;\n      edge[0] = 0;\n      edge[1] = 0;\n      edge[0] = 0;\n      edge[1] = 0;\n      result.collision = false;\n      result.move_axis[0] = 0;\n      result.move_axis[1] = 0;\n\n      //Iterate over all the edges composing the polygons\n      for (\n        let i = 0, len1 = p1.vertices.length, len2 = p2.vertices.length;\n        i < len1 + len2;\n        i++\n      ) {\n        if (i < len1) {\n          // or <=\n          edge = p1.edges[i];\n        } else {\n          edge = p2.edges[i - len1];\n        }\n        const axis = collisionTestStatics.axis;\n\n        //Get the axis to which polygons will be projected\n        axis[0] = -edge[1];\n        axis[1] = edge[0];\n        Polygon.normalise(axis);\n        const minMaxA = collisionTestStatics.minMaxA;\n        const minMaxB = collisionTestStatics.minMaxB;\n        Polygon.project(\n          axis,\n          p1,\n          //Do projection on the axis.\n          minMaxA\n        );\n        Polygon.project(axis, p2, minMaxB);\n\n        //If the projections on the axis do not overlap, then their is no collision\n        const dist = Polygon.distance(\n          minMaxA[0],\n          minMaxA[1],\n          minMaxB[0],\n          minMaxB[1]\n        );\n        if (dist > 0 || (dist === 0 && ignoreTouchingEdges)) {\n          result.collision = false;\n          result.move_axis[0] = 0;\n          result.move_axis[1] = 0;\n          return result;\n        }\n        const absDist = Math.abs(dist);\n        if (absDist < minDist) {\n          minDist = absDist;\n          move_axis[0] = axis[0];\n          move_axis[1] = axis[1];\n        }\n      }\n      result.collision = true;\n\n      //Ensure move axis is correctly oriented.\n      const p1Center = p1.computeCenter();\n      const p2Center = p2.computeCenter();\n      const d: FloatPoint = [\n        p1Center[0] - p2Center[0],\n        p1Center[1] - p2Center[1],\n      ];\n      if (Polygon.dotProduct(d, move_axis) < 0) {\n        move_axis[0] = -move_axis[0];\n        move_axis[1] = -move_axis[1];\n      }\n\n      //Add the magnitude to the move axis.\n      result.move_axis[0] = move_axis[0] * minDist;\n      result.move_axis[1] = move_axis[1] * minDist;\n      return result;\n    }\n\n    /**\n     * Do a raycast test.\n     * Please note that the polygon must be **convex**!\n     *\n     * You can read the result but do not keep a reference to it as it's a static object\n     * reused between function calls. If you need to keep the results, use `copyRaycastTestResult`.\n     *\n     * For some theory, check <a href=\"https://www.codeproject.com/Tips/862988/Find-the-Intersection-Point-of-Two-Line-Segments\">Find the Intersection Point of Two Line Segments</a>.\n     *\n     * @param poly The polygon to test\n     * @param startX The raycast start point X\n     * @param startY The raycast start point Y\n     * @param endX The raycast end point X\n     * @param endY The raycast end point Y\n     * @return A raycast result with the contact points and distances. Do NOT keep a reference to this.\n     */\n    static raycastTest(\n      poly: gdjs.Polygon,\n      startX: float,\n      startY: float,\n      endX: float,\n      endY: float\n    ): RaycastTestResult {\n      const result = raycastTestStatics.result;\n      result.collision = false;\n      if (poly.vertices.length < 2) {\n        return result;\n      }\n      poly.computeEdges();\n      const p = raycastTestStatics.p;\n      const q = raycastTestStatics.q;\n      const r = raycastTestStatics.r;\n      const s = raycastTestStatics.s;\n      let minSqDist = Number.MAX_VALUE;\n\n      // Ray segment: p + t*r, with p = start and r = end - start\n      p[0] = startX;\n      p[1] = startY;\n      r[0] = endX - startX;\n      r[1] = endY - startY;\n      for (let i = 0; i < poly.edges.length; i++) {\n        // Edge segment: q + u*s\n        q[0] = poly.vertices[i][0];\n        q[1] = poly.vertices[i][1];\n        s[0] = poly.edges[i][0];\n        s[1] = poly.edges[i][1];\n        const deltaQP = raycastTestStatics.deltaQP;\n        deltaQP[0] = q[0] - p[0];\n        deltaQP[1] = q[1] - p[1];\n        const crossRS = Polygon.crossProduct(r, s);\n        const t = Polygon.crossProduct(deltaQP, s) / crossRS;\n        const u = Polygon.crossProduct(deltaQP, r) / crossRS;\n\n        // Collinear\n        // One point intersection\n        if (\n          Math.abs(crossRS) <= 0.0001 &&\n          Math.abs(Polygon.crossProduct(deltaQP, r)) <= 0.0001\n        ) {\n          // Project the ray and the edge to work on floats, keeping linearity through t\n          const axis = raycastTestStatics.axis;\n          axis[0] = r[0];\n          axis[1] = r[1];\n          Polygon.normalise(axis);\n          const rayA = 0;\n          const rayB = Polygon.dotProduct(axis, r);\n          const edgeA = Polygon.dotProduct(axis, deltaQP);\n          const edgeB = Polygon.dotProduct(axis, [\n            deltaQP[0] + s[0],\n            deltaQP[1] + s[1],\n          ]);\n\n          // Get overlapping range\n          const minOverlap = Math.max(\n            Math.min(rayA, rayB),\n            Math.min(edgeA, edgeB)\n          );\n          const maxOverlap = Math.min(\n            Math.max(rayA, rayB),\n            Math.max(edgeA, edgeB)\n          );\n          if (minOverlap > maxOverlap) {\n            return result;\n          }\n          result.collision = true;\n\n          // Zero distance ray\n          if (rayB === 0) {\n            result.closeX = startX;\n            result.closeY = startY;\n            result.closeSqDist = 0;\n            result.farX = startX;\n            result.farY = startY;\n            result.farSqDist = 0;\n          }\n          const t1 = minOverlap / Math.abs(rayB);\n          const t2 = maxOverlap / Math.abs(rayB);\n          result.closeX = startX + t1 * r[0];\n          result.closeY = startY + t1 * r[1];\n          result.closeSqDist = t1 * t1 * (r[0] * r[0] + r[1] * r[1]);\n          result.farX = startX + t2 * r[0];\n          result.farY = startY + t2 * r[1];\n          result.farSqDist = t2 * t2 * (r[0] * r[0] + r[1] * r[1]);\n          return result;\n        } else {\n          if (crossRS !== 0 && 0 <= t && t <= 1 && 0 <= u && u <= 1) {\n            const x = p[0] + t * r[0];\n            const y = p[1] + t * r[1];\n            const sqDist =\n              (x - startX) * (x - startX) + (y - startY) * (y - startY);\n            if (sqDist < minSqDist) {\n              if (!result.collision) {\n                result.farX = x;\n                result.farY = y;\n                result.farSqDist = sqDist;\n              }\n              minSqDist = sqDist;\n              result.closeX = x;\n              result.closeY = y;\n              result.closeSqDist = sqDist;\n              result.collision = true;\n            } else {\n              result.farX = x;\n              result.farY = y;\n              result.farSqDist = sqDist;\n            }\n          }\n        }\n      }\n      return result;\n    }\n\n    //Tools functions :\n    static normalise(v: FloatPoint): void {\n      const len = Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n      if (len != 0) {\n        v[0] /= len;\n        v[1] /= len;\n      }\n    }\n\n    static dotProduct(a: FloatPoint, b: FloatPoint): float {\n      const dp = a[0] * b[0] + a[1] * b[1];\n      return dp;\n    }\n\n    static crossProduct(a: FloatPoint, b: FloatPoint): float {\n      const cp = a[0] * b[1] - a[1] * b[0];\n      return cp;\n    }\n\n    static project(\n      axis: FloatPoint,\n      p: gdjs.Polygon,\n      result: FloatPoint\n    ): void {\n      let dp = Polygon.dotProduct(axis, p.vertices[0]);\n      result[0] = dp;\n      result[1] = dp;\n      for (let i = 1, len = p.vertices.length; i < len; ++i) {\n        dp = Polygon.dotProduct(axis, p.vertices[i]);\n        if (dp < result[0]) {\n          result[0] = dp;\n        } else {\n          if (dp > result[1]) {\n            result[1] = dp;\n          }\n        }\n      }\n    }\n\n    static distance(minA: float, maxA: float, minB: float, maxB: float): float {\n      if (minA < minB) {\n        return minB - maxA;\n      } else {\n        return minA - maxB;\n      }\n    }\n\n    /**\n     * Check if a point is inside a polygon.\n     *\n     * Uses <a href=\"https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html\">PNPOLY</a> by W. Randolph Franklin.\n     *\n     * @param poly The polygon to test\n     * @param x The point x coordinate\n     * @param y The point y coordinate\n     * @return true if the point is inside the polygon\n     */\n    static isPointInside(poly: gdjs.Polygon, x: float, y: float): boolean {\n      let inside = false;\n      for (\n        let i = 0, j = poly.vertices.length - 1;\n        i < poly.vertices.length;\n        j = i++\n      ) {\n        let vi = poly.vertices[i];\n        let vj = poly.vertices[j];\n        if (\n          vi[1] > y != vj[1] > y &&\n          x < ((vj[0] - vi[0]) * (y - vi[1])) / (vj[1] - vi[1]) + vi[0]\n        ) {\n          inside = !inside;\n        }\n      }\n      return inside;\n    }\n\n    /**\n     * Copy a `CollisionTestResult` into another one.\n     * Use `gdjs.Polygon.makeNewCollisionTestResult()` to build a new\n     * destination before copying the existing source inside it.\n     */\n    static copyCollisionTestResult(\n      source: CollisionTestResult,\n      dest: CollisionTestResult\n    ) {\n      dest.collision = source.collision;\n      dest.move_axis[0] = source.move_axis[0];\n      dest.move_axis[1] = source.move_axis[1];\n    }\n\n    static makeNewCollisionTestResult = makeNewCollisionTestResult;\n\n    /**\n     * Copy a `RaycastTestResult` into another one.\n     * Use `gdjs.Polygon.makeNewRaycastTestResult()` to build a new\n     * destination before copying the existing source inside it.\n     */\n    static copyRaycastTestResult(\n      source: RaycastTestResult,\n      dest: RaycastTestResult\n    ) {\n      dest.collision = source.collision;\n      dest.closeX = source.closeX;\n      dest.closeY = source.closeY;\n      dest.closeSqDist = source.closeSqDist;\n      dest.farX = source.farX;\n      dest.farY = source.farY;\n      dest.farSqDist = source.farSqDist;\n    }\n\n    static makeNewRaycastTestResult = makeNewRaycastTestResult;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
