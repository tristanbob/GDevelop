{
  "version": 3,
  "sources": ["../../../../../GDJS/Runtime/layer.ts"],
  "sourcesContent": ["/*\n * GDevelop JS Platform\n * Copyright 2013-2016 Florian Rival (Florian.Rival@gmail.com). All rights reserved.\n * This project is released under the MIT License.\n */\nnamespace gdjs {\n  /**\n   * Represents a layer of a scene, used to display objects.\n   */\n  export class Layer extends gdjs.RuntimeLayer {\n    _cameraRotation: float = 0;\n    _zoomFactor: float = 1;\n    _cameraX: float;\n    _cameraY: float;\n    _cameraZ: float = 0;\n    /**\n     * `_cameraZ` is dirty when the zoom factor is set last.\n     */\n    _isCameraZDirty: boolean = true;\n\n    /**\n     * @param layerData The data used to initialize the layer\n     * @param instanceContainer The container in which the layer is used\n     */\n    constructor(\n      layerData: LayerData,\n      instanceContainer: gdjs.RuntimeInstanceContainer\n    ) {\n      super(layerData, instanceContainer);\n\n      this._cameraX = this.getWidth() / 2;\n      this._cameraY = this.getHeight() / 2;\n\n      // Let the renderer do its final set up:\n      this._renderer.onCreated();\n    }\n\n    /**\n     * Called by the RuntimeScene whenever the game resolution size is changed.\n     * Updates the layer width/height and position.\n     */\n    onGameResolutionResized(\n      oldGameResolutionOriginX: float,\n      oldGameResolutionOriginY: float\n    ): void {\n      // Adapt position of the camera center as:\n      // * Most cameras following a player/object on the scene will be updating this\n      // in events anyway.\n      // * Cameras not following a player/object are usually UIs which are intuitively\n      // expected not to \"move\". Not adapting the center position would make the camera\n      // move from its initial position (which is centered in the screen) - and anchor\n      // behavior would behave counterintuitively.\n      this._cameraX +=\n        this._runtimeScene.getViewportOriginX() - oldGameResolutionOriginX;\n      this._cameraY +=\n        this._runtimeScene.getViewportOriginY() - oldGameResolutionOriginY;\n      this._renderer.updatePosition();\n    }\n\n    /**\n     * Change the camera center X position.\n     *\n     * @param cameraId The camera number. Currently ignored.\n     * @return The x position of the camera\n     */\n    getCameraX(cameraId?: integer): float {\n      this._forceDimensionUpdate();\n      return this._cameraX;\n    }\n\n    /**\n     * Change the camera center Y position.\n     *\n     * @param cameraId The camera number. Currently ignored.\n     * @return The y position of the camera\n     */\n    getCameraY(cameraId?: integer): float {\n      this._forceDimensionUpdate();\n      return this._cameraY;\n    }\n\n    /**\n     * Set the camera center X position.\n     *\n     * @param x The new x position\n     * @param cameraId The camera number. Currently ignored.\n     */\n    setCameraX(x: float, cameraId?: integer): void {\n      this._forceDimensionUpdate();\n      this._cameraX = x;\n      this._renderer.updatePosition();\n    }\n\n    /**\n     * Set the camera center Y position.\n     *\n     * @param y The new y position\n     * @param cameraId The camera number. Currently ignored.\n     */\n    setCameraY(y: float, cameraId?: integer): void {\n      this._forceDimensionUpdate();\n      this._cameraY = y;\n      this._renderer.updatePosition();\n    }\n\n    /**\n     * Get the camera width (which can be different than the game resolution width\n     * if the camera is zoomed).\n     *\n     * @param cameraId The camera number. Currently ignored.\n     * @return The width of the camera\n     */\n    getCameraWidth(cameraId?: integer): float {\n      return this.getWidth() / this._zoomFactor;\n    }\n\n    /**\n     * Get the camera height (which can be different than the game resolution height\n     * if the camera is zoomed).\n     *\n     * @param cameraId The camera number. Currently ignored.\n     * @return The height of the camera\n     */\n    getCameraHeight(cameraId?: integer): float {\n      return this.getHeight() / this._zoomFactor;\n    }\n\n    /**\n     * Set the zoom of a camera.\n     *\n     * @param newZoom The new zoom. Must be superior to 0. 1 is the default zoom.\n     * @param cameraId The camera number. Currently ignored.\n     */\n    setCameraZoom(newZoom: float, cameraId?: integer): void {\n      this._zoomFactor = newZoom;\n      this._isCameraZDirty = true;\n      this._renderer.updatePosition();\n    }\n\n    /**\n     * Get the zoom of a camera.\n     *\n     * @param cameraId The camera number. Currently ignored.\n     * @return The zoom.\n     */\n    getCameraZoom(cameraId?: integer): float {\n      return this._zoomFactor;\n    }\n\n    /**\n     * Set the camera center Z position.\n     *\n     * @param z The new y position.\n     * @param fov The field of view.\n     * @param cameraId The camera number. Currently ignored.\n     */\n    setCameraZ(z: float, fov: float = 45, cameraId?: integer): void {\n      const cameraFovInRadians = gdjs.toRad(fov);\n\n      // The zoom factor is capped to a not too big value to avoid infinity.\n      // MAX_SAFE_INTEGER is an arbitrary choice. It's big but not too big.\n      const zoomFactor = Math.min(\n        Number.MAX_SAFE_INTEGER,\n        (0.5 * this.getHeight()) / (z * Math.tan(0.5 * cameraFovInRadians))\n      );\n\n      if (zoomFactor > 0) {\n        this._zoomFactor = zoomFactor;\n      }\n\n      this._cameraZ = z;\n      this._isCameraZDirty = false;\n      this._renderer.updatePosition();\n    }\n\n    /**\n     * Get the camera center Z position.\n     *\n     * @param fov The field of view.\n     * @param cameraId The camera number. Currently ignored.\n     * @return The z position of the camera\n     */\n    getCameraZ(fov: float = 45, cameraId?: integer): float {\n      if (!this._isCameraZDirty) {\n        return this._cameraZ;\n      }\n\n      // Set the camera so that it displays the whole PixiJS plane, as if it was a 2D rendering.\n      // The Z position is computed by taking the half height of the displayed rendering,\n      // and using the angle of the triangle defined by the field of view to compute the length\n      // of the triangle defining the distance between the camera and the rendering plane.\n      const cameraZPosition =\n        (0.5 * this.getHeight()) /\n        this.getCameraZoom() /\n        Math.tan(0.5 * gdjs.toRad(fov));\n\n      return cameraZPosition;\n    }\n\n    /**\n     * Get the rotation of the camera, expressed in degrees.\n     *\n     * @param cameraId The camera number. Currently ignored.\n     * @return The rotation, in degrees.\n     */\n    getCameraRotation(cameraId?: integer): float {\n      return this._cameraRotation;\n    }\n\n    /**\n     * Set the rotation of the camera, expressed in degrees.\n     * The rotation is made around the camera center.\n     *\n     * @param rotation The new rotation, in degrees.\n     * @param cameraId The camera number. Currently ignored.\n     */\n    setCameraRotation(rotation: float, cameraId?: integer): void {\n      this._cameraRotation = rotation;\n      this._renderer.updatePosition();\n    }\n\n    /**\n     * Convert a point from the canvas coordinates (for example,\n     * the mouse position) to the container coordinates.\n     *\n     * This method handles 3D rotations.\n     *\n     * @param x The x position, in canvas coordinates.\n     * @param y The y position, in canvas coordinates.\n     * @param cameraId The camera number. Currently ignored.\n     * @param result The point instance that is used to return the result.\n     */\n    convertCoords(\n      x: float,\n      y: float,\n      cameraId: integer = 0,\n      result: FloatPoint\n    ): FloatPoint {\n      // This code duplicates applyLayerInverseTransformation for performance reasons;\n\n      // The result parameter used to be optional.\n      let position = result || [0, 0];\n\n      if (this._renderer.isCameraRotatedIn3D()) {\n        return this._renderer.transformTo3DWorld(x, y, 0, cameraId, result);\n      }\n\n      x -= this.getRuntimeScene()._cachedGameResolutionWidth / 2;\n      y -= this.getRuntimeScene()._cachedGameResolutionHeight / 2;\n      x /= Math.abs(this._zoomFactor);\n      y /= Math.abs(this._zoomFactor);\n\n      // Only compute angle and cos/sin once (allow heavy optimization from JS engines).\n      const angleInRadians = (this._cameraRotation / 180) * Math.PI;\n      const tmp = x;\n      const cosValue = Math.cos(angleInRadians);\n      const sinValue = Math.sin(angleInRadians);\n      x = cosValue * x - sinValue * y;\n      y = sinValue * tmp + cosValue * y;\n      position[0] = x + this.getCameraX(cameraId);\n      position[1] = y + this.getCameraY(cameraId);\n      return position;\n    }\n\n    /**\n     * Return an array containing the coordinates of the point passed as parameter\n     * in layer local coordinates (as opposed to the parent coordinates).\n     *\n     * All transformations (scale, rotation) are supported.\n     *\n     * This method doesn't handle 3D rotations.\n     *\n     * @param x The X position of the point, in parent coordinates.\n     * @param y The Y position of the point, in parent coordinates.\n     * @param result Array that will be updated with the result\n     * @param result The point instance that is used to return the result.\n     * (x and y position of the point in layer coordinates).\n     */\n    applyLayerInverseTransformation(\n      x: float,\n      y: float,\n      cameraId: integer,\n      result: FloatPoint\n    ): FloatPoint {\n      x -= this._runtimeScene.getViewportOriginX();\n      y -= this._runtimeScene.getViewportOriginY();\n      x /= Math.abs(this._zoomFactor);\n      y /= Math.abs(this._zoomFactor);\n\n      // Only compute angle and cos/sin once (allow heavy optimization from JS engines).\n      const angleInRadians = (this._cameraRotation / 180) * Math.PI;\n      const tmp = x;\n      const cosValue = Math.cos(angleInRadians);\n      const sinValue = Math.sin(angleInRadians);\n      x = cosValue * x - sinValue * y;\n      y = sinValue * tmp + cosValue * y;\n      result[0] = x + this.getCameraX(cameraId);\n      result[1] = y + this.getCameraY(cameraId);\n\n      return result;\n    }\n\n    /**\n     * Convert a point from the container coordinates (for example,\n     * an object position) to the canvas coordinates.\n     *\n     * This method doesn't handle 3D rotations.\n     *\n     * @param x The x position, in container coordinates.\n     * @param y The y position, in container coordinates.\n     * @param cameraId The camera number. Currently ignored.\n     * @param result The point instance that is used to return the result.\n     */\n    convertInverseCoords(\n      x: float,\n      y: float,\n      cameraId: integer = 0,\n      result: FloatPoint\n    ): FloatPoint {\n      // This code duplicates applyLayerTransformation for performance reasons;\n\n      // The result parameter used to be optional.\n      let position = result || [0, 0];\n      x -= this.getCameraX(cameraId);\n      y -= this.getCameraY(cameraId);\n\n      // Only compute angle and cos/sin once (allow heavy optimization from JS engines).\n      const angleInRadians = (this._cameraRotation / 180) * Math.PI;\n      const tmp = x;\n      const cosValue = Math.cos(-angleInRadians);\n      const sinValue = Math.sin(-angleInRadians);\n      x = cosValue * x - sinValue * y;\n      y = sinValue * tmp + cosValue * y;\n      x *= Math.abs(this._zoomFactor);\n      y *= Math.abs(this._zoomFactor);\n      position[0] = x + this.getRuntimeScene()._cachedGameResolutionWidth / 2;\n      position[1] = y + this.getRuntimeScene()._cachedGameResolutionHeight / 2;\n      return position;\n    }\n\n    /**\n     * Return an array containing the coordinates of the point passed as parameter\n     * in parent coordinate coordinates (as opposed to the layer local coordinates).\n     *\n     * All transformations (scale, rotation) are supported.\n     *\n     * This method doesn't handle 3D rotations.\n     *\n     * @param x The X position of the point, in layer coordinates.\n     * @param y The Y position of the point, in layer coordinates.\n     * @param result Array that will be updated with the result\n     * (x and y position of the point in parent coordinates).\n     */\n    applyLayerTransformation(\n      x: float,\n      y: float,\n      cameraId: integer,\n      result: FloatPoint\n    ): FloatPoint {\n      x -= this.getCameraX(cameraId);\n      y -= this.getCameraY(cameraId);\n\n      // Only compute angle and cos/sin once (allow heavy optimization from JS engines).\n      const angleInRadians = (this._cameraRotation / 180) * Math.PI;\n      const tmp = x;\n      const cosValue = Math.cos(-angleInRadians);\n      const sinValue = Math.sin(-angleInRadians);\n      x = cosValue * x - sinValue * y;\n      y = sinValue * tmp + cosValue * y;\n      x *= Math.abs(this._zoomFactor);\n      y *= Math.abs(this._zoomFactor);\n      x += this._runtimeScene.getViewportOriginX();\n      y += this._runtimeScene.getViewportOriginY();\n\n      result[0] = x;\n      result[1] = y;\n      return result;\n    }\n\n    /**\n     * This ensure that the viewport dimensions are up to date.\n     *\n     * It's needed because custom objects dimensions are only updated on\n     * demand for efficiency reasons.\n     */\n    private _forceDimensionUpdate(): void {\n      // This will update dimensions.\n      this._runtimeScene.getViewportWidth();\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
