{
  "version": 3,
  "sources": ["../../../../../GDJS/Runtime/RuntimeLayer.ts"],
  "sourcesContent": ["/*\n * GDevelop JS Platform\n * Copyright 2013-2016 Florian Rival (Florian.Rival@gmail.com). All rights reserved.\n * This project is released under the MIT License.\n */\nnamespace gdjs {\n  export enum RuntimeLayerRenderingType {\n    TWO_D,\n    THREE_D,\n    TWO_D_PLUS_THREE_D,\n  }\n\n  const getRenderingTypeFromString = (\n    renderingTypeAsString: string | undefined\n  ) =>\n    renderingTypeAsString === '3d'\n      ? RuntimeLayerRenderingType.THREE_D\n      : renderingTypeAsString === '2d+3d' || renderingTypeAsString === ''\n      ? RuntimeLayerRenderingType.TWO_D_PLUS_THREE_D\n      : RuntimeLayerRenderingType.TWO_D;\n\n  /**\n   * Represents a layer of a \"container\", used to display objects.\n   * The container can be a scene (see gdjs.Layer)\n   * or a custom object (see gdjs.RuntimeCustomObjectLayer).\n   */\n  export abstract class RuntimeLayer implements EffectsTarget {\n    _name: string;\n    _renderingType: RuntimeLayerRenderingType;\n    _timeScale: float = 1;\n    _defaultZOrder: integer = 0;\n    _hidden: boolean;\n    _initialEffectsData: Array<EffectData>;\n\n    // TODO EBO Don't store scene layer related data in layers used by custom objects.\n    // (both these 3D settings and the lighting layer properties below).\n    _initialCamera3DFieldOfView: float;\n    _initialCamera3DFarPlaneDistance: float;\n    _initialCamera3DNearPlaneDistance: float;\n\n    _runtimeScene: gdjs.RuntimeInstanceContainer;\n    _effectsManager: gdjs.EffectsManager;\n\n    // Lighting layer properties.\n    _isLightingLayer: boolean;\n    _followBaseLayerCamera: boolean;\n    _clearColor: Array<integer>;\n\n    _rendererEffects: Record<string, gdjs.PixiFiltersTools.Filter> = {};\n    _renderer: gdjs.LayerRenderer;\n\n    /**\n     * @param layerData The data used to initialize the layer\n     * @param instanceContainer The container in which the layer is used\n     */\n    constructor(\n      layerData: LayerData,\n      instanceContainer: gdjs.RuntimeInstanceContainer\n    ) {\n      this._name = layerData.name;\n      this._renderingType = getRenderingTypeFromString(layerData.renderingType);\n      this._hidden = !layerData.visibility;\n      this._initialCamera3DFieldOfView = layerData.camera3DFieldOfView || 45;\n      this._initialCamera3DFarPlaneDistance =\n        layerData.camera3DFarPlaneDistance || 0.1;\n      this._initialCamera3DNearPlaneDistance =\n        layerData.camera3DNearPlaneDistance || 2000;\n      this._initialEffectsData = layerData.effects || [];\n      this._runtimeScene = instanceContainer;\n      this._effectsManager = instanceContainer.getGame().getEffectsManager();\n      this._isLightingLayer = layerData.isLightingLayer;\n      this._followBaseLayerCamera = layerData.followBaseLayerCamera;\n      this._clearColor = [\n        layerData.ambientLightColorR / 255,\n        layerData.ambientLightColorG / 255,\n        layerData.ambientLightColorB / 255,\n        1.0,\n      ];\n      this._renderer = new gdjs.LayerRenderer(\n        this,\n        instanceContainer.getRenderer(),\n        instanceContainer.getGame().getRenderer()\n      );\n      this.show(!this._hidden);\n      for (let i = 0; i < layerData.effects.length; ++i) {\n        this.addEffect(layerData.effects[i]);\n      }\n    }\n\n    getRenderer(): gdjs.LayerRenderer {\n      return this._renderer;\n    }\n\n    getRendererObject() {\n      return this._renderer.getRendererObject();\n    }\n\n    get3DRendererObject() {\n      return this._renderer.getThreeScene();\n    }\n\n    getRenderingType(): RuntimeLayerRenderingType {\n      return this._renderingType;\n    }\n\n    /**\n     * Get the default Z order to be attributed to objects created on this layer\n     * (usually from events generated code).\n     */\n    getDefaultZOrder(): float {\n      return this._defaultZOrder;\n    }\n\n    /**\n     * Set the default Z order to be attributed to objects created on this layer.\n     * @param defaultZOrder The Z order to use when creating a new object from events.\n     */\n    setDefaultZOrder(defaultZOrder: integer): void {\n      this._defaultZOrder = defaultZOrder;\n    }\n\n    /**\n     * Called by the RuntimeScene whenever the game resolution size is changed.\n     * Updates the layer width/height and position.\n     */\n    abstract onGameResolutionResized(\n      oldGameResolutionOriginX: float,\n      oldGameResolutionOriginY: float\n    ): void;\n\n    /**\n     * Returns the scene the layer belongs to directly or indirectly\n     * @returns the scene the layer belongs to directly or indirectly\n     */\n    getRuntimeScene(): gdjs.RuntimeScene {\n      return this._runtimeScene.getScene();\n    }\n\n    /**\n     * Called at each frame, after events are run and before rendering.\n     */\n    updatePreRender(instanceContainer?: gdjs.RuntimeInstanceContainer): void {\n      if (this._followBaseLayerCamera) {\n        this.followBaseLayer();\n      }\n      this._renderer.updatePreRender();\n      this._effectsManager.updatePreRender(this._rendererEffects, this);\n    }\n\n    /**\n     * Get the name of the layer\n     * @return The name of the layer\n     */\n    getName(): string {\n      return this._name;\n    }\n\n    /**\n     * Change the camera center X position.\n     *\n     * @param cameraId The camera number. Currently ignored.\n     * @return The x position of the camera\n     */\n    abstract getCameraX(cameraId?: integer): float;\n\n    /**\n     * Change the camera center Y position.\n     *\n     * @param cameraId The camera number. Currently ignored.\n     * @return The y position of the camera\n     */\n    abstract getCameraY(cameraId?: integer): float;\n\n    /**\n     * Set the camera center X position.\n     *\n     * @param x The new x position\n     * @param cameraId The camera number. Currently ignored.\n     */\n    abstract setCameraX(x: float, cameraId?: integer): void;\n\n    /**\n     * Set the camera center Y position.\n     *\n     * @param y The new y position\n     * @param cameraId The camera number. Currently ignored.\n     */\n    abstract setCameraY(y: float, cameraId?: integer): void;\n\n    /**\n     * Get the camera width (which can be different than the game resolution width\n     * if the camera is zoomed).\n     *\n     * @param cameraId The camera number. Currently ignored.\n     * @return The width of the camera\n     */\n    abstract getCameraWidth(cameraId?: integer): float;\n\n    /**\n     * Get the camera height (which can be different than the game resolution height\n     * if the camera is zoomed).\n     *\n     * @param cameraId The camera number. Currently ignored.\n     * @return The height of the camera\n     */\n    abstract getCameraHeight(cameraId?: integer): float;\n\n    /**\n     * Show (or hide) the layer.\n     * @param enable true to show the layer, false to hide it.\n     */\n    show(enable: boolean): void {\n      this._hidden = !enable;\n      this._renderer.updateVisibility(enable);\n    }\n\n    /**\n     * Check if the layer is visible.\n     *\n     * @return true if the layer is visible.\n     */\n    isVisible(): boolean {\n      return !this._hidden;\n    }\n\n    /**\n     * Set the zoom of a camera.\n     *\n     * @param newZoom The new zoom. Must be superior to 0. 1 is the default zoom.\n     * @param cameraId The camera number. Currently ignored.\n     */\n    abstract setCameraZoom(newZoom: float, cameraId?: integer): void;\n\n    /**\n     * Get the zoom of a camera.\n     *\n     * @param cameraId The camera number. Currently ignored.\n     * @return The zoom.\n     */\n    abstract getCameraZoom(cameraId?: integer): float;\n\n    /**\n     * Set the camera center Z position.\n     *\n     * @param z The new y position.\n     * @param fov The field of view.\n     * @param cameraId The camera number. Currently ignored.\n     */\n    abstract setCameraZ(z: float, fov: float, cameraId?: integer): void;\n\n    /**\n     * Get the camera center Z position.\n     *\n     * @param fov The field of view.\n     * @param cameraId The camera number. Currently ignored.\n     * @return The z position of the camera\n     */\n    abstract getCameraZ(fov: float, cameraId?: integer): float;\n\n    /**\n     * Get the rotation of the camera, expressed in degrees.\n     *\n     * @param cameraId The camera number. Currently ignored.\n     * @return The rotation, in degrees.\n     */\n    abstract getCameraRotation(cameraId?: integer): float;\n\n    /**\n     * Set the rotation of the camera, expressed in degrees.\n     * The rotation is made around the camera center.\n     *\n     * @param rotation The new rotation, in degrees.\n     * @param cameraId The camera number. Currently ignored.\n     */\n    abstract setCameraRotation(rotation: float, cameraId?: integer): void;\n\n    /**\n     * Convert a point from the canvas coordinates (for example,\n     * the mouse position) to the container coordinates.\n     *\n     * @param x The x position, in canvas coordinates.\n     * @param y The y position, in canvas coordinates.\n     * @param cameraId The camera number. Currently ignored.\n     * @param result The point instance that is used to return the result.\n     */\n    abstract convertCoords(\n      x: float,\n      y: float,\n      cameraId: integer,\n      result: FloatPoint\n    ): FloatPoint;\n\n    /**\n     * Return an array containing the coordinates of the point passed as parameter\n     * in parent coordinate coordinates (as opposed to the layer local coordinates).\n     *\n     * All transformations (scale, rotation) are supported.\n     *\n     * @param x The X position of the point, in layer coordinates.\n     * @param y The Y position of the point, in layer coordinates.\n     * @param result Array that will be updated with the result\n     * (x and y position of the point in parent coordinates).\n     */\n    abstract applyLayerTransformation(\n      x: float,\n      y: float,\n      cameraId: integer,\n      result: FloatPoint\n    ): FloatPoint;\n\n    /**\n     * Convert a point from the container coordinates (for example,\n     * an object position) to the canvas coordinates.\n     *\n     * @param x The x position, in container coordinates.\n     * @param y The y position, in container coordinates.\n     * @param cameraId The camera number. Currently ignored.\n     * @param result The point instance that is used to return the result.\n     */\n    abstract convertInverseCoords(\n      x: float,\n      y: float,\n      cameraId: integer,\n      result: FloatPoint\n    ): FloatPoint;\n\n    /**\n     * Return an array containing the coordinates of the point passed as parameter\n     * in layer local coordinates (as opposed to the parent coordinates).\n     *\n     * All transformations (scale, rotation) are supported.\n     *\n     * @param x The X position of the point, in parent coordinates.\n     * @param y The Y position of the point, in parent coordinates.\n     * @param result Array that will be updated with the result\n     * @param result The point instance that is used to return the result.\n     * (x and y position of the point in layer coordinates).\n     */\n    abstract applyLayerInverseTransformation(\n      x: float,\n      y: float,\n      cameraId: integer,\n      result: FloatPoint\n    ): FloatPoint;\n\n    getWidth(): float {\n      return this._runtimeScene.getViewportWidth();\n    }\n\n    getHeight(): float {\n      return this._runtimeScene.getViewportHeight();\n    }\n\n    getInitialCamera3DFieldOfView(): float {\n      return this._initialCamera3DFieldOfView;\n    }\n    getInitialCamera3DNearPlaneDistance(): float {\n      return this._initialCamera3DNearPlaneDistance;\n    }\n    getInitialCamera3DFarPlaneDistance(): float {\n      return this._initialCamera3DFarPlaneDistance;\n    }\n\n    /**\n     * Return the initial effects data for the layer. Only to\n     * be used by renderers.\n     * @deprecated\n     */\n    getInitialEffectsData(): EffectData[] {\n      return this._initialEffectsData;\n    }\n\n    /**\n     * Add a new effect, or replace the one with the same name.\n     * @param effectData The data of the effect to add.\n     */\n    addEffect(effectData: EffectData): void {\n      this._effectsManager.addEffect(effectData, this._rendererEffects, this);\n    }\n\n    /**\n     * Remove the effect with the specified name\n     * @param effectName The name of the effect.\n     */\n    removeEffect(effectName: string): void {\n      this._effectsManager.removeEffect(\n        this._rendererEffects,\n        this,\n        effectName\n      );\n    }\n\n    /**\n     * Change an effect parameter value (for parameters that are numbers).\n     * @param name The name of the effect to update.\n     * @param parameterName The name of the parameter to update.\n     * @param value The new value (number).\n     */\n    setEffectDoubleParameter(\n      name: string,\n      parameterName: string,\n      value: float\n    ): void {\n      this._effectsManager.setEffectDoubleParameter(\n        this._rendererEffects,\n        name,\n        parameterName,\n        value\n      );\n    }\n\n    /**\n     * Change an effect parameter value (for parameters that are strings).\n     * @param name The name of the effect to update.\n     * @param parameterName The name of the parameter to update.\n     * @param value The new value (string).\n     */\n    setEffectStringParameter(\n      name: string,\n      parameterName: string,\n      value: string\n    ): void {\n      this._effectsManager.setEffectStringParameter(\n        this._rendererEffects,\n        name,\n        parameterName,\n        value\n      );\n    }\n\n    /**\n     * Change an effect parameter value (for parameters that are booleans).\n     * @param name The name of the effect to update.\n     * @param parameterName The name of the parameter to update.\n     * @param value The new value (boolean).\n     */\n    setEffectBooleanParameter(\n      name: string,\n      parameterName: string,\n      value: boolean\n    ): void {\n      this._effectsManager.setEffectBooleanParameter(\n        this._rendererEffects,\n        name,\n        parameterName,\n        value\n      );\n    }\n\n    /**\n     * Enable or disable an effect.\n     * @param name The name of the effect to enable or disable.\n     * @param enable true to enable, false to disable\n     */\n    enableEffect(name: string, enable: boolean): void {\n      this._effectsManager.enableEffect(\n        this._rendererEffects,\n        this,\n        name,\n        enable\n      );\n    }\n\n    /**\n     * Check if an effect is enabled\n     * @param name The name of the effect\n     * @return true if the effect is enabled, false otherwise.\n     */\n    isEffectEnabled(name: string): boolean {\n      return this._effectsManager.isEffectEnabled(\n        this._rendererEffects,\n        this,\n        name\n      );\n    }\n\n    /**\n     * Check if an effect exists on this layer\n     * @param name The name of the effect\n     * @return true if the effect exists, false otherwise.\n     */\n    hasEffect(name: string): boolean {\n      return this._effectsManager.hasEffect(this._rendererEffects, name);\n    }\n\n    /**\n     * Set the time scale for the objects on the layer:\n     * time will be slower if time scale is < 1, faster if > 1.\n     * @param timeScale The new time scale (must be positive).\n     */\n    setTimeScale(timeScale: float): void {\n      if (timeScale >= 0) {\n        this._timeScale = timeScale;\n      }\n    }\n\n    /**\n     * Get the time scale for the objects on the layer.\n     */\n    getTimeScale(): float {\n      return this._timeScale;\n    }\n\n    /**\n     * Return the time elapsed since the last frame,\n     * in milliseconds, for objects on the layer.\n     *\n     * @param instanceContainer The instance container the layer belongs to (deprecated - can be omitted).\n     */\n    getElapsedTime(instanceContainer?: gdjs.RuntimeInstanceContainer): float {\n      const container = instanceContainer || this._runtimeScene;\n      return container.getElapsedTime() * this._timeScale;\n    }\n\n    /**\n     * Change the position, rotation and scale (zoom) of the layer camera to be the same as the base layer camera.\n     */\n    followBaseLayer(): void {\n      const baseLayer = this._runtimeScene.getLayer('');\n      this.setCameraX(baseLayer.getCameraX());\n      this.setCameraY(baseLayer.getCameraY());\n      this.setCameraRotation(baseLayer.getCameraRotation());\n      this.setCameraZoom(baseLayer.getCameraZoom());\n    }\n\n    /**\n     * The clear color is defined in the format [r, g, b], with components in the range of 0 to 1.\n     * @return the clear color of layer in the range of [0, 1].\n     */\n    getClearColor(): Array<integer> {\n      return this._clearColor;\n    }\n\n    /**\n     * Set the clear color in format [r, g, b], with components in the range of 0 to 1.;\n     * @param r Red color component in the range 0-255.\n     * @param g Green color component in the range 0-255.\n     * @param b Blue color component in the range 0-255.\n     */\n    setClearColor(r: integer, g: integer, b: integer): void {\n      this._clearColor[0] = r / 255;\n      this._clearColor[1] = g / 255;\n      this._clearColor[2] = b / 255;\n      this._renderer.updateClearColor();\n    }\n\n    /**\n     * Set whether layer's camera follows base layer's camera or not.\n     */\n    setFollowBaseLayerCamera(follow: boolean): void {\n      this._followBaseLayerCamera = follow;\n    }\n\n    /**\n     * Return true if the layer is a lighting layer, false otherwise.\n     * @return true if it is a lighting layer, false otherwise.\n     */\n    isLightingLayer(): boolean {\n      return this._isLightingLayer;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
