{
  "version": 3,
  "sources": ["../../../../../GDJS/Runtime/timemanager.ts"],
  "sourcesContent": ["/*\n * GDevelop JS Platform\n * Copyright 2013-2016 Florian Rival (Florian.Rival@gmail.com). All rights reserved.\n * This project is released under the MIT License.\n */\nnamespace gdjs {\n  /**\n   * Manage the timers and times elapsed during last\n   * frame, since the beginning of the scene and other time related values.\n   * All durations are expressed in milliseconds.\n   */\n  export class TimeManager {\n    _elapsedTime: float = 0;\n    _timeScale: float = 1;\n    _timeFromStart: float = 0;\n    _firstFrame: boolean = true;\n    _timers: Hashtable<gdjs.Timer> = new Hashtable();\n    _firstUpdateDone: boolean = false;\n\n    constructor() {\n      this.reset();\n    }\n\n    reset(): void {\n      this._elapsedTime = 0;\n      this._timeScale = 1;\n      this._timeFromStart = 0;\n      this._firstFrame = true;\n      this._timers = new Hashtable();\n    }\n\n    update(elapsedTime: float, minimumFPS: integer): void {\n      if (this._firstUpdateDone) {\n        this._firstFrame = false;\n      }\n      this._firstUpdateDone = true;\n\n      //Compute the elapsed time since last frame\n      this._elapsedTime = Math.min(elapsedTime, 1000 / minimumFPS);\n      this._elapsedTime *= this._timeScale;\n\n      //Update timers and others members\n      for (const name in this._timers.items) {\n        if (this._timers.items.hasOwnProperty(name)) {\n          this._timers.items[name].updateTime(this._elapsedTime);\n        }\n      }\n      this._timeFromStart += this._elapsedTime;\n    }\n\n    /**\n     * Set the time scale: time will be slower if time scale is < 1,\n     * faster if > 1.\n     * @param timeScale The new time scale (must be positive).\n     */\n    setTimeScale(timeScale: float): void {\n      if (timeScale >= 0) {\n        this._timeScale = timeScale;\n      }\n    }\n\n    /**\n     * Get the time scale.\n     * @return The time scale (positive, 1 is normal speed).\n     */\n    getTimeScale(): float {\n      return this._timeScale;\n    }\n\n    /**\n     * Get the time since the instantiation of the manager (i.e: since\n     * the beginning of the scene most of the time), in milliseconds.\n     */\n    getTimeFromStart(): float {\n      return this._timeFromStart;\n    }\n\n    /**\n     * Return true if update was called only once (i.e: if the scene\n     * is rendering its first frame).\n     */\n    isFirstFrame(): boolean {\n      return this._firstFrame;\n    }\n\n    /**\n     * Return the time elapsed since the last call to update\n     * (i.e: the last frame), in milliseconds.\n     */\n    getElapsedTime(): float {\n      return this._elapsedTime;\n    }\n\n    addTimer(name: string): void {\n      this._timers.put(name, new gdjs.Timer(name));\n    }\n\n    hasTimer(name: string): boolean {\n      return this._timers.containsKey(name);\n    }\n\n    getTimer(name: string): gdjs.Timer {\n      return this._timers.get(name);\n    }\n\n    removeTimer(name: string): void {\n      if (this._timers.containsKey(name)) {\n        this._timers.remove(name);\n      }\n    }\n  }\n}\n"],
  "mappings": "AAKA,GAAU,MAAV,UAAU,EAAV,CAMS,OAAkB,CAQvB,aAAc,CAPd,kBAAsB,EACtB,gBAAoB,EACpB,oBAAwB,EACxB,iBAAuB,GACvB,aAAiC,GAAI,WACrC,sBAA4B,GAG1B,KAAK,QAGP,OAAc,CACZ,KAAK,aAAe,EACpB,KAAK,WAAa,EAClB,KAAK,eAAiB,EACtB,KAAK,YAAc,GACnB,KAAK,QAAU,GAAI,WAGrB,OAAO,EAAoB,EAA2B,CACpD,AAAI,KAAK,kBACP,MAAK,YAAc,IAErB,KAAK,iBAAmB,GAGxB,KAAK,aAAe,KAAK,IAAI,EAAa,IAAO,GACjD,KAAK,cAAgB,KAAK,WAG1B,SAAW,KAAQ,MAAK,QAAQ,MAC9B,AAAI,KAAK,QAAQ,MAAM,eAAe,IACpC,KAAK,QAAQ,MAAM,GAAM,WAAW,KAAK,cAG7C,KAAK,gBAAkB,KAAK,aAQ9B,aAAa,EAAwB,CACnC,AAAI,GAAa,GACf,MAAK,WAAa,GAQtB,cAAsB,CACpB,MAAO,MAAK,WAOd,kBAA0B,CACxB,MAAO,MAAK,eAOd,cAAwB,CACtB,MAAO,MAAK,YAOd,gBAAwB,CACtB,MAAO,MAAK,aAGd,SAAS,EAAoB,CAC3B,KAAK,QAAQ,IAAI,EAAM,GAAI,GAAK,MAAM,IAGxC,SAAS,EAAuB,CAC9B,MAAO,MAAK,QAAQ,YAAY,GAGlC,SAAS,EAA0B,CACjC,MAAO,MAAK,QAAQ,IAAI,GAG1B,YAAY,EAAoB,CAC9B,AAAI,KAAK,QAAQ,YAAY,IAC3B,KAAK,QAAQ,OAAO,IAhGnB,EAAM,gBANL",
  "names": []
}
