{
  "version": 3,
  "sources": ["../../../../../GDJS/Runtime/profiler.ts"],
  "sourcesContent": ["namespace gdjs {\n  export type ProfilerStats = {\n    framesCount: integer;\n  };\n\n  export type FrameMeasure = {\n    parent: FrameMeasure | null;\n    time: float;\n    lastStartTime: float;\n    subsections: Record<string, FrameMeasure>;\n  };\n\n  /**\n   * A basic profiling tool that can be used to measure time spent in sections of the engine.\n   */\n  export class Profiler {\n    /** All the measures for the last frames */\n    _framesMeasures: Array<FrameMeasure> = [];\n\n    _currentFrameIndex: float = 0;\n\n    /** The measures being done */\n    _currentFrameMeasure: FrameMeasure = {\n      parent: null,\n      time: 0,\n      lastStartTime: 0,\n      subsections: {},\n    };\n\n    /** The section being measured */\n    _currentSection: FrameMeasure | null = null;\n\n    _maxFramesCount: number = 600;\n\n    /** The number of frames that have been measured */\n    _framesCount: number = 0;\n\n    /** A function to get the current time. If available, corresponds to performance.now(). */\n    _getTimeNow: () => float;\n\n    constructor() {\n      while (this._framesMeasures.length < this._maxFramesCount) {\n        this._framesMeasures.push({\n          parent: null,\n          time: 0,\n          lastStartTime: 0,\n          subsections: {},\n        });\n      }\n      this._getTimeNow =\n        window.performance && typeof window.performance.now === 'function'\n          ? window.performance.now.bind(window.performance)\n          : Date.now;\n    }\n\n    beginFrame(): void {\n      this._currentFrameMeasure = {\n        parent: null,\n        time: 0,\n        lastStartTime: this._getTimeNow(),\n        subsections: {},\n      };\n      this._currentSection = this._currentFrameMeasure;\n    }\n\n    begin(sectionName: string): void {\n      if (this._currentSection === null)\n        throw new Error(\n          'Impossible to call Profiler.begin() when not profiling a frame!'\n        );\n\n      // Push the new section\n      const subsections = this._currentSection.subsections;\n      const subsection = (subsections[sectionName] = subsections[\n        sectionName\n      ] || {\n        parent: this._currentSection,\n        time: 0,\n        lastStartTime: 0,\n        subsections: {},\n      });\n      this._currentSection = subsection;\n\n      // Start the timer\n      this._currentSection.lastStartTime = this._getTimeNow();\n    }\n\n    end(sectionName?: string): void {\n      if (this._currentSection === null)\n        throw new Error(\n          'Impossible to call Profiler.end() when not profiling a frame!'\n        );\n\n      // Stop the timer\n      const sectionTime =\n        this._getTimeNow() - this._currentSection.lastStartTime;\n      this._currentSection.time =\n        (this._currentSection.time || 0) + sectionTime;\n\n      // Pop the section\n      if (this._currentSection.parent !== null)\n        this._currentSection = this._currentSection.parent;\n    }\n\n    endFrame(): void {\n      if (this._currentSection === null)\n        throw new Error(\n          'Impossible to end profiling a frame when profiling has not started a frame!'\n        );\n      if (this._currentSection.parent !== null) {\n        throw new Error(\n          'Mismatch in profiler, endFrame should be called on root section'\n        );\n      }\n      this.end();\n      this._framesCount++;\n      if (this._framesCount > this._maxFramesCount) {\n        this._framesCount = this._maxFramesCount;\n      }\n      this._framesMeasures[this._currentFrameIndex] = this\n        ._currentFrameMeasure as FrameMeasure;\n      this._currentFrameIndex++;\n      if (this._currentFrameIndex >= this._maxFramesCount) {\n        this._currentFrameIndex = 0;\n      }\n    }\n\n    static _addAverageSectionTimes(\n      section: FrameMeasure,\n      destinationSection: FrameMeasure,\n      totalCount: integer,\n      i: integer\n    ): void {\n      destinationSection.time =\n        (destinationSection.time || 0) + section.time / totalCount;\n      for (const sectionName in section.subsections) {\n        if (section.subsections.hasOwnProperty(sectionName)) {\n          const destinationSubsections = destinationSection.subsections;\n          const destinationSubsection = (destinationSubsections[\n            sectionName\n          ] = destinationSubsections[sectionName] || {\n            parent: destinationSection,\n            time: 0,\n            subsections: {},\n          });\n          Profiler._addAverageSectionTimes(\n            section.subsections[sectionName],\n            destinationSubsection,\n            totalCount,\n            i\n          );\n        }\n      }\n    }\n\n    /**\n     * Return the measures for all the section of the game during the frames\n     * captured.\n     */\n    getFramesAverageMeasures(): FrameMeasure {\n      const framesAverageMeasures = {\n        parent: null,\n        time: 0,\n        lastStartTime: 0,\n        subsections: {},\n      };\n      for (let i = 0; i < this._framesCount; ++i) {\n        Profiler._addAverageSectionTimes(\n          this._framesMeasures[i],\n          framesAverageMeasures,\n          this._framesCount,\n          i\n        );\n      }\n      return framesAverageMeasures;\n    }\n\n    /**\n     * Get stats measured during the frames captured.\n     */\n    getStats(): ProfilerStats {\n      return { framesCount: this._framesCount };\n    }\n\n    /**\n     * Convert measures for a section into texts.\n     * Useful for ingame profiling.\n     *\n     * @param sectionName The name of the section\n     * @param profilerSection The section measures\n     * @param outputs The array where to push the results\n     */\n    static getProfilerSectionTexts(\n      sectionName: string,\n      profilerSection: any,\n      outputs: any\n    ): void {\n      const percent =\n        profilerSection.parent && profilerSection.parent.time !== 0\n          ? (\n              (profilerSection.time / profilerSection.parent.time) *\n              100\n            ).toFixed(1)\n          : '100%';\n      const time = profilerSection.time.toFixed(2);\n      outputs.push(sectionName + ': ' + time + 'ms (' + percent + ')');\n      const subsectionsOutputs = [];\n      for (const subsectionName in profilerSection.subsections) {\n        if (profilerSection.subsections.hasOwnProperty(subsectionName)) {\n          Profiler.getProfilerSectionTexts(\n            subsectionName,\n            profilerSection.subsections[subsectionName],\n            subsectionsOutputs\n          );\n        }\n      }\n      outputs.push.apply(outputs, subsectionsOutputs);\n    }\n  }\n}\n"],
  "mappings": "AAAA,GAAU,MAAV,UAAU,EAAV,CAeS,OAAe,CAyBpB,aAAc,CAvBd,qBAAuC,GAEvC,wBAA4B,EAG5B,0BAAqC,CACnC,OAAQ,KACR,KAAM,EACN,cAAe,EACf,YAAa,IAIf,qBAAuC,KAEvC,qBAA0B,IAG1B,kBAAuB,EAMrB,KAAO,KAAK,gBAAgB,OAAS,KAAK,iBACxC,KAAK,gBAAgB,KAAK,CACxB,OAAQ,KACR,KAAM,EACN,cAAe,EACf,YAAa,KAGjB,KAAK,YACH,OAAO,aAAe,MAAO,QAAO,YAAY,KAAQ,WACpD,OAAO,YAAY,IAAI,KAAK,OAAO,aACnC,KAAK,IAGb,YAAmB,CACjB,KAAK,qBAAuB,CAC1B,OAAQ,KACR,KAAM,EACN,cAAe,KAAK,cACpB,YAAa,IAEf,KAAK,gBAAkB,KAAK,qBAG9B,MAAM,EAA2B,CAC/B,GAAI,KAAK,kBAAoB,KAC3B,KAAM,IAAI,OACR,mEAIJ,KAAM,GAAc,KAAK,gBAAgB,YACnC,EAAc,EAAY,GAAe,EAC7C,IACG,CACH,OAAQ,KAAK,gBACb,KAAM,EACN,cAAe,EACf,YAAa,IAEf,KAAK,gBAAkB,EAGvB,KAAK,gBAAgB,cAAgB,KAAK,cAG5C,IAAI,EAA4B,CAC9B,GAAI,KAAK,kBAAoB,KAC3B,KAAM,IAAI,OACR,iEAIJ,KAAM,GACJ,KAAK,cAAgB,KAAK,gBAAgB,cAC5C,KAAK,gBAAgB,KAClB,MAAK,gBAAgB,MAAQ,GAAK,EAGjC,KAAK,gBAAgB,SAAW,MAClC,MAAK,gBAAkB,KAAK,gBAAgB,QAGhD,UAAiB,CACf,GAAI,KAAK,kBAAoB,KAC3B,KAAM,IAAI,OACR,+EAEJ,GAAI,KAAK,gBAAgB,SAAW,KAClC,KAAM,IAAI,OACR,mEAGJ,KAAK,MACL,KAAK,eACD,KAAK,aAAe,KAAK,iBAC3B,MAAK,aAAe,KAAK,iBAE3B,KAAK,gBAAgB,KAAK,oBAAsB,KAC7C,qBACH,KAAK,qBACD,KAAK,oBAAsB,KAAK,iBAClC,MAAK,mBAAqB,SAIvB,yBACL,EACA,EACA,EACA,EACM,CACN,EAAmB,KAChB,GAAmB,MAAQ,GAAK,EAAQ,KAAO,EAClD,SAAW,KAAe,GAAQ,YAChC,GAAI,EAAQ,YAAY,eAAe,GAAc,CACnD,KAAM,GAAyB,EAAmB,YAC5C,EAAyB,EAC7B,GACE,EAAuB,IAAgB,CACzC,OAAQ,EACR,KAAM,EACN,YAAa,IAEf,EAAS,wBACP,EAAQ,YAAY,GACpB,EACA,EACA,IAUR,0BAAyC,CACvC,KAAM,GAAwB,CAC5B,OAAQ,KACR,KAAM,EACN,cAAe,EACf,YAAa,IAEf,OAAS,GAAI,EAAG,EAAI,KAAK,aAAc,EAAE,EACvC,EAAS,wBACP,KAAK,gBAAgB,GACrB,EACA,KAAK,aACL,GAGJ,MAAO,GAMT,UAA0B,CACxB,MAAO,CAAE,YAAa,KAAK,oBAWtB,yBACL,EACA,EACA,EACM,CACN,KAAM,GACJ,EAAgB,QAAU,EAAgB,OAAO,OAAS,EAEnD,GAAgB,KAAO,EAAgB,OAAO,KAC/C,KACA,QAAQ,GACV,OACA,EAAO,EAAgB,KAAK,QAAQ,GAC1C,EAAQ,KAAK,EAAc,KAAO,EAAO,OAAS,EAAU,KAC5D,KAAM,GAAqB,GAC3B,SAAW,KAAkB,GAAgB,YAC3C,AAAI,EAAgB,YAAY,eAAe,IAC7C,EAAS,wBACP,EACA,EAAgB,YAAY,GAC5B,GAIN,EAAQ,KAAK,MAAM,EAAS,IAzMzB,EAAM,aAfL",
  "names": []
}
