{
  "version": 3,
  "sources": ["../../../../../GDJS/Runtime/RuntimeInstanceContainer.ts"],
  "sourcesContent": ["/*\n * GDevelop JS Platform\n * Copyright 2013-2016 Florian Rival (Florian.Rival@gmail.com). All rights reserved.\n * This project is released under the MIT License.\n */\nnamespace gdjs {\n  const logger = new gdjs.Logger('RuntimeInstanceContainer');\n\n  /**\n   * A container of object instances rendered on screen.\n   */\n  export abstract class RuntimeInstanceContainer {\n    _initialBehaviorSharedData: Hashtable<BehaviorSharedData | null>;\n\n    /** Contains the instances living on the container */\n    _instances: Hashtable<RuntimeObject[]>;\n\n    /**\n     * An array used to create a list of all instance when necessary.\n     * @see gdjs.RuntimeInstanceContainer#_constructListOfAllInstances}\n     */\n    private _allInstancesList: gdjs.RuntimeObject[] = [];\n    _allInstancesListIsUpToDate = true;\n\n    /** Used to recycle destroyed instance instead of creating new ones. */\n    _instancesCache: Hashtable<RuntimeObject[]>;\n\n    /** The instances removed from the container and waiting to be sent to the cache. */\n    _instancesRemoved: gdjs.RuntimeObject[] = [];\n\n    /** Contains the objects data stored in the project */\n    _objects: Hashtable<ObjectData>;\n    _objectsCtor: Hashtable<typeof RuntimeObject>;\n\n    _layers: Hashtable<RuntimeLayer>;\n    _orderedLayers: RuntimeLayer[]; // TODO: should this be a single structure with _layers, to enforce its usage?\n    _layersCameraCoordinates: Record<string, [float, float, float, float]> = {};\n\n    // Options for the debug draw:\n    _debugDrawEnabled: boolean = false;\n    _debugDrawShowHiddenInstances: boolean = false;\n    _debugDrawShowPointsNames: boolean = false;\n    _debugDrawShowCustomPoints: boolean = false;\n\n    constructor() {\n      this._initialBehaviorSharedData = new Hashtable();\n      this._instances = new Hashtable();\n      this._instancesCache = new Hashtable();\n      this._objects = new Hashtable();\n      this._objectsCtor = new Hashtable();\n      this._layers = new Hashtable();\n      this._orderedLayers = [];\n    }\n\n    /**\n     * Return the time elapsed since the last frame,\n     * in milliseconds, for objects on the layer.\n     */\n    abstract getElapsedTime(): float;\n\n    /**\n     * Get the renderer associated to the container.\n     */\n    abstract getRenderer(): gdjs.RuntimeInstanceContainerRenderer;\n\n    /**\n     * Get the renderer for visual debugging associated to the container.\n     */\n    abstract getDebuggerRenderer(): gdjs.DebuggerRenderer;\n\n    /**\n     * Get the {@link gdjs.RuntimeGame} associated to this.\n     */\n    abstract getGame(): gdjs.RuntimeGame;\n\n    /**\n     * Get the {@link gdjs.RuntimeScene} associated to this.\n     */\n    abstract getScene(): gdjs.RuntimeScene;\n\n    /**\n     * Convert a point from the canvas coordinates (for example,\n     * the mouse position) to the container coordinates.\n     *\n     * @param x The x position, in container coordinates.\n     * @param y The y position, in container coordinates.\n     * @param result The point instance that is used to return the result.\n     */\n    abstract convertCoords(x: float, y: float, result?: FloatPoint): FloatPoint;\n\n    /**\n     * Convert a point from the container coordinates (for example,\n     * an object position) to the canvas coordinates.\n     *\n     * @param sceneX The x position, in container coordinates.\n     * @param sceneY The y position, in container coordinates.\n     * @param result The point instance that is used to return the result.\n     */\n    abstract convertInverseCoords(\n      sceneX: float,\n      sceneY: float,\n      result: FloatPoint\n    ): FloatPoint;\n\n    /**\n     * @return the width of:\n     * - the game resolution for a {@link gdjs.RuntimeScene}\n     * - the default dimensions (the AABB of all its children) for a\n     * {@link gdjs.CustomRuntimeObject}.\n     */\n    abstract getViewportWidth(): float;\n\n    /**\n     * @return the height of:\n     * - the game resolution for a {@link gdjs.RuntimeScene}\n     * - the default dimensions (the AABB of all its children) for a\n     * {@link gdjs.CustomRuntimeObject}.\n     */\n    abstract getViewportHeight(): float;\n\n    /**\n     * @return the center X of:\n     * - the game resolution for a {@link gdjs.RuntimeScene}\n     * - the default dimensions (the AABB of all its children) for a\n     * {@link gdjs.CustomRuntimeObject}.\n     */\n    abstract getViewportOriginX(): float;\n\n    /**\n     * @return the center Y of:\n     * - the game resolution for a {@link gdjs.RuntimeScene}\n     * - the default dimensions (the AABB of all its children) for a\n     * {@link gdjs.CustomRuntimeObject}.\n     */\n    abstract getViewportOriginY(): float;\n\n    /**\n     * Triggered when the AABB of a child of the container could have changed.\n     */\n    abstract onChildrenLocationChanged(): void;\n\n    /**\n     * Activate or deactivate the debug visualization for collisions and points.\n     */\n    enableDebugDraw(\n      enableDebugDraw: boolean,\n      showHiddenInstances: boolean,\n      showPointsNames: boolean,\n      showCustomPoints: boolean\n    ): void {\n      if (this._debugDrawEnabled && !enableDebugDraw) {\n        this.getDebuggerRenderer().clearDebugDraw();\n      }\n\n      this._debugDrawEnabled = enableDebugDraw;\n      this._debugDrawShowHiddenInstances = showHiddenInstances;\n      this._debugDrawShowPointsNames = showPointsNames;\n      this._debugDrawShowCustomPoints = showCustomPoints;\n    }\n\n    /**\n     * Check if an object is registered, meaning that instances of it can be\n     * created and lives in the container.\n     * @see gdjs.RuntimeInstanceContainer#registerObject\n     */\n    isObjectRegistered(objectName: string): boolean {\n      return (\n        this._objects.containsKey(objectName) &&\n        this._instances.containsKey(objectName) &&\n        this._objectsCtor.containsKey(objectName)\n      );\n    }\n\n    /**\n     * Register a {@link gdjs.RuntimeObject} so that instances of it can be\n     * used in the container.\n     * @param objectData The data for the object to register.\n     */\n    registerObject(objectData: ObjectData) {\n      this._objects.put(objectData.name, objectData);\n      this._instances.put(objectData.name, []);\n\n      // Cache the constructor\n      const Ctor = gdjs.getObjectConstructor(objectData.type);\n      this._objectsCtor.put(objectData.name, Ctor);\n\n      // Also prepare a cache for recycled instances, if the object supports it.\n      if (Ctor.supportsReinitialization) {\n        this._instancesCache.put(objectData.name, []);\n      }\n    }\n\n    /**\n     * Update the data of a {@link gdjs.RuntimeObject} so that instances use\n     * this when constructed.\n     * @param objectData The data for the object to register.\n     */\n    updateObject(objectData: ObjectData): void {\n      if (!this.isObjectRegistered(objectData.name)) {\n        logger.warn(\n          'Tried to call updateObject for an object that was not registered (' +\n            objectData.name +\n            '). Call registerObject first.'\n        );\n      }\n      this._objects.put(objectData.name, objectData);\n    }\n\n    // Don't erase instances, nor instances cache, or objectsCtor cache.\n    /**\n     * Unregister a {@link gdjs.RuntimeObject}. Instances will be destroyed.\n     * @param objectName The name of the object to unregister.\n     */\n    unregisterObject(objectName: string) {\n      const instances = this._instances.get(objectName);\n      if (instances) {\n        // This is sub-optimal: markObjectForDeletion will search the instance to\n        // remove in instances, so cost is O(n^2), n being the number of instances.\n        // As we're unregistering an object which only happen during a hot-reloading,\n        // this is fine.\n        const instancesToRemove = instances.slice();\n        for (let i = 0; i < instancesToRemove.length; i++) {\n          this.markObjectForDeletion(instancesToRemove[i]);\n        }\n        this._cacheOrClearRemovedInstances();\n      }\n      this._objects.remove(objectName);\n      this._instances.remove(objectName);\n      this._instancesCache.remove(objectName);\n      this._objectsCtor.remove(objectName);\n    }\n\n    /**\n     * Create objects from initial instances data (for example, the initial instances\n     * of the scene or the instances of an external layout).\n     *\n     * @param data The instances data\n     * @param xPos The offset on X axis\n     * @param yPos The offset on Y axis\n     * @param trackByPersistentUuid If true, objects are tracked by setting their `persistentUuid`\n     * to the same as the associated instance. Useful for hot-reloading when instances are changed.\n     */\n    createObjectsFrom(\n      data: InstanceData[],\n      xPos: float,\n      yPos: float,\n      trackByPersistentUuid: boolean\n    ) {\n      for (let i = 0, len = data.length; i < len; ++i) {\n        const instanceData = data[i];\n        const objectName = instanceData.name;\n        const newObject = this.createObject(objectName);\n        if (newObject !== null) {\n          if (trackByPersistentUuid) {\n            // Give the object the same persistentUuid as the instance, so that\n            // it can be hot-reloaded.\n            newObject.persistentUuid = instanceData.persistentUuid || null;\n          }\n          newObject.setPosition(instanceData.x + xPos, instanceData.y + yPos);\n          newObject.setAngle(instanceData.angle);\n          if (\n            gdjs.RuntimeObject3D &&\n            newObject instanceof gdjs.RuntimeObject3D\n          ) {\n            if (instanceData.z !== undefined) newObject.setZ(instanceData.z);\n            if (instanceData.rotationX !== undefined)\n              newObject.setRotationX(instanceData.rotationX);\n            if (instanceData.rotationY !== undefined)\n              newObject.setRotationY(instanceData.rotationY);\n          }\n\n          newObject.setZOrder(instanceData.zOrder);\n          newObject.setLayer(instanceData.layer);\n          newObject\n            .getVariables()\n            .initFrom(instanceData.initialVariables, true);\n          newObject.extraInitializationFromInitialInstance(instanceData);\n        }\n      }\n    }\n\n    /**\n     * Get the data representing the initial shared data of the scene for the specified behavior.\n     * @param name The name of the behavior\n     * @returns The shared data for the behavior, if any.\n     */\n    getInitialSharedDataForBehavior(name: string): BehaviorSharedData | null {\n      return this._initialBehaviorSharedData.get(name);\n    }\n\n    /**\n     * Set the data representing the initial shared data of the scene for the specified behavior.\n     * @param name The name of the behavior\n     * @param sharedData The shared data for the behavior, or null to remove it.\n     */\n    setInitialSharedDataForBehavior(\n      name: string,\n      sharedData: BehaviorSharedData | null\n    ): void {\n      this._initialBehaviorSharedData.put(name, sharedData);\n    }\n\n    /**\n     * Set the default Z order for each layer, which is the highest Z order found on each layer.\n     * Useful as it ensures that instances created from events are, by default, shown in front\n     * of other instances.\n     */\n    _setLayerDefaultZOrders() {\n      if (\n        this.getGame().getGameData().properties.useDeprecatedZeroAsDefaultZOrder\n      ) {\n        // Deprecated option to still support games that were made considered 0 as the\n        // default Z order for all layers.\n        return;\n      }\n      const layerHighestZOrders: Record<string, number> = {};\n      const allInstances = this.getAdhocListOfAllInstances();\n      for (let i = 0, len = allInstances.length; i < len; ++i) {\n        const object = allInstances[i];\n        let layerName = object.getLayer();\n        const zOrder = object.getZOrder();\n        if (\n          layerHighestZOrders[layerName] === undefined ||\n          layerHighestZOrders[layerName] < zOrder\n        ) {\n          layerHighestZOrders[layerName] = zOrder;\n        }\n      }\n      for (let layerName in layerHighestZOrders) {\n        this.getLayer(layerName).setDefaultZOrder(\n          layerHighestZOrders[layerName] + 1\n        );\n      }\n    }\n\n    _updateLayersCameraCoordinates(scale: float) {\n      this._layersCameraCoordinates = this._layersCameraCoordinates || {};\n      for (const name in this._layers.items) {\n        if (this._layers.items.hasOwnProperty(name)) {\n          const theLayer = this._layers.items[name];\n          this._layersCameraCoordinates[name] = this._layersCameraCoordinates[\n            name\n          ] || [0, 0, 0, 0];\n          this._layersCameraCoordinates[name][0] =\n            theLayer.getCameraX() - (theLayer.getCameraWidth() / 2) * scale;\n          this._layersCameraCoordinates[name][1] =\n            theLayer.getCameraY() - (theLayer.getCameraHeight() / 2) * scale;\n          this._layersCameraCoordinates[name][2] =\n            theLayer.getCameraX() + (theLayer.getCameraWidth() / 2) * scale;\n          this._layersCameraCoordinates[name][3] =\n            theLayer.getCameraY() + (theLayer.getCameraHeight() / 2) * scale;\n        }\n      }\n    }\n\n    /**\n     * Called to update effects of layers before rendering.\n     */\n    _updateLayersPreRender() {\n      for (const layer of this._orderedLayers) {\n        layer.updatePreRender(this);\n      }\n    }\n\n    /**\n     * Called to update visibility of the renderers of objects\n     * rendered on the scene (\"culling\"), update effects (of visible objects)\n     * and give a last chance for objects to update before rendering.\n     *\n     * Visibility is set to false if object is hidden, or if\n     * object is too far from the camera of its layer (\"culling\").\n     */\n    _updateObjectsPreRender() {\n      const allInstancesList = this.getAdhocListOfAllInstances();\n      // TODO (3D) culling - add support for 3D object culling?\n      for (let i = 0, len = allInstancesList.length; i < len; ++i) {\n        const object = allInstancesList[i];\n        const rendererObject = object.getRendererObject();\n        if (rendererObject) {\n          rendererObject.visible = !object.isHidden();\n\n          // Update effects, only for visible objects.\n          if (rendererObject.visible) {\n            this.getGame()\n              .getEffectsManager()\n              .updatePreRender(object.getRendererEffects(), object);\n          }\n        }\n\n        // Perform pre-render update.\n        object.updatePreRender(this);\n      }\n      return;\n    }\n\n    /**\n     * Empty the list of the removed objects:\n     *\n     * When an object is removed from the container, it is still kept in\n     * {@link gdjs.RuntimeInstanceContainer#_instancesRemoved}.\n     *\n     * This method should be called regularly (after events or behaviors steps) so as to clear this list\n     * and allows the removed objects to be cached (or destroyed if the cache is full).\n     *\n     * The removed objects could not be sent directly to the cache, as events may still be using them after\n     * removing them from the scene for example.\n     */\n    _cacheOrClearRemovedInstances() {\n      for (let k = 0, lenk = this._instancesRemoved.length; k < lenk; ++k) {\n        // Cache the instance to recycle it into a new instance later.\n        // If the object does not support recycling, the cache won't be defined.\n        const cache = this._instancesCache.get(\n          this._instancesRemoved[k].getName()\n        );\n        if (cache) {\n          if (cache.length < 128) {\n            cache.push(this._instancesRemoved[k]);\n          }\n        }\n      }\n      this._instancesRemoved.length = 0;\n    }\n\n    /**\n     * Tool function filling _allInstancesList member with all the living object instances.\n     */\n    private _constructListOfAllInstances() {\n      let currentListSize = 0;\n      for (const name in this._instances.items) {\n        if (this._instances.items.hasOwnProperty(name)) {\n          const list = this._instances.items[name];\n          const oldSize = currentListSize;\n          currentListSize += list.length;\n          for (let j = 0, lenj = list.length; j < lenj; ++j) {\n            if (oldSize + j < this._allInstancesList.length) {\n              this._allInstancesList[oldSize + j] = list[j];\n            } else {\n              this._allInstancesList.push(list[j]);\n            }\n          }\n        }\n      }\n      this._allInstancesList.length = currentListSize;\n      this._allInstancesListIsUpToDate = true;\n    }\n\n    /**\n     * @param objectName The name of the object\n     * @returns the instances of a given object in the container.\n     */\n    getInstancesOf(objectName: string): gdjs.RuntimeObject[] {\n      return this._instances.items[objectName];\n    }\n\n    /**\n     * Get a list of all {@link gdjs.RuntimeObject} living in the container.\n     * You should not, normally, need this method at all. It's only to be used\n     * in exceptional use cases where you need to loop through all objects,\n     * and it won't be performant.\n     *\n     * @returns The list of all runtime objects in the container\n     */\n    getAdhocListOfAllInstances(): gdjs.RuntimeObject[] {\n      if (!this._allInstancesListIsUpToDate) {\n        this._constructListOfAllInstances();\n      }\n      return this._allInstancesList;\n    }\n\n    /**\n     * Update the objects before launching the events.\n     */\n    _updateObjectsPreEvents() {\n      // It is *mandatory* to create and iterate on a external list of all objects, as the behaviors\n      // may delete the objects.\n      const allInstancesList = this.getAdhocListOfAllInstances();\n      for (let i = 0, len = allInstancesList.length; i < len; ++i) {\n        const obj = allInstancesList[i];\n        const elapsedTime = obj.getElapsedTime();\n        if (!obj.hasNoForces()) {\n          const averageForce = obj.getAverageForce();\n          const elapsedTimeInSeconds = elapsedTime / 1000;\n          obj.setX(obj.getX() + averageForce.getX() * elapsedTimeInSeconds);\n          obj.setY(obj.getY() + averageForce.getY() * elapsedTimeInSeconds);\n          obj.update(this);\n          obj.updateForces(elapsedTimeInSeconds);\n        } else {\n          obj.update(this);\n        }\n        obj.updateTimers(elapsedTime);\n        allInstancesList[i].stepBehaviorsPreEvents(this);\n      }\n\n      // Some behaviors may have request objects to be deleted.\n      this._cacheOrClearRemovedInstances();\n    }\n\n    /**\n     * Update the objects (update positions, time management...)\n     */\n    _updateObjectsPostEvents() {\n      this._cacheOrClearRemovedInstances();\n\n      // It is *mandatory* to create and iterate on a external list of all objects, as the behaviors\n      // may delete the objects.\n      const allInstancesList = this.getAdhocListOfAllInstances();\n      for (let i = 0, len = allInstancesList.length; i < len; ++i) {\n        allInstancesList[i].stepBehaviorsPostEvents(this);\n      }\n\n      // Some behaviors may have request objects to be deleted.\n      this._cacheOrClearRemovedInstances();\n    }\n\n    /**\n     * Add an object to the instances living in the container.\n     * @param obj The object to be added.\n     */\n    addObject(obj: gdjs.RuntimeObject) {\n      if (!this._instances.containsKey(obj.name)) {\n        this._instances.put(obj.name, []);\n      }\n      this._instances.get(obj.name).push(obj);\n      this._allInstancesListIsUpToDate = false;\n    }\n\n    /**\n     * Get all the instances of the object called name.\n     * @param name Name of the object for which the instances must be returned.\n     * @return The list of objects with the given name\n     */\n    getObjects(name: string): gdjs.RuntimeObject[] | undefined {\n      if (!this._instances.containsKey(name)) {\n        logger.info(\n          'RuntimeScene.getObjects: No instances called \"' +\n            name +\n            '\"! Adding it.'\n        );\n        this._instances.put(name, []);\n      }\n      return this._instances.get(name);\n    }\n\n    /**\n     * Create a new object from its name. The object is also added to the instances\n     * living in the container (No need to call {@link gdjs.RuntimeScene.addObject})\n     * @param objectName The name of the object to be created\n     * @return The created object\n     */\n    createObject(objectName: string): gdjs.RuntimeObject | null {\n      if (\n        !this._objectsCtor.containsKey(objectName) ||\n        !this._objects.containsKey(objectName)\n      ) {\n        // There is no such object in this container.\n        return null;\n      }\n\n      // Create a new object using the object constructor (cached during loading)\n      // and the stored object's data:\n      const cache = this._instancesCache.get(objectName);\n      const ctor = this._objectsCtor.get(objectName);\n      let obj;\n      if (!cache || cache.length === 0) {\n        obj = new ctor(this, this._objects.get(objectName));\n      } else {\n        // Reuse an objet destroyed before. If there is an object in the cache,\n        // then it means it does support reinitialization.\n        obj = cache.pop();\n        obj.reinitialize(this._objects.get(objectName));\n      }\n      this.addObject(obj);\n      return obj;\n    }\n\n    /**\n     * Must be called whenever an object must be removed from the container.\n     * @param obj The object to be removed.\n     */\n    markObjectForDeletion(obj: gdjs.RuntimeObject) {\n      // Add to the objects removed list.\n      // The objects will be sent to the instances cache or really deleted from memory later.\n      if (this._instancesRemoved.indexOf(obj) === -1) {\n        this._instancesRemoved.push(obj);\n      }\n\n      // Delete from the living instances.\n      if (this._instances.containsKey(obj.getName())) {\n        const objId = obj.id;\n        const allInstances = this._instances.get(obj.getName());\n        for (let i = 0, len = allInstances.length; i < len; ++i) {\n          if (allInstances[i].id == objId) {\n            allInstances.splice(i, 1);\n            this._allInstancesListIsUpToDate = false;\n            break;\n          }\n        }\n      }\n\n      // Notify the object it was removed from the container\n      obj.onDestroyFromScene(this);\n\n      // Notify the global callbacks\n      for (let j = 0; j < gdjs.callbacksObjectDeletedFromScene.length; ++j) {\n        gdjs.callbacksObjectDeletedFromScene[j](this, obj);\n      }\n      return;\n    }\n\n    /**\n     * Get the layer with the given name\n     * @param name The name of the layer\n     * @returns The layer, or the base layer if not found\n     */\n    getLayer(name: string): gdjs.RuntimeLayer {\n      if (this._layers.containsKey(name)) {\n        return this._layers.get(name);\n      }\n      return this._layers.get('');\n    }\n\n    /**\n     * Check if a layer exists\n     * @param name The name of the layer\n     */\n    hasLayer(name: string): boolean {\n      return this._layers.containsKey(name);\n    }\n\n    /**\n     * Add a layer.\n     * @param layerData The data to construct the layer\n     */\n    abstract addLayer(layerData: LayerData);\n\n    /**\n     * Remove a layer. All {@link gdjs.RuntimeObject} on this layer will\n     * be moved back to the base layer.\n     * @param layerName The name of the layer to remove\n     */\n    removeLayer(layerName: string) {\n      const existingLayer = this._layers.get(layerName);\n      if (!existingLayer) return;\n\n      const allInstances = this.getAdhocListOfAllInstances();\n      for (let i = 0; i < allInstances.length; ++i) {\n        const runtimeObject = allInstances[i];\n        if (runtimeObject.getLayer() === layerName) {\n          runtimeObject.setLayer('');\n        }\n      }\n      this._layers.remove(layerName);\n      const layerIndex = this._orderedLayers.indexOf(existingLayer);\n      this._orderedLayers.splice(layerIndex, 1);\n    }\n\n    /**\n     * Change the position of a layer.\n     *\n     * @param layerName The name of the layer to reorder\n     * @param index The new position in the list of layers\n     */\n    setLayerIndex(layerName: string, newIndex: integer): void {\n      const layer: gdjs.RuntimeLayer = this._layers.get(layerName);\n      if (!layer) {\n        return;\n      }\n      const layerIndex = this._orderedLayers.indexOf(layer);\n      if (layerIndex === newIndex) return;\n\n      this._orderedLayers.splice(layerIndex, 1);\n      this._orderedLayers.splice(newIndex, 0, layer);\n\n      this.getRenderer().setLayerIndex(layer, newIndex);\n    }\n\n    /**\n     * Fill the array passed as argument with the names of all layers\n     * @param result The array where to put the layer names\n     */\n    getAllLayerNames(result: string[]) {\n      this._layers.keys(result);\n    }\n\n    /**\n     * Return the number of instances of the specified object living in the container.\n     * @param objectName The object name for which instances must be counted.\n     */\n    getInstancesCountOnScene(objectName: string): integer {\n      const instances = this._instances.get(objectName);\n      if (instances) {\n        return instances.length;\n      }\n\n      return 0;\n    }\n\n    /**\n     * Update the objects positions according to their forces\n     */\n    updateObjectsForces(): void {\n      for (const name in this._instances.items) {\n        if (this._instances.items.hasOwnProperty(name)) {\n          const list = this._instances.items[name];\n          for (let j = 0, listLen = list.length; j < listLen; ++j) {\n            const obj = list[j];\n            if (!obj.hasNoForces()) {\n              const averageForce = obj.getAverageForce();\n              const elapsedTimeInSeconds = obj.getElapsedTime() / 1000;\n              obj.setX(obj.getX() + averageForce.getX() * elapsedTimeInSeconds);\n              obj.setY(obj.getY() + averageForce.getY() * elapsedTimeInSeconds);\n              obj.updateForces(elapsedTimeInSeconds);\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Clear any data structures to make sure memory is freed as soon as\n     * possible.\n     */\n    _destroy() {\n      // It should not be necessary to reset these variables, but this help\n      // ensuring that all memory related to the container is released immediately.\n      this._layers = new Hashtable();\n      this._orderedLayers = [];\n      this._objects = new Hashtable();\n      this._instances = new Hashtable();\n      this._instancesCache = new Hashtable();\n      this._objectsCtor = new Hashtable();\n      this._allInstancesList = [];\n      this._instancesRemoved = [];\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
