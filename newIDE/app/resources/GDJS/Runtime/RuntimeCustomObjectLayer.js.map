{
  "version": 3,
  "sources": ["../../../../../GDJS/Runtime/RuntimeCustomObjectLayer.ts"],
  "sourcesContent": ["/*\n * GDevelop JS Platform\n * Copyright 2013-2016 Florian Rival (Florian.Rival@gmail.com). All rights reserved.\n * This project is released under the MIT License.\n */\nnamespace gdjs {\n  /**\n   * Represents a layer of a custom object. It doesn't allow to move any camera\n   * because it doesn't make sense inside an object.\n   */\n  export class RuntimeCustomObjectLayer extends gdjs.RuntimeLayer {\n    /**\n     * @param layerData The data used to initialize the layer\n     * @param instanceContainer The container in which the layer is used\n     */\n    constructor(\n      layerData: LayerData,\n      instanceContainer: gdjs.RuntimeInstanceContainer\n    ) {\n      super(layerData, instanceContainer);\n\n      // Let the renderer do its final set up:\n      this._renderer.onCreated();\n    }\n\n    onGameResolutionResized(\n      oldGameResolutionOriginX: float,\n      oldGameResolutionOriginY: float\n    ): void {}\n\n    getCameraX(cameraId?: integer): float {\n      return 0;\n    }\n\n    getCameraY(cameraId?: integer): float {\n      return 0;\n    }\n\n    setCameraX(x: float, cameraId?: integer): void {}\n\n    setCameraY(y: float, cameraId?: integer): void {}\n\n    getCameraWidth(cameraId?: integer): float {\n      return 0;\n    }\n\n    getCameraHeight(cameraId?: integer): float {\n      return 0;\n    }\n\n    setCameraZoom(newZoom: float, cameraId?: integer): void {}\n\n    getCameraZoom(cameraId?: integer): float {\n      return 1;\n    }\n\n    setCameraZ(z: float, fov: float, cameraId?: integer): void {}\n\n    getCameraZ(fov: float = 45, cameraId?: integer): float {\n      return 0;\n    }\n\n    getCameraRotation(cameraId?: integer): float {\n      return 0;\n    }\n\n    setCameraRotation(rotation: float, cameraId?: integer): void {}\n\n    convertCoords(\n      x: float,\n      y: float,\n      cameraId: integer,\n      result: FloatPoint\n    ): FloatPoint {\n      // TODO EBO use an AffineTransformation to avoid chained calls.\n      // The result parameter used to be optional.\n      return this._runtimeScene.convertCoords(x, y, result || [0, 0]);\n    }\n\n    convertInverseCoords(\n      x: float,\n      y: float,\n      cameraId: integer,\n      result: FloatPoint\n    ): FloatPoint {\n      // TODO EBO use an AffineTransformation to avoid chained calls.\n      // The result parameter used to be optional.\n      return this._runtimeScene.convertInverseCoords(x, y, result || [0, 0]);\n    }\n\n    applyLayerInverseTransformation(\n      x: float,\n      y: float,\n      cameraId: integer,\n      result: FloatPoint\n    ): FloatPoint {\n      result[0] = x;\n      result[1] = y;\n      return result;\n    }\n\n    applyLayerTransformation(\n      x: float,\n      y: float,\n      cameraId: integer,\n      result: FloatPoint\n    ): FloatPoint {\n      result[0] = x;\n      result[1] = y;\n      return result;\n    }\n  }\n}\n"],
  "mappings": "AAKA,GAAU,MAAV,UAAU,EAAV,CAKS,eAAuC,GAAK,YAAa,CAK9D,YACE,EACA,EACA,CACA,MAAM,EAAW,GAGjB,KAAK,UAAU,YAGjB,wBACE,EACA,EACM,EAER,WAAW,EAA2B,CACpC,MAAO,GAGT,WAAW,EAA2B,CACpC,MAAO,GAGT,WAAW,EAAU,EAA0B,EAE/C,WAAW,EAAU,EAA0B,EAE/C,eAAe,EAA2B,CACxC,MAAO,GAGT,gBAAgB,EAA2B,CACzC,MAAO,GAGT,cAAc,EAAgB,EAA0B,EAExD,cAAc,EAA2B,CACvC,MAAO,GAGT,WAAW,EAAU,EAAY,EAA0B,EAE3D,WAAW,EAAa,GAAI,EAA2B,CACrD,MAAO,GAGT,kBAAkB,EAA2B,CAC3C,MAAO,GAGT,kBAAkB,EAAiB,EAA0B,EAE7D,cACE,EACA,EACA,EACA,EACY,CAGZ,MAAO,MAAK,cAAc,cAAc,EAAG,EAAG,GAAU,CAAC,EAAG,IAG9D,qBACE,EACA,EACA,EACA,EACY,CAGZ,MAAO,MAAK,cAAc,qBAAqB,EAAG,EAAG,GAAU,CAAC,EAAG,IAGrE,gCACE,EACA,EACA,EACA,EACY,CACZ,SAAO,GAAK,EACZ,EAAO,GAAK,EACL,EAGT,yBACE,EACA,EACA,EACA,EACY,CACZ,SAAO,GAAK,EACZ,EAAO,GAAK,EACL,GAnGJ,EAAM,6BALL",
  "names": []
}
