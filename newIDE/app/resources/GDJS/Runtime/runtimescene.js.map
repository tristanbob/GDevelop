{
  "version": 3,
  "sources": ["../../../../../GDJS/Runtime/runtimescene.ts"],
  "sourcesContent": ["/*\n * GDevelop JS Platform\n * Copyright 2013-2016 Florian Rival (Florian.Rival@gmail.com). All rights reserved.\n * This project is released under the MIT License.\n */\nnamespace gdjs {\n  const logger = new gdjs.Logger('RuntimeScene');\n  const setupWarningLogger = new gdjs.Logger('RuntimeScene (setup warnings)');\n\n  /**\n   * A scene being played, containing instances of objects rendered on screen.\n   */\n  export class RuntimeScene extends gdjs.RuntimeInstanceContainer {\n    _eventsFunction: null | ((runtimeScene: RuntimeScene) => void) = null;\n\n    _renderer: RuntimeSceneRenderer;\n    _debuggerRenderer: gdjs.DebuggerRenderer;\n    _variables: gdjs.VariablesContainer;\n    _runtimeGame: gdjs.RuntimeGame;\n    _lastId: integer = 0;\n    _name: string = '';\n    _timeManager: TimeManager;\n    _gameStopRequested: boolean = false;\n    _requestedScene: string = '';\n    private _asyncTasksManager = new gdjs.AsyncTasksManager();\n\n    /** True if loadFromScene was called and the scene is being played. */\n    _isLoaded: boolean = false;\n    /** True in the first frame after resuming the paused scene */\n    _isJustResumed: boolean = false;\n\n    _requestedChange: SceneChangeRequest;\n    /** Black background by default. */\n    _backgroundColor: integer = 0;\n    _onceTriggers: OnceTriggers;\n    _profiler: gdjs.Profiler | null = null;\n\n    // Set to `new gdjs.Profiler()` to have profiling done on the scene.\n    _onProfilerStopped: null | ((oldProfiler: gdjs.Profiler) => void) = null;\n\n    _cachedGameResolutionWidth: integer;\n    _cachedGameResolutionHeight: integer;\n\n    /**\n     * @param runtimeGame The game associated to this scene.\n     */\n    constructor(runtimeGame: gdjs.RuntimeGame) {\n      super();\n      this._runtimeGame = runtimeGame;\n      this._variables = new gdjs.VariablesContainer();\n      this._timeManager = new gdjs.TimeManager();\n      this._onceTriggers = new gdjs.OnceTriggers();\n      this._requestedChange = SceneChangeRequest.CONTINUE;\n      this._cachedGameResolutionWidth = runtimeGame\n        ? runtimeGame.getGameResolutionWidth()\n        : 0;\n      this._cachedGameResolutionHeight = runtimeGame\n        ? runtimeGame.getGameResolutionHeight()\n        : 0;\n\n      this._renderer = new gdjs.RuntimeSceneRenderer(\n        this,\n        // @ts-ignore This is needed because of test. They should mock RuntimeGame instead.\n        runtimeGame ? runtimeGame.getRenderer() : null\n      );\n      this._debuggerRenderer = new gdjs.DebuggerRenderer(this);\n\n      // What to do after the frame is rendered.\n\n      // The callback function to call when the profiler is stopped.\n      this.onGameResolutionResized();\n    }\n\n    addLayer(layerData: LayerData) {\n      const layer = new gdjs.Layer(layerData, this);\n      this._layers.put(layerData.name, layer);\n      this._orderedLayers.push(layer);\n    }\n\n    /**\n     * Should be called when the canvas where the scene is rendered has been resized.\n     * See gdjs.RuntimeGame.startGameLoop in particular.\n     */\n    onGameResolutionResized() {\n      const oldGameResolutionOriginX = this.getViewportOriginX();\n      const oldGameResolutionOriginY = this.getViewportOriginY();\n      this._cachedGameResolutionWidth = this._runtimeGame\n        ? this._runtimeGame.getGameResolutionWidth()\n        : 0;\n      this._cachedGameResolutionHeight = this._runtimeGame\n        ? this._runtimeGame.getGameResolutionHeight()\n        : 0;\n      for (const name in this._layers.items) {\n        if (this._layers.items.hasOwnProperty(name)) {\n          const theLayer: gdjs.RuntimeLayer = this._layers.items[name];\n          theLayer.onGameResolutionResized(\n            oldGameResolutionOriginX,\n            oldGameResolutionOriginY\n          );\n        }\n      }\n      this._renderer.onGameResolutionResized();\n    }\n\n    /**\n     * Load the runtime scene from the given scene.\n     * @param sceneData An object containing the scene data.\n     * @see gdjs.RuntimeGame#getSceneData\n     */\n    loadFromScene(sceneData: LayoutData | null) {\n      if (!sceneData) {\n        logger.error('loadFromScene was called without a scene');\n        return;\n      }\n\n      if (this._isLoaded) {\n        this.unloadScene();\n      }\n\n      //Setup main properties\n      if (this._runtimeGame) {\n        this._runtimeGame.getRenderer().setWindowTitle(sceneData.title);\n      }\n      this._name = sceneData.name;\n      this.setBackgroundColor(sceneData.r, sceneData.v, sceneData.b);\n\n      //Load layers\n      for (let i = 0, len = sceneData.layers.length; i < len; ++i) {\n        this.addLayer(sceneData.layers[i]);\n      }\n\n      //Load variables\n      this._variables = new gdjs.VariablesContainer(sceneData.variables);\n\n      //Cache the initial shared data of the behaviors\n      for (\n        let i = 0, len = sceneData.behaviorsSharedData.length;\n        i < len;\n        ++i\n      ) {\n        const behaviorSharedData = sceneData.behaviorsSharedData[i];\n        this.setInitialSharedDataForBehavior(\n          behaviorSharedData.name,\n          behaviorSharedData\n        );\n      }\n\n      //Registering objects: Global objects first...\n      const initialGlobalObjectsData = this.getGame().getInitialObjectsData();\n      for (let i = 0, len = initialGlobalObjectsData.length; i < len; ++i) {\n        this.registerObject(initialGlobalObjectsData[i]);\n      }\n\n      //...then the scene objects\n      for (let i = 0, len = sceneData.objects.length; i < len; ++i) {\n        this.registerObject(sceneData.objects[i]);\n      }\n\n      //Create initial instances of objects\n      this.createObjectsFrom(\n        sceneData.instances,\n        0,\n        0,\n        /*trackByPersistentUuid=*/\n        true\n      );\n\n      // Set up the default z order (for objects created from events)\n      this._setLayerDefaultZOrders();\n\n      //Set up the function to be executed at each tick\n      this.setEventsGeneratedCodeFunction(sceneData);\n      this._onceTriggers = new gdjs.OnceTriggers();\n\n      // Notify the global callbacks\n      if (this._runtimeGame && !this._runtimeGame.wasFirstSceneLoaded()) {\n        for (let i = 0; i < gdjs.callbacksFirstRuntimeSceneLoaded.length; ++i) {\n          gdjs.callbacksFirstRuntimeSceneLoaded[i](this);\n        }\n      }\n      for (let i = 0; i < gdjs.callbacksRuntimeSceneLoaded.length; ++i) {\n        gdjs.callbacksRuntimeSceneLoaded[i](this);\n      }\n      if (sceneData.stopSoundsOnStartup && this._runtimeGame) {\n        this._runtimeGame.getSoundManager().clearAll();\n      }\n      this._isLoaded = true;\n      this._timeManager.reset();\n    }\n\n    getInitialSharedDataForBehavior(name: string): BehaviorSharedData | null {\n      // TODO Move this error in RuntimeInstanceContainer after deciding\n      // what to do with shared data in custom object.\n      const behaviorSharedData = super.getInitialSharedDataForBehavior(name);\n      if (!behaviorSharedData) {\n        logger.error(\"Can't find shared data for behavior with name: \" + name);\n      }\n      return behaviorSharedData;\n    }\n\n    /**\n     * Called when a scene is \"paused\", i.e it will be not be rendered again\n     * for some time, until it's resumed or unloaded.\n     */\n    onPause() {\n      // Notify the objects that the scene is being paused. Objects should not\n      // do anything special, but some object renderers might want to know about this.\n      const allInstancesList = this.getAdhocListOfAllInstances();\n      for (let i = 0, len = allInstancesList.length; i < len; ++i) {\n        const object = allInstancesList[i];\n        object.onScenePaused(this);\n      }\n\n      for (let i = 0; i < gdjs.callbacksRuntimeScenePaused.length; ++i) {\n        gdjs.callbacksRuntimeScenePaused[i](this);\n      }\n    }\n\n    /**\n     * Called when a scene is \"resumed\", i.e it will be rendered again\n     * on screen after having being paused.\n     */\n    onResume() {\n      this._isJustResumed = true;\n\n      // Notify the objects that the scene is being resumed. Objects should not\n      // do anything special, but some object renderers might want to know about this.\n      const allInstancesList = this.getAdhocListOfAllInstances();\n      for (let i = 0, len = allInstancesList.length; i < len; ++i) {\n        const object = allInstancesList[i];\n        object.onSceneResumed(this);\n      }\n\n      for (let i = 0; i < gdjs.callbacksRuntimeSceneResumed.length; ++i) {\n        gdjs.callbacksRuntimeSceneResumed[i](this);\n      }\n    }\n\n    /**\n     * Called before a scene is removed from the stack of scenes\n     * rendered on the screen.\n     */\n    unloadScene() {\n      if (!this._isLoaded) {\n        return;\n      }\n      if (this._profiler) {\n        this.stopProfiler();\n      }\n\n      // Notify the global callbacks (which should not release resources yet,\n      // as other callbacks might still refer to the objects/scene).\n      for (let i = 0; i < gdjs.callbacksRuntimeSceneUnloading.length; ++i) {\n        gdjs.callbacksRuntimeSceneUnloading[i](this);\n      }\n\n      // Notify the objects they are being destroyed\n      const allInstancesList = this.getAdhocListOfAllInstances();\n      for (let i = 0, len = allInstancesList.length; i < len; ++i) {\n        const object = allInstancesList[i];\n        object.onDestroyFromScene(this);\n      }\n\n      // Notify the renderer\n      if (this._renderer) {\n        this._renderer.onSceneUnloaded();\n      }\n\n      // Notify the global callbacks (after notifying objects and renderer, because\n      // callbacks from extensions might want to free resources - which can't be done\n      // safely before destroying objects and the renderer).\n      for (let i = 0; i < gdjs.callbacksRuntimeSceneUnloaded.length; ++i) {\n        gdjs.callbacksRuntimeSceneUnloaded[i](this);\n      }\n\n      this._destroy();\n\n      this._isLoaded = false;\n      this.onGameResolutionResized();\n    }\n\n    _destroy() {\n      // It should not be necessary to reset these variables, but this help\n      // ensuring that all memory related to the RuntimeScene is released immediately.\n      super._destroy();\n      this._variables = new gdjs.VariablesContainer();\n      this._initialBehaviorSharedData = new Hashtable();\n      this._eventsFunction = null;\n      this._lastId = 0;\n      // @ts-ignore We are deleting the object\n      this._onceTriggers = null;\n    }\n\n    /**\n     * Set the function called each time the scene is stepped to be the events generated code,\n     * which is by convention assumed to be a function in `gdjs` with a name based on the scene\n     * mangled name.\n     *\n     * @param sceneData The scene data, used to find where the code was generated.\n     */\n    setEventsGeneratedCodeFunction(sceneData: LayoutData): void {\n      const module = gdjs[sceneData.mangledName + 'Code'];\n      if (module && module.func) {\n        this._eventsFunction = module.func;\n      } else {\n        setupWarningLogger.warn(\n          'No function found for running logic of scene ' + this._name\n        );\n        this._eventsFunction = function () {};\n      }\n    }\n\n    /**\n     * Set the function called each time the scene is stepped.\n     * The function will be passed the `runtimeScene` as argument.\n     *\n     * Note that this is already set up by the gdjs.RuntimeScene constructor and that you should\n     * not need to use this method.\n     *\n     * @param func The function to be called.\n     */\n    setEventsFunction(func: () => void): void {\n      this._eventsFunction = func;\n    }\n\n    /**\n     * Step and render the scene.\n     * @param elapsedTime In milliseconds\n     * @return true if the game loop should continue, false if a scene change/push/pop\n     * or a game stop was requested.\n     */\n    renderAndStep(elapsedTime: float): boolean {\n      if (this._profiler) {\n        this._profiler.beginFrame();\n      }\n      this._requestedChange = SceneChangeRequest.CONTINUE;\n      this._timeManager.update(\n        elapsedTime,\n        this._runtimeGame.getMinimalFramerate()\n      );\n      if (this._profiler) {\n        this._profiler.begin('asynchronous actions (wait action, etc...)');\n      }\n      this._asyncTasksManager.processTasks(this);\n      if (this._profiler) {\n        this._profiler.end('asynchronous actions (wait action, etc...)');\n      }\n      if (this._profiler) {\n        this._profiler.begin('objects (pre-events)');\n      }\n      this._updateObjectsPreEvents();\n      if (this._profiler) {\n        this._profiler.end('objects (pre-events)');\n      }\n      if (this._profiler) {\n        this._profiler.begin('callbacks and extensions (pre-events)');\n      }\n      for (let i = 0; i < gdjs.callbacksRuntimeScenePreEvents.length; ++i) {\n        gdjs.callbacksRuntimeScenePreEvents[i](this);\n      }\n      if (this._profiler) {\n        this._profiler.end('callbacks and extensions (pre-events)');\n      }\n      if (this._profiler) {\n        this._profiler.begin('events');\n      }\n      if (this._eventsFunction !== null) this._eventsFunction(this);\n      if (this._profiler) {\n        this._profiler.end('events');\n      }\n      if (this._profiler) {\n        this._profiler.begin('objects (post-events)');\n      }\n      this._updateObjectsPostEvents();\n      if (this._profiler) {\n        this._profiler.end('objects (post-events)');\n      }\n      if (this._profiler) {\n        this._profiler.begin('callbacks and extensions (post-events)');\n      }\n      for (let i = 0; i < gdjs.callbacksRuntimeScenePostEvents.length; ++i) {\n        gdjs.callbacksRuntimeScenePostEvents[i](this);\n      }\n      if (this._profiler) {\n        this._profiler.end('callbacks and extensions (post-events)');\n      }\n      if (this._profiler) {\n        this._profiler.begin('objects (pre-render, effects update)');\n      }\n      this._updateObjectsPreRender();\n      if (this._profiler) {\n        this._profiler.end('objects (pre-render, effects update)');\n      }\n      if (this._profiler) {\n        this._profiler.begin('layers (effects update)');\n      }\n      this._updateLayersPreRender();\n      if (this._profiler) {\n        this._profiler.end('layers (effects update)');\n      }\n      if (this._profiler) {\n        this._profiler.begin('render');\n      }\n\n      // Set to true to enable debug rendering (look for the implementation in the renderer\n      // to see what is rendered).\n      if (this._debugDrawEnabled) {\n        this._debuggerRenderer.renderDebugDraw(\n          this.getAdhocListOfAllInstances(),\n          this._debugDrawShowHiddenInstances,\n          this._debugDrawShowPointsNames,\n          this._debugDrawShowCustomPoints\n        );\n      }\n\n      this._isJustResumed = false;\n      this.render();\n      if (this._profiler) {\n        this._profiler.end('render');\n      }\n      if (this._profiler) {\n        this._profiler.endFrame();\n      }\n      return !!this.getRequestedChange();\n    }\n\n    /**\n     * Render the PIXI container associated to the runtimeScene.\n     */\n    render() {\n      this._renderer.render();\n    }\n\n    /**\n     * Called to update visibility of the renderers of objects\n     * rendered on the scene (\"culling\"), update effects (of visible objects)\n     * and give a last chance for objects to update before rendering.\n     *\n     * Visibility is set to false if object is hidden, or if\n     * object is too far from the camera of its layer (\"culling\").\n     */\n    _updateObjectsPreRender() {\n      if (this._timeManager.isFirstFrame()) {\n        super._updateObjectsPreRender();\n        return;\n      } else {\n        // After first frame, optimise rendering by setting only objects\n        // near camera as visible.\n        // TODO: For compatibility, pass a scale of `2`,\n        // meaning that size of cameras will be multiplied by 2 and so objects\n        // will be hidden if they are outside of this *larger* camera area.\n        // This is useful for:\n        // - objects not properly reporting their visibility AABB,\n        // (so we have a \"safety margin\") but these objects should be fixed\n        // instead.\n        // - objects having effects rendering outside of their visibility AABB.\n\n        // TODO (3D) culling - add support for 3D object culling?\n        this._updateLayersCameraCoordinates(2);\n        const allInstancesList = this.getAdhocListOfAllInstances();\n        for (let i = 0, len = allInstancesList.length; i < len; ++i) {\n          const object = allInstancesList[i];\n          const rendererObject = object.getRendererObject();\n          if (rendererObject) {\n            if (object.isHidden()) {\n              rendererObject.visible = false;\n            } else {\n              const cameraCoords = this._layersCameraCoordinates[\n                object.getLayer()\n              ];\n              if (!cameraCoords) {\n                continue;\n              }\n              const aabb = object.getVisibilityAABB();\n              rendererObject.visible =\n                // If no AABB is returned, the object should always be visible\n                !aabb ||\n                // If an AABB is there, it must be at least partially inside\n                // the camera bounds.\n                !(\n                  aabb.min[0] > cameraCoords[2] ||\n                  aabb.min[1] > cameraCoords[3] ||\n                  aabb.max[0] < cameraCoords[0] ||\n                  aabb.max[1] < cameraCoords[1]\n                );\n            }\n\n            // Update effects, only for visible objects.\n            if (rendererObject.visible) {\n              this._runtimeGame\n                .getEffectsManager()\n                .updatePreRender(object.getRendererEffects(), object);\n\n              // Perform pre-render update only if the object is visible\n              // (including if there is no visibility AABB returned previously).\n              object.updatePreRender(this);\n            }\n          } else {\n            // Perform pre-render update, always for objects not having an\n            // associated renderer object (so it must handle visibility on its own).\n            object.updatePreRender(this);\n          }\n        }\n      }\n    }\n\n    /**\n     * Change the background color, by setting the RGB components.\n     * Internally, the color is stored as an hexadecimal number.\n     *\n     * @param r The color red component (0-255).\n     * @param g The color green component (0-255).\n     * @param b The color blue component (0-255).\n     */\n    setBackgroundColor(r: integer, g: integer, b: integer): void {\n      this._backgroundColor = parseInt(gdjs.rgbToHex(r, g, b), 16);\n    }\n\n    /**\n     * Get the background color, as an hexadecimal number.\n     * @returns The current background color.\n     */\n    getBackgroundColor(): number {\n      return this._backgroundColor;\n    }\n\n    /**\n     * Get the name of the scene.\n     */\n    getName(): string {\n      return this._name;\n    }\n\n    /**\n     * Create an identifier for a new object of the scene.\n     */\n    createNewUniqueId(): integer {\n      this._lastId++;\n      return this._lastId;\n    }\n\n    getRenderer(): gdjs.RuntimeScenePixiRenderer {\n      return this._renderer;\n    }\n\n    getDebuggerRenderer() {\n      return this._debuggerRenderer;\n    }\n\n    getGame() {\n      return this._runtimeGame;\n    }\n\n    getScene() {\n      return this;\n    }\n\n    getViewportWidth(): float {\n      return this._cachedGameResolutionWidth;\n    }\n\n    getViewportHeight(): float {\n      return this._cachedGameResolutionHeight;\n    }\n\n    getViewportOriginX(): float {\n      return this._cachedGameResolutionWidth / 2;\n    }\n\n    getViewportOriginY(): float {\n      return this._cachedGameResolutionHeight / 2;\n    }\n\n    convertCoords(x: float, y: float, result: FloatPoint): FloatPoint {\n      // The result parameter used to be optional.\n      const point = result || [0, 0];\n      point[0] = x;\n      point[1] = y;\n      return point;\n    }\n\n    convertInverseCoords(\n      sceneX: float,\n      sceneY: float,\n      result: FloatPoint\n    ): FloatPoint {\n      const point = result || [0, 0];\n      point[0] = sceneX;\n      point[1] = sceneY;\n      return point;\n    }\n\n    onChildrenLocationChanged(): void {\n      // Scenes don't maintain bounds.\n    }\n\n    /**\n     * Get the variables of the runtimeScene.\n     * @return The container holding the variables of the scene.\n     */\n    getVariables() {\n      return this._variables;\n    }\n\n    /**\n     * Get the TimeManager of the scene.\n     * @return The gdjs.TimeManager of the scene.\n     */\n    getTimeManager(): gdjs.TimeManager {\n      return this._timeManager;\n    }\n\n    /**\n     * Return the time elapsed since the last frame,\n     * in milliseconds, for objects on the layer.\n     */\n    getElapsedTime(): float {\n      return this._timeManager.getElapsedTime();\n    }\n\n    /**\n     * Shortcut to get the SoundManager of the game.\n     * @return The gdjs.SoundManager of the game.\n     */\n    getSoundManager(): gdjs.SoundManager {\n      return this._runtimeGame.getSoundManager();\n    }\n\n    /**\n     * @returns The scene's async tasks manager.\n     */\n    getAsyncTasksManager() {\n      return this._asyncTasksManager;\n    }\n\n    /**\n     * Return the value of the scene change that is requested.\n     */\n    getRequestedChange(): SceneChangeRequest {\n      return this._requestedChange;\n    }\n\n    /**\n     * Return the name of the new scene to be launched.\n     *\n     * See requestChange.\n     */\n    getRequestedScene(): string {\n      return this._requestedScene;\n    }\n\n    /**\n     * Request a scene change to be made. The change is handled externally (see gdjs.SceneStack)\n     * thanks to getRequestedChange and getRequestedScene methods.\n     * @param change One of RuntimeScene.CONTINUE|PUSH_SCENE|POP_SCENE|REPLACE_SCENE|CLEAR_SCENES|STOP_GAME.\n     * @param sceneName The name of the new scene to launch, if applicable.\n     */\n    requestChange(change: SceneChangeRequest, sceneName?: string) {\n      this._requestedChange = change;\n      if (sceneName) this._requestedScene = sceneName;\n    }\n\n    /**\n     * Get the profiler associated with the scene, or null if none.\n     */\n    getProfiler(): gdjs.Profiler | null {\n      return this._profiler;\n    }\n\n    /**\n     * Start a new profiler to measures the time passed in sections of the engine\n     * in the scene.\n     * @param onProfilerStopped Function to be called when the profiler is stopped. Will be passed the profiler as argument.\n     */\n    startProfiler(onProfilerStopped: (oldProfiler: gdjs.Profiler) => void) {\n      if (this._profiler) {\n        return;\n      }\n      this._profiler = new gdjs.Profiler();\n      this._onProfilerStopped = onProfilerStopped;\n    }\n\n    /**\n     * Stop the profiler being run on the scene.\n     */\n    stopProfiler() {\n      if (!this._profiler) {\n        return;\n      }\n      const oldProfiler = this._profiler;\n      const onProfilerStopped = this._onProfilerStopped;\n      this._profiler = null;\n      this._onProfilerStopped = null;\n      if (onProfilerStopped) {\n        onProfilerStopped(oldProfiler);\n      }\n    }\n\n    /**\n     * Get the structure containing the triggers for \"Trigger once\" conditions.\n     */\n    getOnceTriggers() {\n      return this._onceTriggers;\n    }\n\n    /**\n     * Check if the scene was just resumed.\n     * This is true during the first frame after the scene has been unpaused.\n     *\n     * @returns true if the scene was just resumed\n     */\n    sceneJustResumed(): boolean {\n      return this._isJustResumed;\n    }\n  }\n\n  //The flags to describe the change request by a scene:\n  export enum SceneChangeRequest {\n    CONTINUE,\n    PUSH_SCENE,\n    POP_SCENE,\n    REPLACE_SCENE,\n    CLEAR_SCENES,\n    STOP_GAME,\n  }\n}\n"],
  "mappings": "AAKA,GAAU,MAAV,UAAU,EAAV,CACE,KAAM,GAAS,GAAI,GAAK,OAAO,gBACzB,EAAqB,GAAI,GAAK,OAAO,iCAKpC,eAA2B,GAAK,wBAAyB,CAkC9D,YAAY,EAA+B,CACzC,QAlCF,qBAAiE,KAMjE,aAAmB,EACnB,WAAgB,GAEhB,wBAA8B,GAC9B,qBAA0B,GAClB,wBAAqB,GAAI,GAAK,kBAGtC,eAAqB,GAErB,oBAA0B,GAI1B,sBAA4B,EAE5B,eAAkC,KAGlC,wBAAoE,KAUlE,KAAK,aAAe,EACpB,KAAK,WAAa,GAAI,GAAK,mBAC3B,KAAK,aAAe,GAAI,GAAK,YAC7B,KAAK,cAAgB,GAAI,GAAK,aAC9B,KAAK,iBAAmB,EAAmB,SAC3C,KAAK,2BAA6B,EAC9B,EAAY,yBACZ,EACJ,KAAK,4BAA8B,EAC/B,EAAY,0BACZ,EAEJ,KAAK,UAAY,GAAI,GAAK,qBACxB,KAEA,EAAc,EAAY,cAAgB,MAE5C,KAAK,kBAAoB,GAAI,GAAK,iBAAiB,MAKnD,KAAK,0BAGP,SAAS,EAAsB,CAC7B,KAAM,GAAQ,GAAI,GAAK,MAAM,EAAW,MACxC,KAAK,QAAQ,IAAI,EAAU,KAAM,GACjC,KAAK,eAAe,KAAK,GAO3B,yBAA0B,CACxB,KAAM,GAA2B,KAAK,qBAChC,EAA2B,KAAK,qBACtC,KAAK,2BAA6B,KAAK,aACnC,KAAK,aAAa,yBAClB,EACJ,KAAK,4BAA8B,KAAK,aACpC,KAAK,aAAa,0BAClB,EACJ,SAAW,KAAQ,MAAK,QAAQ,MAC9B,AAAI,KAAK,QAAQ,MAAM,eAAe,IAEpC,AADoC,KAAK,QAAQ,MAAM,GAC9C,wBACP,EACA,GAIN,KAAK,UAAU,0BAQjB,cAAc,EAA8B,CAC1C,GAAI,CAAC,EAAW,CACd,EAAO,MAAM,4CACb,OAGF,AAAI,KAAK,WACP,KAAK,cAIH,KAAK,cACP,KAAK,aAAa,cAAc,eAAe,EAAU,OAE3D,KAAK,MAAQ,EAAU,KACvB,KAAK,mBAAmB,EAAU,EAAG,EAAU,EAAG,EAAU,GAG5D,OAAS,GAAI,EAAG,EAAM,EAAU,OAAO,OAAQ,EAAI,EAAK,EAAE,EACxD,KAAK,SAAS,EAAU,OAAO,IAIjC,KAAK,WAAa,GAAI,GAAK,mBAAmB,EAAU,WAGxD,OACM,GAAI,EAAG,EAAM,EAAU,oBAAoB,OAC/C,EAAI,EACJ,EAAE,EACF,CACA,KAAM,GAAqB,EAAU,oBAAoB,GACzD,KAAK,gCACH,EAAmB,KACnB,GAKJ,KAAM,GAA2B,KAAK,UAAU,wBAChD,OAAS,GAAI,EAAG,EAAM,EAAyB,OAAQ,EAAI,EAAK,EAAE,EAChE,KAAK,eAAe,EAAyB,IAI/C,OAAS,GAAI,EAAG,EAAM,EAAU,QAAQ,OAAQ,EAAI,EAAK,EAAE,EACzD,KAAK,eAAe,EAAU,QAAQ,IAoBxC,GAhBA,KAAK,kBACH,EAAU,UACV,EACA,EAEA,IAIF,KAAK,0BAGL,KAAK,+BAA+B,GACpC,KAAK,cAAgB,GAAI,GAAK,aAG1B,KAAK,cAAgB,CAAC,KAAK,aAAa,sBAC1C,OAAS,GAAI,EAAG,EAAI,EAAK,iCAAiC,OAAQ,EAAE,EAClE,EAAK,iCAAiC,GAAG,MAG7C,OAAS,GAAI,EAAG,EAAI,EAAK,4BAA4B,OAAQ,EAAE,EAC7D,EAAK,4BAA4B,GAAG,MAEtC,AAAI,EAAU,qBAAuB,KAAK,cACxC,KAAK,aAAa,kBAAkB,WAEtC,KAAK,UAAY,GACjB,KAAK,aAAa,QAGpB,gCAAgC,EAAyC,CAGvE,KAAM,GAAqB,MAAM,gCAAgC,GACjE,MAAK,IACH,EAAO,MAAM,kDAAoD,GAE5D,EAOT,SAAU,CAGR,KAAM,GAAmB,KAAK,6BAC9B,OAAS,GAAI,EAAG,EAAM,EAAiB,OAAQ,EAAI,EAAK,EAAE,EAExD,AADe,EAAiB,GACzB,cAAc,MAGvB,OAAS,GAAI,EAAG,EAAI,EAAK,4BAA4B,OAAQ,EAAE,EAC7D,EAAK,4BAA4B,GAAG,MAQxC,UAAW,CACT,KAAK,eAAiB,GAItB,KAAM,GAAmB,KAAK,6BAC9B,OAAS,GAAI,EAAG,EAAM,EAAiB,OAAQ,EAAI,EAAK,EAAE,EAExD,AADe,EAAiB,GACzB,eAAe,MAGxB,OAAS,GAAI,EAAG,EAAI,EAAK,6BAA6B,OAAQ,EAAE,EAC9D,EAAK,6BAA6B,GAAG,MAQzC,aAAc,CACZ,GAAI,CAAC,KAAK,UACR,OAEF,AAAI,KAAK,WACP,KAAK,eAKP,OAAS,GAAI,EAAG,EAAI,EAAK,+BAA+B,OAAQ,EAAE,EAChE,EAAK,+BAA+B,GAAG,MAIzC,KAAM,GAAmB,KAAK,6BAC9B,OAAS,GAAI,EAAG,EAAM,EAAiB,OAAQ,EAAI,EAAK,EAAE,EAExD,AADe,EAAiB,GACzB,mBAAmB,MAI5B,AAAI,KAAK,WACP,KAAK,UAAU,kBAMjB,OAAS,GAAI,EAAG,EAAI,EAAK,8BAA8B,OAAQ,EAAE,EAC/D,EAAK,8BAA8B,GAAG,MAGxC,KAAK,WAEL,KAAK,UAAY,GACjB,KAAK,0BAGP,UAAW,CAGT,MAAM,WACN,KAAK,WAAa,GAAI,GAAK,mBAC3B,KAAK,2BAA6B,GAAI,WACtC,KAAK,gBAAkB,KACvB,KAAK,QAAU,EAEf,KAAK,cAAgB,KAUvB,+BAA+B,EAA6B,CAC1D,KAAM,GAAS,EAAK,EAAU,YAAc,QAC5C,AAAI,GAAU,EAAO,KACnB,KAAK,gBAAkB,EAAO,KAE9B,GAAmB,KACjB,gDAAkD,KAAK,OAEzD,KAAK,gBAAkB,UAAY,IAavC,kBAAkB,EAAwB,CACxC,KAAK,gBAAkB,EASzB,cAAc,EAA6B,CACzC,AAAI,KAAK,WACP,KAAK,UAAU,aAEjB,KAAK,iBAAmB,EAAmB,SAC3C,KAAK,aAAa,OAChB,EACA,KAAK,aAAa,uBAEhB,KAAK,WACP,KAAK,UAAU,MAAM,8CAEvB,KAAK,mBAAmB,aAAa,MACjC,KAAK,WACP,KAAK,UAAU,IAAI,8CAEjB,KAAK,WACP,KAAK,UAAU,MAAM,wBAEvB,KAAK,0BACD,KAAK,WACP,KAAK,UAAU,IAAI,wBAEjB,KAAK,WACP,KAAK,UAAU,MAAM,yCAEvB,OAAS,GAAI,EAAG,EAAI,EAAK,+BAA+B,OAAQ,EAAE,EAChE,EAAK,+BAA+B,GAAG,MAEzC,AAAI,KAAK,WACP,KAAK,UAAU,IAAI,yCAEjB,KAAK,WACP,KAAK,UAAU,MAAM,UAEnB,KAAK,kBAAoB,MAAM,KAAK,gBAAgB,MACpD,KAAK,WACP,KAAK,UAAU,IAAI,UAEjB,KAAK,WACP,KAAK,UAAU,MAAM,yBAEvB,KAAK,2BACD,KAAK,WACP,KAAK,UAAU,IAAI,yBAEjB,KAAK,WACP,KAAK,UAAU,MAAM,0CAEvB,OAAS,GAAI,EAAG,EAAI,EAAK,gCAAgC,OAAQ,EAAE,EACjE,EAAK,gCAAgC,GAAG,MAE1C,MAAI,MAAK,WACP,KAAK,UAAU,IAAI,0CAEjB,KAAK,WACP,KAAK,UAAU,MAAM,wCAEvB,KAAK,0BACD,KAAK,WACP,KAAK,UAAU,IAAI,wCAEjB,KAAK,WACP,KAAK,UAAU,MAAM,2BAEvB,KAAK,yBACD,KAAK,WACP,KAAK,UAAU,IAAI,2BAEjB,KAAK,WACP,KAAK,UAAU,MAAM,UAKnB,KAAK,mBACP,KAAK,kBAAkB,gBACrB,KAAK,6BACL,KAAK,8BACL,KAAK,0BACL,KAAK,4BAIT,KAAK,eAAiB,GACtB,KAAK,SACD,KAAK,WACP,KAAK,UAAU,IAAI,UAEjB,KAAK,WACP,KAAK,UAAU,WAEV,CAAC,CAAC,KAAK,qBAMhB,QAAS,CACP,KAAK,UAAU,SAWjB,yBAA0B,CACxB,GAAI,KAAK,aAAa,eAAgB,CACpC,MAAM,0BACN,WACK,CAaL,KAAK,+BAA+B,GACpC,KAAM,GAAmB,KAAK,6BAC9B,OAAS,GAAI,EAAG,EAAM,EAAiB,OAAQ,EAAI,EAAK,EAAE,EAAG,CAC3D,KAAM,GAAS,EAAiB,GAC1B,EAAiB,EAAO,oBAC9B,GAAI,EAAgB,CAClB,GAAI,EAAO,WACT,EAAe,QAAU,OACpB,CACL,KAAM,GAAe,KAAK,yBACxB,EAAO,YAET,GAAI,CAAC,EACH,SAEF,KAAM,GAAO,EAAO,oBACpB,EAAe,QAEb,CAAC,GAGD,CACE,GAAK,IAAI,GAAK,EAAa,IAC3B,EAAK,IAAI,GAAK,EAAa,IAC3B,EAAK,IAAI,GAAK,EAAa,IAC3B,EAAK,IAAI,GAAK,EAAa,IAKjC,AAAI,EAAe,SACjB,MAAK,aACF,oBACA,gBAAgB,EAAO,qBAAsB,GAIhD,EAAO,gBAAgB,WAKzB,GAAO,gBAAgB,QAc/B,mBAAmB,EAAY,EAAY,EAAkB,CAC3D,KAAK,iBAAmB,SAAS,EAAK,SAAS,EAAG,EAAG,GAAI,IAO3D,oBAA6B,CAC3B,MAAO,MAAK,iBAMd,SAAkB,CAChB,MAAO,MAAK,MAMd,mBAA6B,CAC3B,YAAK,UACE,KAAK,QAGd,aAA6C,CAC3C,MAAO,MAAK,UAGd,qBAAsB,CACpB,MAAO,MAAK,kBAGd,SAAU,CACR,MAAO,MAAK,aAGd,UAAW,CACT,MAAO,MAGT,kBAA0B,CACxB,MAAO,MAAK,2BAGd,mBAA2B,CACzB,MAAO,MAAK,4BAGd,oBAA4B,CAC1B,MAAO,MAAK,2BAA6B,EAG3C,oBAA4B,CAC1B,MAAO,MAAK,4BAA8B,EAG5C,cAAc,EAAU,EAAU,EAAgC,CAEhE,KAAM,GAAQ,GAAU,CAAC,EAAG,GAC5B,SAAM,GAAK,EACX,EAAM,GAAK,EACJ,EAGT,qBACE,EACA,EACA,EACY,CACZ,KAAM,GAAQ,GAAU,CAAC,EAAG,GAC5B,SAAM,GAAK,EACX,EAAM,GAAK,EACJ,EAGT,2BAAkC,EAQlC,cAAe,CACb,MAAO,MAAK,WAOd,gBAAmC,CACjC,MAAO,MAAK,aAOd,gBAAwB,CACtB,MAAO,MAAK,aAAa,iBAO3B,iBAAqC,CACnC,MAAO,MAAK,aAAa,kBAM3B,sBAAuB,CACrB,MAAO,MAAK,mBAMd,oBAAyC,CACvC,MAAO,MAAK,iBAQd,mBAA4B,CAC1B,MAAO,MAAK,gBASd,cAAc,EAA4B,EAAoB,CAC5D,KAAK,iBAAmB,EACpB,GAAW,MAAK,gBAAkB,GAMxC,aAAoC,CAClC,MAAO,MAAK,UAQd,cAAc,EAAyD,CACrE,AAAI,KAAK,WAGT,MAAK,UAAY,GAAI,GAAK,SAC1B,KAAK,mBAAqB,GAM5B,cAAe,CACb,GAAI,CAAC,KAAK,UACR,OAEF,KAAM,GAAc,KAAK,UACnB,EAAoB,KAAK,mBAC/B,KAAK,UAAY,KACjB,KAAK,mBAAqB,KACtB,GACF,EAAkB,GAOtB,iBAAkB,CAChB,MAAO,MAAK,cASd,kBAA4B,CAC1B,MAAO,MAAK,gBA5rBT,EAAM,eAisBN,GAAK,GAAL,UAAK,EAAL,CACL,2BACA,+BACA,6BACA,qCACA,mCACA,+BANU,qDAxsBJ",
  "names": []
}
