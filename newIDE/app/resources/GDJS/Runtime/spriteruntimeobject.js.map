{
  "version": 3,
  "sources": ["../../../../../GDJS/Runtime/spriteruntimeobject.ts"],
  "sourcesContent": ["/*\n * GDevelop JS Platform\n * Copyright 2013-2016 Florian Rival (Florian.Rival@gmail.com). All rights reserved.\n * This project is released under the MIT License.\n */\nnamespace gdjs {\n  /** Represents a point in a coordinate system. */\n  export type SpritePoint = {\n    /** X position of the point. */\n    x: number;\n    /** Y position of the point. */\n    y: number;\n  };\n\n  /** Represents a custom point in a frame. */\n  export type SpriteCustomPointData = {\n    /** Name of the point. */\n    name: string;\n    /** X position of the point. */\n    x: number;\n    /** Y position of the point. */\n    y: number;\n  };\n\n  /** Represents the center point in a frame. */\n  export type SpriteCenterPointData = {\n    /** Name of the point. */\n    name: string;\n    /** Is the center automatically computed? */\n    automatic: boolean;\n    /** X position of the point. */\n    x: number;\n    /** Y position of the point. */\n    y: number;\n  };\n\n  /** Represents a {@link gdjs.SpriteAnimationFrame}. */\n  export type SpriteFrameData = {\n    /** The resource name of the image used in this frame. */\n    image: string;\n    /** The points of the frame. */\n    points: Array<SpriteCustomPointData>;\n    /** The origin point. */\n    originPoint: SpriteCustomPointData;\n    /** The center of the frame. */\n    centerPoint: SpriteCenterPointData;\n    /** Is The collision mask custom? */\n    hasCustomCollisionMask: boolean;\n    /** The collision mask if it is custom. */\n    customCollisionMask: Array<Array<SpritePoint>>;\n  };\n\n  /** Represents the data of a {@link gdjs.SpriteAnimationDirection}. */\n  export type SpriteDirectionData = {\n    /** Time between each frame, in seconds. */\n    timeBetweenFrames: number;\n    /** Is the animation looping? */\n    looping: boolean;\n    /** The list of frames. */\n    sprites: Array<SpriteFrameData>;\n  };\n\n  /** Represents the data of a {@link gdjs.SpriteAnimation}. */\n  export type SpriteAnimationData = {\n    /** The name of the animation. */\n    name: string;\n    /** Does the animation use multiple {@link gdjs.SpriteAnimationDirection}? */\n    useMultipleDirections: boolean;\n    /** The list of {@link SpriteDirectionData} representing {@link gdjs.SpriteAnimationDirection} instances. */\n    directions: Array<SpriteDirectionData>;\n  };\n\n  /** Represents the data of a {@link gdjs.SpriteRuntimeObject}. */\n  export type SpriteObjectDataType = {\n    /** Update the object even if he is not visible?. */\n    updateIfNotVisible: boolean;\n    /** The list of {@link SpriteAnimationData} representing {@link gdjs.SpriteAnimation} instances. */\n    animations: Array<SpriteAnimationData>;\n  };\n\n  export type SpriteObjectData = ObjectData & SpriteObjectDataType;\n\n  /**\n   * A frame used by a SpriteAnimation in a {@link gdjs.SpriteRuntimeObject}.\n   *\n   * It contains the texture displayed as well as information like the points position\n   * or the collision mask.\n   */\n  export class SpriteAnimationFrame {\n    image: string;\n\n    //TODO: Rename in imageName, and do not store it in the object?\n    texture: any;\n    center: SpritePoint = { x: 0, y: 0 };\n    origin: SpritePoint = { x: 0, y: 0 };\n    hasCustomHitBoxes: boolean = false;\n    customHitBoxes: gdjs.Polygon[] = [];\n    points: Hashtable<SpritePoint>;\n\n    /**\n     * @param imageManager The game image manager\n     * @param frameData The frame data used to initialize the frame\n     */\n    constructor(imageManager: gdjs.ImageManager, frameData: SpriteFrameData) {\n      this.image = frameData ? frameData.image : '';\n      this.texture = gdjs.SpriteRuntimeObjectRenderer.getAnimationFrame(\n        imageManager,\n        this.image\n      );\n      this.points = new Hashtable();\n      this.reinitialize(imageManager, frameData);\n    }\n\n    /**\n     * @param imageManager The game image manager\n     * @param frameData The frame data used to initialize the frame\n     */\n    reinitialize(imageManager: gdjs.ImageManager, frameData: SpriteFrameData) {\n      this.points.clear();\n      for (let i = 0, len = frameData.points.length; i < len; ++i) {\n        const ptData = frameData.points[i];\n        const point = { x: ptData.x, y: ptData.y };\n        this.points.put(ptData.name, point);\n      }\n      const origin = frameData.originPoint;\n      this.origin.x = origin.x;\n      this.origin.y = origin.y;\n      const center = frameData.centerPoint;\n      if (center.automatic !== true) {\n        this.center.x = center.x;\n        this.center.y = center.y;\n      } else {\n        this.center.x =\n          gdjs.SpriteRuntimeObjectRenderer.getAnimationFrameWidth(\n            this.texture\n          ) / 2;\n        this.center.y =\n          gdjs.SpriteRuntimeObjectRenderer.getAnimationFrameHeight(\n            this.texture\n          ) / 2;\n      }\n\n      //Load the custom collision mask, if any:\n      if (frameData.hasCustomCollisionMask) {\n        this.hasCustomHitBoxes = true;\n        let i = 0;\n        for (let len = frameData.customCollisionMask.length; i < len; ++i) {\n          const polygonData: SpritePoint[] = frameData.customCollisionMask[i];\n\n          //Add a polygon, if necessary (Avoid recreating a polygon if it already exists).\n          if (i >= this.customHitBoxes.length) {\n            this.customHitBoxes.push(new gdjs.Polygon());\n          }\n          let j = 0;\n          for (const len2 = polygonData.length; j < len2; ++j) {\n            const pointData: SpritePoint = polygonData[j];\n\n            //Add a point, if necessary (Avoid recreating a point if it already exists).\n            if (j >= this.customHitBoxes[i].vertices.length) {\n              this.customHitBoxes[i].vertices.push([0, 0]);\n            }\n            this.customHitBoxes[i].vertices[j][0] = pointData.x;\n            this.customHitBoxes[i].vertices[j][1] = pointData.y;\n          }\n          this.customHitBoxes[i].vertices.length = j;\n        }\n        this.customHitBoxes.length = i;\n      } else {\n        this.customHitBoxes.length = 0;\n      }\n    }\n\n    /**\n     * Get a point of the frame.<br>\n     * If the point does not exist, the origin is returned.\n     * @param name The point's name\n     * @return The requested point. If it doesn't exists returns the origin point.\n     */\n    getPoint(name: string): SpritePoint {\n      if (name === 'Centre' || name === 'Center') {\n        return this.center;\n      } else {\n        if (name === 'Origin') {\n          return this.origin;\n        }\n      }\n      return this.points.containsKey(name)\n        ? this.points.get(name)\n        : this.origin;\n    }\n  }\n\n  /**\n   * Represents a direction of an animation of a {@link gdjs.SpriteRuntimeObject}.\n   *\n   * @param imageManager The game image manager\n   * @param directionData The direction data used to initialize the direction\n   */\n  export class SpriteAnimationDirection {\n    timeBetweenFrames: number;\n    loop: boolean;\n    frames: SpriteAnimationFrame[] = [];\n\n    constructor(\n      imageManager: gdjs.PixiImageManager,\n      directionData: SpriteDirectionData\n    ) {\n      this.timeBetweenFrames = directionData\n        ? directionData.timeBetweenFrames\n        : 1.0;\n      this.loop = !!directionData.looping;\n      this.reinitialize(imageManager, directionData);\n    }\n\n    /**\n     * @param imageManager The game image manager\n     * @param directionData The direction data used to initialize the direction\n     */\n    reinitialize(\n      imageManager: gdjs.ImageManager,\n      directionData: SpriteDirectionData\n    ) {\n      this.timeBetweenFrames = directionData\n        ? directionData.timeBetweenFrames\n        : 1.0;\n      this.loop = !!directionData.looping;\n      let i = 0;\n      for (const len = directionData.sprites.length; i < len; ++i) {\n        const frameData = directionData.sprites[i];\n        if (i < this.frames.length) {\n          this.frames[i].reinitialize(imageManager, frameData);\n        } else {\n          this.frames.push(\n            new gdjs.SpriteAnimationFrame(imageManager, frameData)\n          );\n        }\n      }\n      this.frames.length = i;\n    }\n  }\n\n  /**\n   * Represents an animation of a {@link SpriteRuntimeObject}.\n   *\n   * @param imageManager The game image manager\n   * @param animData The animation data used to initialize the animation\n   */\n  export class SpriteAnimation {\n    hasMultipleDirections: boolean;\n    name: string;\n    directions: gdjs.SpriteAnimationDirection[] = [];\n\n    constructor(\n      imageManager: gdjs.PixiImageManager,\n      animData: SpriteAnimationData\n    ) {\n      this.hasMultipleDirections = !!animData.useMultipleDirections;\n      this.name = animData.name || '';\n      this.reinitialize(imageManager, animData);\n    }\n\n    /**\n     * @param imageManager The game image manager\n     * @param animData The animation data used to initialize the animation\n     */\n    reinitialize(\n      imageManager: gdjs.ImageManager,\n      animData: SpriteAnimationData\n    ) {\n      this.hasMultipleDirections = !!animData.useMultipleDirections;\n      this.name = animData.name || '';\n      let i = 0;\n      for (const len = animData.directions.length; i < len; ++i) {\n        const directionData = animData.directions[i];\n        if (i < this.directions.length) {\n          this.directions[i].reinitialize(imageManager, directionData);\n        } else {\n          this.directions.push(\n            new gdjs.SpriteAnimationDirection(imageManager, directionData)\n          );\n        }\n      }\n      // Make sure to delete already existing directions which are not used anymore.\n      this.directions.length = i;\n    }\n  }\n\n  /**\n   * The SpriteRuntimeObject represents an object that can display images.\n   */\n  export class SpriteRuntimeObject extends gdjs.RuntimeObject {\n    _currentAnimation: number = 0;\n    _currentDirection: number = 0;\n    _currentFrame: number = 0;\n    /** In seconds */\n    _frameElapsedTime: float = 0;\n    _animationSpeedScale: number = 1;\n    _animationPaused: boolean = false;\n    _scaleX: number = 1;\n    _scaleY: number = 1;\n    _blendMode: number = 0;\n    _flippedX: boolean = false;\n    _flippedY: boolean = false;\n    opacity: float = 255;\n    _updateIfNotVisible: boolean;\n\n    //Animations:\n    _animations: gdjs.SpriteAnimation[] = [];\n\n    /**\n     * Reference to the current SpriteAnimationFrame that is displayed.\n     * Verify is `this._animationFrameDirty === true` before using it, and if so\n     * call `this._updateAnimationFrame()`.\n     * Can be null, so ensure that this case is handled properly.\n     */\n    _animationFrame: gdjs.SpriteAnimationFrame | null = null;\n    _renderer: gdjs.SpriteRuntimeObjectRenderer;\n    _animationFrameDirty: boolean = true;\n\n    /**\n     * @param instanceContainer The container the object belongs to\n     * @param spriteObjectData The object data used to initialize the object\n     */\n    constructor(\n      instanceContainer: gdjs.RuntimeInstanceContainer,\n      spriteObjectData: ObjectData & SpriteObjectDataType\n    ) {\n      super(instanceContainer, spriteObjectData);\n      this._updateIfNotVisible = !!spriteObjectData.updateIfNotVisible;\n      for (let i = 0, len = spriteObjectData.animations.length; i < len; ++i) {\n        this._animations.push(\n          new gdjs.SpriteAnimation(\n            instanceContainer.getGame().getImageManager(),\n            spriteObjectData.animations[i]\n          )\n        );\n      }\n      this._renderer = new gdjs.SpriteRuntimeObjectRenderer(\n        this,\n        instanceContainer\n      );\n      this._updateAnimationFrame();\n\n      // *ALWAYS* call `this.onCreated()` at the very end of your object constructor.\n      this.onCreated();\n    }\n\n    reinitialize(spriteObjectData: SpriteObjectData) {\n      super.reinitialize(spriteObjectData);\n      const instanceContainer = this.getInstanceContainer();\n      this._currentAnimation = 0;\n      this._currentDirection = 0;\n      this._currentFrame = 0;\n      this._frameElapsedTime = 0;\n      this._animationSpeedScale = 1;\n      this._animationPaused = false;\n      this._scaleX = 1;\n      this._scaleY = 1;\n      this._blendMode = 0;\n      this._flippedX = false;\n      this._flippedY = false;\n      this.opacity = 255;\n      this._updateIfNotVisible = !!spriteObjectData.updateIfNotVisible;\n      let i = 0;\n      for (const len = spriteObjectData.animations.length; i < len; ++i) {\n        const animData = spriteObjectData.animations[i];\n        if (i < this._animations.length) {\n          this._animations[i].reinitialize(\n            instanceContainer.getGame().getImageManager(),\n            animData\n          );\n        } else {\n          this._animations.push(\n            new gdjs.SpriteAnimation(\n              instanceContainer.getGame().getImageManager(),\n              animData\n            )\n          );\n        }\n      }\n      this._animations.length = i;\n\n      //Make sure to delete already existing animations which are not used anymore.\n      this._animationFrame = null;\n      this._renderer.reinitialize(this, instanceContainer);\n      this._updateAnimationFrame();\n\n      // *ALWAYS* call `this.onCreated()` at the very end of your object reinitialize method.\n      this.onCreated();\n    }\n\n    updateFromObjectData(\n      oldObjectData: SpriteObjectData,\n      newObjectData: SpriteObjectData\n    ): boolean {\n      const instanceContainer = this.getInstanceContainer();\n      let i = 0;\n      for (const len = newObjectData.animations.length; i < len; ++i) {\n        const animData = newObjectData.animations[i];\n        if (i < this._animations.length) {\n          this._animations[i].reinitialize(\n            instanceContainer.getGame().getImageManager(),\n            animData\n          );\n        } else {\n          this._animations.push(\n            new gdjs.SpriteAnimation(\n              instanceContainer.getGame().getImageManager(),\n              animData\n            )\n          );\n        }\n      }\n      this._animations.length = i;\n\n      //Make sure to delete already existing animations which are not used anymore.\n      this._updateAnimationFrame();\n      if (!this._animationFrame) {\n        this.setAnimation(0);\n      }\n      this.invalidateHitboxes();\n      return true;\n    }\n\n    /**\n     * Initialize the extra parameters that could be set for an instance.\n     * @param initialInstanceData The extra parameters\n     */\n    extraInitializationFromInitialInstance(initialInstanceData: InstanceData) {\n      if (initialInstanceData.numberProperties) {\n        for (\n          let i = 0, len = initialInstanceData.numberProperties.length;\n          i < len;\n          ++i\n        ) {\n          const extraData = initialInstanceData.numberProperties[i];\n          if (extraData.name === 'animation') {\n            this.setAnimation(extraData.value);\n          }\n        }\n      }\n      if (initialInstanceData.customSize) {\n        this.setWidth(initialInstanceData.width);\n        this.setHeight(initialInstanceData.height);\n      }\n    }\n\n    /**\n     * Update the current frame of the object according to the elapsed time on the scene.\n     */\n    update(instanceContainer: gdjs.RuntimeInstanceContainer): void {\n      //Playing the animation of all objects including the ones outside the screen can be\n      //costly when the scene is big with a lot of animated objects. By default, we skip\n      //updating the object if it is not visible.\n      if (\n        !this._updateIfNotVisible &&\n        !this._renderer.getRendererObject().visible\n      ) {\n        return;\n      }\n      if (\n        this._currentAnimation >= this._animations.length ||\n        this._currentDirection >=\n          this._animations[this._currentAnimation].directions.length\n      ) {\n        return;\n      }\n      const direction = this._animations[this._currentAnimation].directions[\n        this._currentDirection\n      ];\n      const oldFrame = this._currentFrame;\n\n      const elapsedTime = this.getElapsedTime() / 1000;\n      this._frameElapsedTime += this._animationPaused\n        ? 0\n        : elapsedTime * this._animationSpeedScale;\n\n      if (\n        !direction.loop &&\n        this._currentFrame >= direction.frames.length - 1 &&\n        this._frameElapsedTime > direction.timeBetweenFrames\n      ) {\n        // *Optimization*: Animation is finished, don't change the current frame\n        // and compute nothing more.\n      } else {\n        if (this._frameElapsedTime > direction.timeBetweenFrames) {\n          const count = Math.floor(\n            this._frameElapsedTime / direction.timeBetweenFrames\n          );\n          this._currentFrame += count;\n          this._frameElapsedTime =\n            this._frameElapsedTime - count * direction.timeBetweenFrames;\n          if (this._frameElapsedTime < 0) {\n            this._frameElapsedTime = 0;\n          }\n        }\n        if (this._currentFrame >= direction.frames.length) {\n          this._currentFrame = direction.loop\n            ? this._currentFrame % direction.frames.length\n            : direction.frames.length - 1;\n        }\n        if (this._currentFrame < 0) {\n          this._currentFrame = 0;\n        }\n      }\n\n      //May happen if there is no frame.\n      if (oldFrame !== this._currentFrame || this._animationFrameDirty) {\n        this._updateAnimationFrame();\n      }\n      if (oldFrame !== this._currentFrame) {\n        this.invalidateHitboxes();\n      }\n      this._renderer.ensureUpToDate();\n    }\n\n    /**\n     * Ensure the sprite is ready to be displayed: the proper animation frame\n     * is set and the renderer is up to date (position, angle, alpha, flip, blend mode...).\n     */\n    updatePreRender(instanceContainer: gdjs.RuntimeInstanceContainer): void {\n      if (this._animationFrameDirty) {\n        this._updateAnimationFrame();\n      }\n      this._renderer.ensureUpToDate();\n    }\n\n    /**\n     * Update `this._animationFrame` according to the current animation/direction/frame values\n     * (`this._currentAnimation`, `this._currentDirection`, `this._currentFrame`) and set\n     * `this._animationFrameDirty` back to false.\n     *\n     * Trigger a call to the renderer to change the texture being shown (if the animation/direction/frame\n     * is valid).\n     * If invalid, `this._animationFrame` will be `null` after calling this function.\n     */\n    _updateAnimationFrame() {\n      this._animationFrameDirty = false;\n      if (\n        this._currentAnimation < this._animations.length &&\n        this._currentDirection <\n          this._animations[this._currentAnimation].directions.length\n      ) {\n        const direction = this._animations[this._currentAnimation].directions[\n          this._currentDirection\n        ];\n        if (this._currentFrame < direction.frames.length) {\n          this._animationFrame = direction.frames[this._currentFrame];\n          if (this._animationFrame !== null) {\n            this._renderer.updateFrame(this._animationFrame);\n          }\n          return;\n        }\n      }\n\n      //Invalid animation/direction/frame:\n      this._animationFrame = null;\n    }\n\n    getRendererObject() {\n      return this._renderer.getRendererObject();\n    }\n\n    /**\n     * Update the hit boxes for the object.\n     * Fallback to the default implementation (rotated bounding box) if there is no custom\n     * hitboxes defined for the current animation frame.\n     */\n    updateHitBoxes(): void {\n      if (this._animationFrameDirty) {\n        this._updateAnimationFrame();\n      }\n      //Beware, `this._animationFrame` can still be null.\n      if (this._animationFrame === null) {\n        return;\n      }\n\n      if (!this._animationFrame.hasCustomHitBoxes) {\n        return super.updateHitBoxes();\n      }\n\n      //logger.log(\"Update for \"+this.name); //Uncomment to track updates\n      //(and in particular be sure that unnecessary update are avoided).\n\n      //Update the current hitboxes with the frame custom hit boxes\n      //and apply transformations.\n      for (let i = 0; i < this._animationFrame.customHitBoxes.length; ++i) {\n        if (i >= this.hitBoxes.length) {\n          this.hitBoxes.push(new gdjs.Polygon());\n        }\n        for (\n          let j = 0;\n          j < this._animationFrame.customHitBoxes[i].vertices.length;\n          ++j\n        ) {\n          if (j >= this.hitBoxes[i].vertices.length) {\n            this.hitBoxes[i].vertices.push([0, 0]);\n          }\n          this._transformToGlobal(\n            this._animationFrame.customHitBoxes[i].vertices[j][0],\n            this._animationFrame.customHitBoxes[i].vertices[j][1],\n            this.hitBoxes[i].vertices[j]\n          );\n        }\n        this.hitBoxes[i].vertices.length = this._animationFrame.customHitBoxes[\n          i\n        ].vertices.length;\n      }\n      this.hitBoxes.length = this._animationFrame.customHitBoxes.length;\n    }\n\n    //Rotate and scale and flipping have already been applied to the point by _transformToGlobal.\n    //Animations :\n    /**\n     * Change the animation being played.\n     * @param newAnimation The index of the new animation to be played\n     */\n    setAnimation(newAnimation: number): void {\n      newAnimation = newAnimation | 0;\n      if (\n        newAnimation < this._animations.length &&\n        this._currentAnimation !== newAnimation &&\n        newAnimation >= 0\n      ) {\n        this._currentAnimation = newAnimation;\n        this._currentFrame = 0;\n        this._frameElapsedTime = 0;\n\n        //TODO: This may be unnecessary.\n        this._renderer.update();\n        this._animationFrameDirty = true;\n        this.invalidateHitboxes();\n      }\n    }\n\n    /**\n     * Change the animation being played.\n     * @param newAnimationName The name of the new animation to be played\n     */\n    setAnimationName(newAnimationName: string): void {\n      if (!newAnimationName) {\n        return;\n      }\n      for (let i = 0; i < this._animations.length; ++i) {\n        if (this._animations[i].name === newAnimationName) {\n          return this.setAnimation(i);\n        }\n      }\n    }\n\n    /**\n     * Get the index of the animation being played.\n     * @return The index of the new animation being played\n     */\n    getAnimation(): number {\n      return this._currentAnimation;\n    }\n\n    /**\n     * Get the name of the animation being played.\n     * @return The name of the new animation being played\n     */\n    getAnimationName(): string {\n      if (this._currentAnimation >= this._animations.length) {\n        return '';\n      }\n      return this._animations[this._currentAnimation].name;\n    }\n\n    isCurrentAnimationName(name): boolean {\n      return this.getAnimationName() === name;\n    }\n\n    /**\n     * Change the angle (or direction index) of the object\n     * @param The new angle (or direction index) to be applied\n     */\n    setDirectionOrAngle(newValue): void {\n      if (this._currentAnimation >= this._animations.length) {\n        return;\n      }\n      const anim = this._animations[this._currentAnimation];\n      if (!anim.hasMultipleDirections) {\n        if (this.angle === newValue) {\n          return;\n        }\n        this.angle = newValue;\n        this.invalidateHitboxes();\n        this._renderer.updateAngle();\n      } else {\n        newValue = newValue | 0;\n        if (\n          newValue === this._currentDirection ||\n          newValue >= anim.directions.length ||\n          anim.directions[newValue].frames.length === 0\n        ) {\n          return;\n        }\n        this._currentDirection = newValue;\n        this._currentFrame = 0;\n        this._frameElapsedTime = 0;\n        this.angle = 0;\n\n        //TODO: This may be unnecessary.\n        this._renderer.update();\n        this._animationFrameDirty = true;\n        this.invalidateHitboxes();\n      }\n    }\n\n    getDirectionOrAngle(): float {\n      if (this._currentAnimation >= this._animations.length) {\n        return 0;\n      }\n      if (!this._animations[this._currentAnimation].hasMultipleDirections) {\n        return this.angle;\n      } else {\n        return this._currentDirection;\n      }\n    }\n\n    /**\n     * Change the current frame displayed by the animation\n     * @param newFrame The index of the frame to be displayed\n     */\n    setAnimationFrame(newFrame: number): void {\n      if (\n        this._currentAnimation >= this._animations.length ||\n        this._currentDirection >=\n          this._animations[this._currentAnimation].directions.length\n      ) {\n        return;\n      }\n      const direction = this._animations[this._currentAnimation].directions[\n        this._currentDirection\n      ];\n      if (\n        newFrame >= 0 &&\n        newFrame < direction.frames.length &&\n        newFrame !== this._currentFrame\n      ) {\n        this._currentFrame = newFrame;\n        this._frameElapsedTime = 0;\n        this._animationFrameDirty = true;\n        this.invalidateHitboxes();\n      }\n    }\n\n    /**\n     * Get the index of the current frame displayed by the animation\n     * @return newFrame The index of the frame being displayed\n     */\n    getAnimationFrame(): number {\n      return this._currentFrame;\n    }\n\n    getAnimationFrameCount(): number {\n      if (this._currentAnimation >= this._animations.length) {\n        return 0;\n      }\n      const currentAnimation = this._animations[this._currentAnimation];\n      if (this._currentDirection >= currentAnimation.directions.length) {\n        return 0;\n      }\n      return currentAnimation.directions[this._currentDirection].frames.length;\n    }\n\n    /**\n     * @deprecated\n     * Return true if animation has ended.\n     * Prefer using hasAnimationEnded2. This method returns true as soon as\n     * the animation enters the last frame, not at the end of the last frame.\n     */\n    hasAnimationEnded(): boolean {\n      if (\n        this._currentAnimation >= this._animations.length ||\n        this._currentDirection >=\n          this._animations[this._currentAnimation].directions.length\n      ) {\n        return true;\n      }\n      const direction = this._animations[this._currentAnimation].directions[\n        this._currentDirection\n      ];\n      if (direction.loop) {\n        return false;\n      }\n      return this._currentFrame === direction.frames.length - 1;\n    }\n\n    /**\n     * Return true if animation has ended.\n     * The animation had ended if:\n     * - it's not configured as a loop;\n     * - the current frame is the last frame;\n     * - the last frame has been displayed long enough.\n     */\n    hasAnimationEnded2(): boolean {\n      if (\n        this._currentAnimation >= this._animations.length ||\n        this._currentDirection >=\n          this._animations[this._currentAnimation].directions.length\n      ) {\n        return true;\n      }\n      const direction = this._animations[this._currentAnimation].directions[\n        this._currentDirection\n      ];\n      if (direction.loop) {\n        return false;\n      }\n      return (\n        this._currentFrame === direction.frames.length - 1 &&\n        this._frameElapsedTime > direction.timeBetweenFrames\n      );\n    }\n\n    animationPaused() {\n      return this._animationPaused;\n    }\n\n    pauseAnimation() {\n      this._animationPaused = true;\n    }\n\n    playAnimation() {\n      this._animationPaused = false;\n    }\n\n    getAnimationSpeedScale() {\n      return this._animationSpeedScale;\n    }\n\n    setAnimationSpeedScale(ratio): void {\n      this._animationSpeedScale = ratio;\n    }\n\n    //Position :\n    /**\n     * Get the position on X axis on the scene of the given point.\n     * @param name The point name\n     * @return the position on X axis on the scene of the given point.\n     */\n    getPointX(name: string): float {\n      if (this._animationFrameDirty) {\n        this._updateAnimationFrame();\n      }\n      if (name.length === 0 || this._animationFrame === null) {\n        return this.getX();\n      }\n      const pt = this._animationFrame.getPoint(name);\n      const pos = gdjs.staticArray(SpriteRuntimeObject.prototype.getPointX);\n      this._transformToGlobal(pt.x, pt.y, pos);\n      return pos[0];\n    }\n\n    /**\n     * Get the position on Y axis on the scene of the given point.\n     * @param name The point name\n     * @return the position on Y axis on the scene of the given point.\n     */\n    getPointY(name: string): float {\n      if (this._animationFrameDirty) {\n        this._updateAnimationFrame();\n      }\n      if (name.length === 0 || this._animationFrame === null) {\n        return this.getY();\n      }\n      const pt = this._animationFrame.getPoint(name);\n      const pos = gdjs.staticArray(SpriteRuntimeObject.prototype.getPointY);\n      this._transformToGlobal(pt.x, pt.y, pos);\n      return pos[1];\n    }\n    /**\n     * Get the positions on X and Y axis on the scene of the given point.\n     * @param name The point name\n     * @return An array of the position on X and Y axis on the scene of the given point.\n     */\n    getPointPosition(name: string): [x: float, y: float] {\n      if (this._animationFrameDirty) {\n        this._updateAnimationFrame();\n      }\n      if (name.length === 0 || this._animationFrame === null) {\n        return [this.getX(), this.getY()];\n      }\n      const pt = this._animationFrame.getPoint(name);\n      const pos = gdjs.staticArray(SpriteRuntimeObject.prototype.getPointX);\n      this._transformToGlobal(pt.x, pt.y, pos);\n      return [pos[0], pos[1]];\n    }\n\n    /**\n     * Return an array containing the coordinates of the point passed as parameter\n     * in world coordinates (as opposed to the object local coordinates).\n     *\n     * Beware: this._animationFrame and this._sprite must *not* be null!\n     *\n     * All transformations (flipping, scale, rotation) are supported.\n     *\n     * @param x The X position of the point, in object coordinates.\n     * @param y The Y position of the point, in object coordinates.\n     * @param result Array that will be updated with the result\n     * (x and y position of the point in global coordinates).\n     */\n    private _transformToGlobal(x: float, y: float, result: number[]) {\n      const animationFrame = this._animationFrame as SpriteAnimationFrame;\n      let cx = animationFrame.center.x;\n      let cy = animationFrame.center.y;\n\n      //Flipping\n      if (this._flippedX) {\n        x = x + (cx - x) * 2;\n      }\n      if (this._flippedY) {\n        y = y + (cy - y) * 2;\n      }\n\n      //Scale\n      const absScaleX = Math.abs(this._scaleX);\n      const absScaleY = Math.abs(this._scaleY);\n      x *= absScaleX;\n      y *= absScaleY;\n      cx *= absScaleX;\n      cy *= absScaleY;\n\n      //Rotation\n      const angleInRadians = (this.angle / 180) * Math.PI;\n      const cosValue = Math.cos(\n        // Only compute cos and sin once (10% faster than doing it twice)\n        angleInRadians\n      );\n      const sinValue = Math.sin(angleInRadians);\n      const xToCenterXDelta = x - cx;\n      const yToCenterYDelta = y - cy;\n      x = cx + cosValue * xToCenterXDelta - sinValue * yToCenterYDelta;\n      y = cy + sinValue * xToCenterXDelta + cosValue * yToCenterYDelta;\n      result.length = 2;\n      result[0] = x + (this.x - animationFrame.origin.x * absScaleX);\n      result[1] = y + (this.y - animationFrame.origin.y * absScaleY);\n    }\n\n    /**\n     * Get the X position, on the scene, of the origin of the texture of the object.\n     * @return the X position, on the scene, of the origin of the texture of the object.\n     */\n    getDrawableX(): float {\n      if (this._animationFrameDirty) {\n        this._updateAnimationFrame();\n      }\n      if (this._animationFrame === null) {\n        return this.x;\n      }\n      const absScaleX = Math.abs(this._scaleX);\n      if (!this._flippedX) {\n        return this.x - this._animationFrame.origin.x * absScaleX;\n      } else {\n        return (\n          this.x +\n          (-this._animationFrame.origin.x -\n            this._renderer.getUnscaledWidth() +\n            2 * this._animationFrame.center.x) *\n            absScaleX\n        );\n      }\n    }\n\n    /**\n     * Get the Y position, on the scene, of the origin of the texture of the object.\n     * @return the Y position, on the scene, of the origin of the texture of the object.\n     */\n    getDrawableY(): float {\n      if (this._animationFrameDirty) {\n        this._updateAnimationFrame();\n      }\n      if (this._animationFrame === null) {\n        return this.y;\n      }\n      const absScaleY = Math.abs(this._scaleY);\n      if (!this._flippedY) {\n        return this.y - this._animationFrame.origin.y * absScaleY;\n      } else {\n        return (\n          this.y +\n          (-this._animationFrame.origin.y -\n            this._renderer.getUnscaledHeight() +\n            2 * this._animationFrame.center.y) *\n            absScaleY\n        );\n      }\n    }\n\n    /**\n     * Get the X position of the center of the object, relative to top-left of the texture of the object (`getDrawableX`).\n     * @return X position of the center of the object, relative to `getDrawableX()`.\n     */\n    getCenterX(): float {\n      if (this._animationFrameDirty) {\n        this._updateAnimationFrame();\n      }\n      if (this._animationFrame === null) {\n        return 0;\n      }\n      if (!this._flippedX) {\n        //Just need to multiply by the scale as it is the center.\n        return this._animationFrame.center.x * Math.abs(this._scaleX);\n      } else {\n        return (\n          (this._renderer.getUnscaledWidth() - this._animationFrame.center.x) *\n          Math.abs(this._scaleX)\n        );\n      }\n    }\n\n    /**\n     * Get the Y position of the center of the object, relative to top-left of the texture of the object (`getDrawableY`).\n     * @return Y position of the center of the object, relative to `getDrawableY()`.\n     */\n    getCenterY(): float {\n      if (this._animationFrameDirty) {\n        this._updateAnimationFrame();\n      }\n      if (this._animationFrame === null) {\n        return 0;\n      }\n      if (!this._flippedY) {\n        //Just need to multiply by the scale as it is the center.\n        return this._animationFrame.center.y * Math.abs(this._scaleY);\n      } else {\n        return (\n          (this._renderer.getUnscaledHeight() - this._animationFrame.center.y) *\n          Math.abs(this._scaleY)\n        );\n      }\n    }\n\n    /**\n     * Set the X position of the (origin of the) object.\n     * @param x The new X position.\n     */\n    setX(x: float): void {\n      if (x === this.x) {\n        return;\n      }\n      this.x = x;\n      if (this._animationFrame !== null) {\n        this.invalidateHitboxes();\n        this._renderer.updateX();\n      }\n    }\n\n    /**\n     * Set the Y position of the (origin of the) object.\n     * @param y The new Y position.\n     */\n    setY(y: float): void {\n      if (y === this.y) {\n        return;\n      }\n      this.y = y;\n      if (this._animationFrame !== null) {\n        this.invalidateHitboxes();\n        this._renderer.updateY();\n      }\n    }\n\n    /**\n     * Set the angle of the object.\n     * @param angle The new angle, in degrees.\n     */\n    setAngle(angle: float): void {\n      if (this._currentAnimation >= this._animations.length) {\n        return;\n      }\n      if (!this._animations[this._currentAnimation].hasMultipleDirections) {\n        if (this.angle === angle) {\n          return;\n        }\n        this.angle = angle;\n        this._renderer.updateAngle();\n        this.invalidateHitboxes();\n      } else {\n        angle = angle % 360;\n        if (angle < 0) {\n          angle += 360;\n        }\n        this.setDirectionOrAngle(Math.round(angle / 45) % 8);\n      }\n    }\n\n    /**\n     * Get the angle of the object.\n     * @return The angle, in degrees.\n     */\n    getAngle(): float {\n      if (this._currentAnimation >= this._animations.length) {\n        return 0;\n      }\n      if (!this._animations[this._currentAnimation].hasMultipleDirections) {\n        return this.angle;\n      } else {\n        return this._currentDirection * 45;\n      }\n    }\n\n    //Visibility and display :\n    setBlendMode(newMode): void {\n      if (this._blendMode === newMode) {\n        return;\n      }\n      this._blendMode = newMode;\n      this._renderer.update();\n    }\n\n    getBlendMode() {\n      return this._blendMode;\n    }\n\n    /**\n     * Change the transparency of the object.\n     * @param opacity The new opacity, between 0 (transparent) and 255 (opaque).\n     */\n    setOpacity(opacity: float): void {\n      if (opacity < 0) {\n        opacity = 0;\n      }\n      if (opacity > 255) {\n        opacity = 255;\n      }\n      this.opacity = opacity;\n      this._renderer.updateOpacity();\n    }\n\n    /**\n     * Get the transparency of the object.\n     * @return The opacity, between 0 (transparent) and 255 (opaque).\n     */\n    getOpacity(): number {\n      return this.opacity;\n    }\n\n    /**\n     * Hide (or show) the object\n     * @param enable true to hide the object, false to show it again.\n     */\n    hide(enable: boolean): void {\n      if (enable === undefined) {\n        enable = true;\n      }\n      this.hidden = enable;\n      this._renderer.updateVisibility();\n    }\n\n    /**\n     * Change the tint of the sprite object.\n     *\n     * @param rgbColor The color, in RGB format (\"128;200;255\").\n     */\n    setColor(rgbColor: string): void {\n      this._renderer.setColor(rgbColor);\n    }\n\n    /**\n     * Get the tint of the sprite object.\n     *\n     * @returns The color, in RGB format (\"128;200;255\").\n     */\n    getColor(): string {\n      return this._renderer.getColor();\n    }\n\n    flipX(enable: boolean) {\n      if (enable !== this._flippedX) {\n        this._scaleX *= -1;\n        this._flippedX = enable;\n        this.invalidateHitboxes();\n        this._renderer.update();\n      }\n    }\n\n    flipY(enable: boolean) {\n      if (enable !== this._flippedY) {\n        this._scaleY *= -1;\n        this._flippedY = enable;\n        this.invalidateHitboxes();\n        this._renderer.update();\n      }\n    }\n\n    isFlippedX(): boolean {\n      return this._flippedX;\n    }\n\n    isFlippedY(): boolean {\n      return this._flippedY;\n    }\n\n    //Scale and size :\n    /**\n     * Get the width of the object.\n     *\n     * @return The width of the object, in pixels.\n     */\n    getWidth(): float {\n      if (this._animationFrameDirty) {\n        this._updateAnimationFrame();\n      }\n      return this._renderer.getWidth();\n    }\n\n    /**\n     * Get the height of the object.\n     *\n     * @return The height of the object, in pixels.\n     */\n    getHeight(): float {\n      if (this._animationFrameDirty) {\n        this._updateAnimationFrame();\n      }\n      return this._renderer.getHeight();\n    }\n\n    /**\n     * Change the width of the object. This changes the scale on X axis of the object.\n     *\n     * @param newWidth The new width of the object, in pixels.\n     */\n    setWidth(newWidth: float): void {\n      if (this._animationFrameDirty) {\n        this._updateAnimationFrame();\n      }\n      const unscaledWidth = this._renderer.getUnscaledWidth();\n      if (unscaledWidth !== 0) {\n        this.setScaleX(newWidth / unscaledWidth);\n      }\n    }\n\n    /**\n     * Change the height of the object. This changes the scale on Y axis of the object.\n     *\n     * @param newHeight The new height of the object, in pixels.\n     */\n    setHeight(newHeight: float): void {\n      if (this._animationFrameDirty) {\n        this._updateAnimationFrame();\n      }\n      const unscaledHeight = this._renderer.getUnscaledHeight();\n      if (unscaledHeight !== 0) {\n        this.setScaleY(newHeight / unscaledHeight);\n      }\n    }\n\n    /**\n     * Change the size of the object.\n     *\n     * @param newWidth The new width of the object, in pixels.\n     * @param newHeight The new height of the object, in pixels.\n     */\n    setSize(newWidth: float, newHeight: float): void {\n      this.setWidth(newWidth);\n      this.setHeight(newHeight);\n    }\n\n    /**\n     * Change the scale on X and Y axis of the object.\n     *\n     * @param newScale The new scale (must be greater than 0).\n     */\n    setScale(newScale: number): void {\n      if (newScale < 0) {\n        newScale = 0;\n      }\n      if (\n        newScale === Math.abs(this._scaleX) &&\n        newScale === Math.abs(this._scaleY)\n      ) {\n        return;\n      }\n      this._scaleX = newScale * (this._flippedX ? -1 : 1);\n      this._scaleY = newScale * (this._flippedY ? -1 : 1);\n      this._renderer.update();\n      this.invalidateHitboxes();\n    }\n\n    /**\n     * Change the scale on X axis of the object (changing its width).\n     *\n     * @param newScale The new scale (must be greater than 0).\n     */\n    setScaleX(newScale: number): void {\n      if (newScale < 0) {\n        newScale = 0;\n      }\n      if (newScale === Math.abs(this._scaleX)) {\n        return;\n      }\n      this._scaleX = newScale * (this._flippedX ? -1 : 1);\n      this._renderer.update();\n      this.invalidateHitboxes();\n    }\n\n    /**\n     * Change the scale on Y axis of the object (changing its height).\n     *\n     * @param newScale The new scale (must be greater than 0).\n     */\n    setScaleY(newScale: number): void {\n      if (newScale < 0) {\n        newScale = 0;\n      }\n      if (newScale === Math.abs(this._scaleY)) {\n        return;\n      }\n      this._scaleY = newScale * (this._flippedY ? -1 : 1);\n      this._renderer.update();\n      this.invalidateHitboxes();\n    }\n\n    /**\n     * Get the scale of the object (or the average of the X and Y scale in case they are different).\n     *\n     * @return the scale of the object (or the average of the X and Y scale in case they are different).\n     */\n    getScale(): number {\n      return (Math.abs(this._scaleX) + Math.abs(this._scaleY)) / 2.0;\n    }\n\n    /**\n     * Get the scale of the object on Y axis.\n     *\n     * @return the scale of the object on Y axis\n     */\n    getScaleY(): float {\n      return Math.abs(this._scaleY);\n    }\n\n    /**\n     * Get the scale of the object on X axis.\n     *\n     * @return the scale of the object on X axis\n     */\n    getScaleX(): float {\n      return Math.abs(this._scaleX);\n    }\n\n    //Other :\n    /**\n     * @param obj The target object\n     * @param scene The scene containing the object\n     * @deprecated\n     */\n    turnTowardObject(obj: gdjs.RuntimeObject, scene: gdjs.RuntimeScene) {\n      if (obj === null) {\n        return;\n      }\n      this.rotateTowardPosition(\n        obj.getDrawableX() + obj.getCenterX(),\n        obj.getDrawableY() + obj.getCenterY(),\n        0,\n        scene\n      );\n    }\n  }\n  gdjs.registerObject(\n    'Sprite',\n    //Notify gdjs of the object existence.\n    gdjs.SpriteRuntimeObject\n  );\n\n  //Others initialization and internal state management :\n  SpriteRuntimeObject.supportsReinitialization = true;\n}\n"],
  "mappings": "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",
  "names": []
}
