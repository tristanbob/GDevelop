{
  "version": 3,
  "sources": ["../../../../../../../Extensions/PathfindingBehavior/pathfindingruntimebehavior.ts"],
  "sourcesContent": ["/*\nGDevelop - Pathfinding Behavior Extension\nCopyright (c) 2010-2016 Florian Rival (Florian.Rival@gmail.com)\n */\nnamespace gdjs {\n  const logger = new gdjs.Logger('Pathfinding behavior');\n  /**\n   * PathfindingRuntimeBehavior represents a behavior allowing objects to\n   * follow a path computed to avoid obstacles.\n   */\n  export class PathfindingRuntimeBehavior extends gdjs.RuntimeBehavior {\n    _path: Array<FloatPoint> = [];\n    /** Used by the path simplification algorithm */\n    static _smoothingResultVertices: Array<FloatPoint> = [];\n    /** Used by the path simplification algorithm */\n    static _smoothingWorkingVertices: Array<FloatPoint> = [];\n\n    //Behavior configuration:\n    _allowDiagonals: boolean;\n    _acceleration: float;\n    _maxSpeed: float;\n    _angularMaxSpeed: float;\n    _rotateObject: boolean;\n    _angleOffset: float;\n    _cellWidth: float;\n    _cellHeight: float;\n    _gridOffsetX: float;\n    _gridOffsetY: float;\n    _extraBorder: float;\n    _smoothingMaxCellGap: float;\n\n    //Attributes used for traveling on the path:\n    _pathFound: boolean = false;\n    _speed: float = 0;\n    _angularSpeed: float = 0;\n    _distanceOnSegment: float = 0;\n    _totalSegmentDistance: float = 0;\n    _currentSegment: integer = 0;\n    _reachedEnd: boolean = false;\n    _manager: PathfindingObstaclesManager;\n    _searchContext: PathfindingRuntimeBehavior.SearchContext;\n\n    _movementAngle: float = 0;\n\n    constructor(\n      instanceContainer: gdjs.RuntimeInstanceContainer,\n      behaviorData,\n      owner: gdjs.RuntimeObject\n    ) {\n      super(instanceContainer, behaviorData, owner);\n\n      //The path computed and followed by the object (Array of arrays containing x and y position)\n      if (this._path === undefined) {\n      } else {\n        this._path.length = 0;\n      }\n      this._allowDiagonals = behaviorData.allowDiagonals;\n      this._acceleration = behaviorData.acceleration;\n      this._maxSpeed = behaviorData.maxSpeed;\n      this._angularMaxSpeed = behaviorData.angularMaxSpeed;\n      this._rotateObject = behaviorData.rotateObject;\n      this._angleOffset = behaviorData.angleOffset;\n      this._cellWidth = behaviorData.cellWidth;\n      this._cellHeight = behaviorData.cellHeight;\n      this._gridOffsetX = behaviorData.gridOffsetX || 0;\n      this._gridOffsetY = behaviorData.gridOffsetY || 0;\n      this._extraBorder = behaviorData.extraBorder;\n      this._smoothingMaxCellGap = behaviorData.smoothingMaxCellGap || 0;\n      this._manager = gdjs.PathfindingObstaclesManager.getManager(\n        instanceContainer\n      );\n      this._searchContext = new gdjs.PathfindingRuntimeBehavior.SearchContext(\n        this._manager\n      );\n    }\n\n    updateFromBehaviorData(oldBehaviorData, newBehaviorData): boolean {\n      if (oldBehaviorData.allowDiagonals !== newBehaviorData.allowDiagonals) {\n        this.allowDiagonals(newBehaviorData.allowDiagonals);\n      }\n      if (oldBehaviorData.acceleration !== newBehaviorData.acceleration) {\n        this.setAcceleration(newBehaviorData.acceleration);\n      }\n      if (oldBehaviorData.maxSpeed !== newBehaviorData.maxSpeed) {\n        this.setMaxSpeed(newBehaviorData.maxSpeed);\n      }\n      if (oldBehaviorData.angularMaxSpeed !== newBehaviorData.angularMaxSpeed) {\n        this.setAngularMaxSpeed(newBehaviorData.angularMaxSpeed);\n      }\n      if (oldBehaviorData.rotateObject !== newBehaviorData.rotateObject) {\n        this.setRotateObject(newBehaviorData.rotateObject);\n      }\n      if (oldBehaviorData.angleOffset !== newBehaviorData.angleOffset) {\n        this.setAngleOffset(newBehaviorData.angleOffset);\n      }\n      if (oldBehaviorData.cellWidth !== newBehaviorData.cellWidth) {\n        this.setCellWidth(newBehaviorData.cellWidth);\n      }\n      if (oldBehaviorData.cellHeight !== newBehaviorData.cellHeight) {\n        this.setCellHeight(newBehaviorData.cellHeight);\n      }\n      if (oldBehaviorData.gridOffsetX !== newBehaviorData.gridOffsetX) {\n        this._gridOffsetX = newBehaviorData.gridOffsetX;\n      }\n      if (oldBehaviorData.gridOffsetY !== newBehaviorData.gridOffsetY) {\n        this._gridOffsetY = newBehaviorData.gridOffsetY;\n      }\n      if (oldBehaviorData.extraBorder !== newBehaviorData.extraBorder) {\n        this.setExtraBorder(newBehaviorData.extraBorder);\n      }\n      if (\n        oldBehaviorData.smoothingMaxCellGap !==\n        newBehaviorData.smoothingMaxCellGap\n      ) {\n        this._smoothingMaxCellGap = newBehaviorData.smoothingMaxCellGap;\n      }\n      return true;\n    }\n\n    setCellWidth(width: float): void {\n      this._cellWidth = width;\n    }\n\n    getCellWidth(): float {\n      return this._cellWidth;\n    }\n\n    setCellHeight(height: float): void {\n      this._cellHeight = height;\n    }\n\n    getCellHeight(): float {\n      return this._cellHeight;\n    }\n\n    setGridOffsetX(gridOffsetX: float): void {\n      this._gridOffsetX = gridOffsetX;\n    }\n\n    getGridOffsetX(): float {\n      return this._gridOffsetX;\n    }\n\n    setGridOffsetY(gridOffsetY: float): void {\n      this._gridOffsetY = gridOffsetY;\n    }\n\n    getGridOffsetY(): float {\n      return this._gridOffsetY;\n    }\n\n    setAcceleration(acceleration: float): void {\n      this._acceleration = acceleration;\n    }\n\n    getAcceleration() {\n      return this._acceleration;\n    }\n\n    setMaxSpeed(maxSpeed: float): void {\n      this._maxSpeed = maxSpeed;\n    }\n\n    getMaxSpeed() {\n      return this._maxSpeed;\n    }\n\n    setSpeed(speed: float): void {\n      this._speed = speed;\n    }\n\n    getSpeed() {\n      return this._speed;\n    }\n\n    getMovementAngle() {\n      return this._movementAngle;\n    }\n\n    movementAngleIsAround(degreeAngle: float, tolerance: float) {\n      return (\n        Math.abs(\n          gdjs.evtTools.common.angleDifference(this._movementAngle, degreeAngle)\n        ) <= tolerance\n      );\n    }\n\n    setAngularMaxSpeed(angularMaxSpeed: float): void {\n      this._angularMaxSpeed = angularMaxSpeed;\n    }\n\n    getAngularMaxSpeed() {\n      return this._angularMaxSpeed;\n    }\n\n    setAngleOffset(angleOffset: float): void {\n      this._angleOffset = angleOffset;\n    }\n\n    getAngleOffset() {\n      return this._angleOffset;\n    }\n\n    setExtraBorder(extraBorder): void {\n      this._extraBorder = extraBorder;\n    }\n\n    getExtraBorder() {\n      return this._extraBorder;\n    }\n\n    allowDiagonals(allow: boolean) {\n      this._allowDiagonals = allow;\n    }\n\n    diagonalsAllowed() {\n      return this._allowDiagonals;\n    }\n\n    setRotateObject(allow: boolean): void {\n      this._rotateObject = allow;\n    }\n\n    isObjectRotated(): boolean {\n      return this._rotateObject;\n    }\n\n    getNodeX(index: integer): float {\n      if (index < this._path.length) {\n        return this._path[index][0];\n      }\n      return 0;\n    }\n\n    getNodeY(index: integer): float {\n      if (index < this._path.length) {\n        return this._path[index][1];\n      }\n      return 0;\n    }\n\n    getNextNodeIndex() {\n      if (this._currentSegment + 1 < this._path.length) {\n        return this._currentSegment + 1;\n      } else {\n        return this._path.length - 1;\n      }\n    }\n\n    getNodeCount(): integer {\n      return this._path.length;\n    }\n\n    getNextNodeX(): float {\n      if (this._path.length === 0) {\n        return 0;\n      }\n      if (this._currentSegment + 1 < this._path.length) {\n        return this._path[this._currentSegment + 1][0];\n      } else {\n        return this._path[this._path.length - 1][0];\n      }\n    }\n\n    getNextNodeY(): float {\n      if (this._path.length === 0) {\n        return 0;\n      }\n      if (this._currentSegment + 1 < this._path.length) {\n        return this._path[this._currentSegment + 1][1];\n      } else {\n        return this._path[this._path.length - 1][1];\n      }\n    }\n\n    getLastNodeX(): float {\n      if (this._path.length < 2) {\n        return 0;\n      }\n      if (this._currentSegment < this._path.length - 1) {\n        return this._path[this._currentSegment][0];\n      } else {\n        return this._path[this._path.length - 1][0];\n      }\n    }\n\n    getLastNodeY(): float {\n      if (this._path.length < 2) {\n        return 0;\n      }\n      if (this._currentSegment < this._path.length - 1) {\n        return this._path[this._currentSegment][1];\n      } else {\n        return this._path[this._path.length - 1][1];\n      }\n    }\n\n    getDestinationX(): float {\n      if (this._path.length === 0) {\n        return 0;\n      }\n      return this._path[this._path.length - 1][0];\n    }\n\n    getDestinationY(): float {\n      if (this._path.length === 0) {\n        return 0;\n      }\n      return this._path[this._path.length - 1][1];\n    }\n\n    /**\n     * Return true if the latest call to moveTo succeeded.\n     */\n    pathFound() {\n      return this._pathFound;\n    }\n\n    /**\n     * Return true if the object reached its destination.\n     */\n    destinationReached() {\n      return this._reachedEnd;\n    }\n\n    /**\n     * Compute and move on the path to the specified destination.\n     */\n    moveTo(\n      instanceContainer: gdjs.RuntimeInstanceContainer,\n      x: float,\n      y: float\n    ) {\n      const owner = this.owner;\n\n      //First be sure that there is a path to compute.\n      const targetCellX = Math.round((x - this._gridOffsetX) / this._cellWidth);\n      const targetCellY = Math.round(\n        (y - this._gridOffsetY) / this._cellHeight\n      );\n      const startCellX = Math.round(\n        (owner.getX() - this._gridOffsetX) / this._cellWidth\n      );\n      const startCellY = Math.round(\n        (owner.getY() - this._gridOffsetY) / this._cellHeight\n      );\n      if (startCellX == targetCellX && startCellY == targetCellY) {\n        this._path.length = 0;\n        this._path.push([owner.getX(), owner.getY()]);\n        this._path.push([x, y]);\n        this._enterSegment(0);\n        this._pathFound = true;\n        return;\n      }\n\n      //Start searching for a path\n      this._searchContext.allowDiagonals(this._allowDiagonals);\n      this._searchContext.setObstacles(this._manager);\n      this._searchContext.setCellSize(this._cellWidth, this._cellHeight);\n      this._searchContext.setGridOffset(this._gridOffsetX, this._gridOffsetY);\n      this._searchContext.setStartPosition(owner.getX(), owner.getY());\n      this._searchContext.setObjectSize(\n        owner.getX() - owner.getDrawableX() + this._extraBorder,\n        owner.getY() - owner.getDrawableY() + this._extraBorder,\n        owner.getWidth() -\n          (owner.getX() - owner.getDrawableX()) +\n          this._extraBorder,\n        owner.getHeight() -\n          (owner.getY() - owner.getDrawableY()) +\n          this._extraBorder\n      );\n      if (this._searchContext.computePathTo(x, y)) {\n        //Path found: memorize it\n        let node = this._searchContext.getFinalNode();\n        let finalPathLength = 0;\n        while (node) {\n          if (finalPathLength === this._path.length) {\n            this._path.push([0, 0]);\n          }\n          this._path[finalPathLength][0] =\n            node.pos[0] * this._cellWidth + this._gridOffsetX;\n          this._path[finalPathLength][1] =\n            node.pos[1] * this._cellHeight + this._gridOffsetY;\n          node = node.parent;\n          finalPathLength++;\n        }\n        this._path.length = finalPathLength;\n        this._path.reverse();\n        this._path[0][0] = owner.getX();\n        this._path[0][1] = owner.getY();\n\n        if (this._allowDiagonals && this._smoothingMaxCellGap > 0) {\n          gdjs.pathfinding.simplifyPath(\n            this._path,\n            this._smoothingMaxCellGap *\n              Math.min(this._cellWidth, this._cellHeight),\n            gdjs.PathfindingRuntimeBehavior._smoothingResultVertices,\n            gdjs.PathfindingRuntimeBehavior._smoothingWorkingVertices\n          );\n          let swapArray = this._path;\n          this._path = gdjs.PathfindingRuntimeBehavior._smoothingResultVertices;\n          gdjs.PathfindingRuntimeBehavior._smoothingResultVertices = swapArray;\n        }\n\n        this._enterSegment(0);\n        this._pathFound = true;\n        return;\n      }\n\n      //Not path found\n      this._pathFound = false;\n    }\n\n    _enterSegment(segmentNumber: integer) {\n      if (this._path.length === 0) {\n        return;\n      }\n      this._currentSegment = segmentNumber;\n      if (this._currentSegment < this._path.length - 1) {\n        const pathX =\n          this._path[this._currentSegment + 1][0] -\n          this._path[this._currentSegment][0];\n        const pathY =\n          this._path[this._currentSegment + 1][1] -\n          this._path[this._currentSegment][1];\n        this._totalSegmentDistance = Math.sqrt(pathX * pathX + pathY * pathY);\n        this._distanceOnSegment = 0;\n        this._reachedEnd = false;\n        this._movementAngle =\n          (gdjs.toDegrees(Math.atan2(pathY, pathX)) + 360) % 360;\n      } else {\n        this._reachedEnd = true;\n        this._speed = 0;\n      }\n    }\n\n    doStepPreEvents(instanceContainer: gdjs.RuntimeInstanceContainer) {\n      if (this._path.length === 0 || this._reachedEnd) {\n        return;\n      }\n\n      // Update the speed of the object\n      const timeDelta = this.owner.getElapsedTime() / 1000;\n      const previousSpeed = this._speed;\n      if (this._speed !== this._maxSpeed) {\n        this._speed += this._acceleration * timeDelta;\n        if (this._speed > this._maxSpeed) {\n          this._speed = this._maxSpeed;\n        }\n      }\n      this._angularSpeed = this._angularMaxSpeed;\n\n      // Update the time on the segment and change segment if needed\n      // Use a Verlet integration to be frame rate independent.\n      this._distanceOnSegment +=\n        ((this._speed + previousSpeed) / 2) * timeDelta;\n      const remainingDistanceOnSegment =\n        this._totalSegmentDistance - this._distanceOnSegment;\n      if (\n        remainingDistanceOnSegment <= 0 &&\n        this._currentSegment < this._path.length\n      ) {\n        this._enterSegment(this._currentSegment + 1);\n        this._distanceOnSegment = -remainingDistanceOnSegment;\n      }\n\n      // Position object on the segment and update its angle\n      let newPos = [0, 0];\n      if (this._currentSegment < this._path.length - 1) {\n        newPos[0] = gdjs.evtTools.common.lerp(\n          this._path[this._currentSegment][0],\n          this._path[this._currentSegment + 1][0],\n          this._distanceOnSegment / this._totalSegmentDistance\n        );\n        newPos[1] = gdjs.evtTools.common.lerp(\n          this._path[this._currentSegment][1],\n          this._path[this._currentSegment + 1][1],\n          this._distanceOnSegment / this._totalSegmentDistance\n        );\n        if (\n          this._rotateObject &&\n          this.owner.getAngle() !== this._movementAngle + this._angleOffset\n        ) {\n          this.owner.rotateTowardAngle(\n            this._movementAngle + this._angleOffset,\n            this._angularSpeed\n          );\n        }\n      } else {\n        newPos = this._path[this._path.length - 1];\n      }\n      this.owner.setX(newPos[0]);\n      this.owner.setY(newPos[1]);\n    }\n\n    doStepPostEvents(instanceContainer: gdjs.RuntimeInstanceContainer) {}\n\n    /**\n     * Compute the euclidean distance between two positions.\n     * @memberof gdjs.PathfindingRuntimeBehavior\n     */\n    static euclideanDistance(a: FloatPoint, b: FloatPoint) {\n      return Math.sqrt(\n        (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])\n      );\n    }\n\n    /**\n     * Compute the taxi distance between two positions.\n     * @memberof gdjs.PathfindingRuntimeBehavior\n     */\n    static manhattanDistance(a: FloatPoint, b: FloatPoint) {\n      return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);\n    }\n  }\n  gdjs.registerBehavior(\n    'PathfindingBehavior::PathfindingBehavior',\n    gdjs.PathfindingRuntimeBehavior\n  );\n\n  export namespace PathfindingRuntimeBehavior {\n    /**\n     * Internal tool class representing a node when looking for a path\n     */\n    export class Node {\n      pos: FloatPoint;\n      cost: integer = 0;\n      smallestCost: integer = -1;\n      estimateCost: integer = -1;\n      parent: Node | null = null;\n      open: boolean = true;\n\n      constructor(xPos: integer, yPos: integer) {\n        this.pos = [xPos, yPos];\n      }\n\n      reinitialize(xPos: integer, yPos: integer) {\n        this.pos[0] = xPos;\n        this.pos[1] = yPos;\n        this.cost = 0;\n        this.smallestCost = -1;\n        this.estimateCost = -1;\n        this.parent = null;\n        this.open = true;\n      }\n    }\n\n    /**\n     * Internal tool class containing the structures used by A* and members functions related\n     * to them.\n     * @ignore\n     */\n    export class SearchContext {\n      _obstacles: PathfindingObstaclesManager;\n      _finalNode: Node | null = null;\n      _destination: FloatPoint = [0, 0];\n      _start: FloatPoint = [0, 0];\n      _startX: float = 0;\n      _startY: float = 0;\n      _allowDiagonals: boolean = true;\n      _maxComplexityFactor: integer = 50;\n      _cellWidth: float = 20;\n      _cellHeight: float = 20;\n      _gridOffsetX: float = 0;\n      _gridOffsetY: float = 0;\n\n      _leftBorder: integer = 0;\n      _rightBorder: integer = 0;\n      _topBorder: integer = 0;\n      _bottomBorder: integer = 0;\n      _distanceFunction: (pt1: FloatPoint, pt2: FloatPoint) => float;\n      //An array of array. Nodes are indexed by their x position, and then by their y position.\n      _allNodes: Node[][] = [];\n      //An array of nodes sorted by their estimate cost (First node = Lower estimate cost).\n      _openNodes: Node[] = [];\n      //Used by getNodes to temporarily store obstacles near a position.\n      _closeObstacles: gdjs.PathfindingObstacleRuntimeBehavior[] = [];\n      //Old nodes constructed in a previous search are stored here to avoid temporary objects (see _freeAllNodes method).\n      _nodeCache: Node[] = [];\n\n      constructor(obstacles: PathfindingObstaclesManager) {\n        this._obstacles = obstacles;\n        this._distanceFunction = PathfindingRuntimeBehavior.euclideanDistance;\n      }\n\n      setObstacles(\n        obstacles: PathfindingObstaclesManager\n      ): PathfindingRuntimeBehavior.SearchContext {\n        this._obstacles = obstacles;\n        return this;\n      }\n\n      getFinalNode() {\n        return this._finalNode;\n      }\n\n      allowDiagonals(allowDiagonals: boolean) {\n        this._allowDiagonals = allowDiagonals;\n        this._distanceFunction = allowDiagonals\n          ? PathfindingRuntimeBehavior.euclideanDistance\n          : PathfindingRuntimeBehavior.manhattanDistance;\n        return this;\n      }\n\n      setStartPosition(\n        x: float,\n        y: float\n      ): PathfindingRuntimeBehavior.SearchContext {\n        this._startX = x;\n        this._startY = y;\n        return this;\n      }\n\n      setObjectSize(\n        leftBorder: integer,\n        topBorder: integer,\n        rightBorder: integer,\n        bottomBorder: integer\n      ): PathfindingRuntimeBehavior.SearchContext {\n        this._leftBorder = leftBorder;\n        this._rightBorder = rightBorder;\n        this._topBorder = topBorder;\n        this._bottomBorder = bottomBorder;\n        return this;\n      }\n\n      setCellSize(\n        cellWidth: float,\n        cellHeight: float\n      ): PathfindingRuntimeBehavior.SearchContext {\n        this._cellWidth = cellWidth;\n        this._cellHeight = cellHeight;\n        return this;\n      }\n\n      setGridOffset(\n        gridOffsetX: float,\n        gridOffsetY: float\n      ): PathfindingRuntimeBehavior.SearchContext {\n        this._gridOffsetX = gridOffsetX;\n        this._gridOffsetY = gridOffsetY;\n        return this;\n      }\n\n      computePathTo(targetX: float, targetY: float) {\n        if (this._obstacles === null) {\n          logger.log(\n            'You tried to compute a path without specifying the obstacles'\n          );\n          return;\n        }\n        this._destination[0] = Math.round(\n          (targetX - this._gridOffsetX) / this._cellWidth\n        );\n        this._destination[1] = Math.round(\n          (targetY - this._gridOffsetY) / this._cellHeight\n        );\n        this._start[0] = Math.round(\n          (this._startX - this._gridOffsetX) / this._cellWidth\n        );\n        this._start[1] = Math.round(\n          (this._startY - this._gridOffsetY) / this._cellHeight\n        );\n\n        //Initialize the algorithm\n        this._freeAllNodes();\n        const startNode = this._getNode(this._start[0], this._start[1]);\n        startNode.smallestCost = 0;\n        startNode.estimateCost =\n          0 + this._distanceFunction(this._start, this._destination);\n        this._openNodes.length = 0;\n        this._openNodes.push(startNode);\n\n        //A* algorithm main loop\n        let iterationCount = 0;\n        const maxIterationCount =\n          startNode.estimateCost * this._maxComplexityFactor;\n        while (this._openNodes.length !== 0) {\n          //Make sure we do not search forever.\n          if (iterationCount++ > maxIterationCount) {\n            console.warn(\n              `No path was found after covering ${maxIterationCount} cells.`\n            );\n            return false;\n          }\n\n          //Get the most promising node...\n          const n = this._openNodes.shift()!;\n          //...and flag it as explored\n          n.open = false;\n\n          //Check if we reached destination?\n          if (\n            n.pos[0] == this._destination[0] &&\n            n.pos[1] == this._destination[1]\n          ) {\n            this._finalNode = n;\n            return true;\n          }\n\n          //No, so add neighbors to the nodes to explore.\n          this._insertNeighbors(n);\n        }\n        return false;\n      }\n\n      _freeAllNodes() {\n        if (this._nodeCache.length <= 32000) {\n          for (const i in this._allNodes) {\n            if (this._allNodes.hasOwnProperty(i)) {\n              const nodeArray = this._allNodes[i];\n              for (const j in nodeArray) {\n                if (nodeArray.hasOwnProperty(j)) {\n                  this._nodeCache.push(nodeArray[j]);\n                }\n              }\n            }\n          }\n        }\n        this._allNodes = [];\n      }\n\n      /**\n       * Insert the neighbors of the current node in the open list\n       * (Only if they are not closed, and if the cost is better than the already existing smallest cost).\n       */\n      _insertNeighbors(currentNode: Node) {\n        this._addOrUpdateNode(\n          currentNode.pos[0] + 1,\n          currentNode.pos[1],\n          currentNode,\n          1\n        );\n        this._addOrUpdateNode(\n          currentNode.pos[0] - 1,\n          currentNode.pos[1],\n          currentNode,\n          1\n        );\n        this._addOrUpdateNode(\n          currentNode.pos[0],\n          currentNode.pos[1] + 1,\n          currentNode,\n          1\n        );\n        this._addOrUpdateNode(\n          currentNode.pos[0],\n          currentNode.pos[1] - 1,\n          currentNode,\n          1\n        );\n        if (this._allowDiagonals) {\n          this._addOrUpdateNode(\n            currentNode.pos[0] + 1,\n            currentNode.pos[1] + 1,\n            currentNode,\n            1.414213562\n          );\n          this._addOrUpdateNode(\n            currentNode.pos[0] + 1,\n            currentNode.pos[1] - 1,\n            currentNode,\n            1.414213562\n          );\n          this._addOrUpdateNode(\n            currentNode.pos[0] - 1,\n            currentNode.pos[1] - 1,\n            currentNode,\n            1.414213562\n          );\n          this._addOrUpdateNode(\n            currentNode.pos[0] - 1,\n            currentNode.pos[1] + 1,\n            currentNode,\n            1.414213562\n          );\n        }\n      }\n\n      /**\n       * Get (or dynamically construct) a node.\n       *\n       * *All* nodes should be created using this method: The cost of the node is computed thanks\n       * to the objects flagged as obstacles.\n       */\n      _getNode(xPos: integer, yPos: integer): Node {\n        //First check if their is a node a the specified position.\n        if (this._allNodes.hasOwnProperty(xPos)) {\n          if (this._allNodes[xPos].hasOwnProperty(yPos)) {\n            return this._allNodes[xPos][yPos];\n          }\n        } else {\n          this._allNodes[xPos] = [];\n        }\n\n        //No so construct a new node (or get it from the cache)...\n        let newNode: Node;\n        if (this._nodeCache.length !== 0) {\n          newNode = this._nodeCache.shift()!;\n          newNode.reinitialize(xPos, yPos);\n        } else {\n          newNode = new Node(xPos, yPos);\n        }\n\n        const nodeCenterX = xPos * this._cellWidth + this._gridOffsetX;\n        const nodeCenterY = yPos * this._cellHeight + this._gridOffsetY;\n\n        //...and update its cost according to obstacles\n        let objectsOnCell = false;\n        const radius =\n          this._cellHeight > this._cellWidth\n            ? this._cellHeight * 2\n            : this._cellWidth * 2;\n        this._obstacles.getAllObstaclesAround(\n          nodeCenterX,\n          nodeCenterY,\n          radius,\n          this._closeObstacles\n        );\n        for (let k = 0; k < this._closeObstacles.length; ++k) {\n          const obj = this._closeObstacles[k].owner;\n          const topLeftCellX = Math.floor(\n            (obj.getDrawableX() - this._rightBorder - this._gridOffsetX) /\n              this._cellWidth\n          );\n          const topLeftCellY = Math.floor(\n            (obj.getDrawableY() - this._bottomBorder - this._gridOffsetY) /\n              this._cellHeight\n          );\n          const bottomRightCellX = Math.ceil(\n            (obj.getDrawableX() +\n              obj.getWidth() +\n              this._leftBorder -\n              this._gridOffsetX) /\n              this._cellWidth\n          );\n          const bottomRightCellY = Math.ceil(\n            (obj.getDrawableY() +\n              obj.getHeight() +\n              this._topBorder -\n              this._gridOffsetY) /\n              this._cellHeight\n          );\n          if (\n            topLeftCellX < xPos &&\n            xPos < bottomRightCellX &&\n            topLeftCellY < yPos &&\n            yPos < bottomRightCellY\n          ) {\n            objectsOnCell = true;\n            if (this._closeObstacles[k].isImpassable()) {\n              //The cell is impassable, stop here.\n              newNode.cost = -1;\n              break;\n            } else {\n              //Superimpose obstacles\n              newNode.cost += this._closeObstacles[k].getCost();\n            }\n          }\n        }\n        if (!objectsOnCell) {\n          newNode.cost = 1;\n        }\n\n        //Default cost when no objects put on the cell.\n        this._allNodes[xPos][yPos] = newNode;\n        return newNode;\n      }\n\n      /**\n       * Add a node to the openNodes (only if the cost to reach it is less than the existing cost, if any).\n       */\n      _addOrUpdateNode(\n        newNodeX: integer,\n        newNodeY: integer,\n        currentNode: Node,\n        factor: float\n      ) {\n        const neighbor = this._getNode(newNodeX, newNodeY);\n\n        //cost < 0 means impassable obstacle\n        if (!neighbor.open || neighbor.cost < 0) {\n          return;\n        }\n\n        //Update the node costs and parent if the path coming from currentNode is better:\n        if (\n          neighbor.smallestCost === -1 ||\n          neighbor.smallestCost >\n            currentNode.smallestCost +\n              ((currentNode.cost + neighbor.cost) / 2.0) * factor\n        ) {\n          if (neighbor.smallestCost != -1) {\n            //The node is already in the open list..\n            for (let i = 0; i < this._openNodes.length; ++i) {\n              if (\n                this._openNodes[i].pos[0] == neighbor.pos[0] &&\n                this._openNodes[i].pos[1] == neighbor.pos[1]\n              ) {\n                this._openNodes.splice(\n                  i,\n                  //..so remove it as its estimate cost will be updated.\n                  1\n                );\n                break;\n              }\n            }\n          }\n          neighbor.smallestCost =\n            currentNode.smallestCost +\n            ((currentNode.cost + neighbor.cost) / 2.0) * factor;\n          neighbor.parent = currentNode;\n          neighbor.estimateCost =\n            neighbor.smallestCost +\n            this._distanceFunction(neighbor.pos, this._destination);\n\n          //Add the neighbor to open nodes, which are sorted by their estimate cost:\n          if (\n            this._openNodes.length === 0 ||\n            this._openNodes[this._openNodes.length - 1].estimateCost <\n              neighbor.estimateCost\n          ) {\n            this._openNodes.push(neighbor);\n          } else {\n            for (let i = 0; i < this._openNodes.length; ++i) {\n              if (this._openNodes[i].estimateCost >= neighbor.estimateCost) {\n                this._openNodes.splice(i, 0, neighbor);\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
