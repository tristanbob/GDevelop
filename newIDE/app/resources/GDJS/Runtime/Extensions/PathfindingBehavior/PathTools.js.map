{
  "version": 3,
  "sources": ["../../../../../../../Extensions/PathfindingBehavior/PathTools.ts"],
  "sourcesContent": ["namespace gdjs {\n  export namespace pathfinding {\n    /**\n     * Simplify a path according to an allowed gap.\n     *\n     * The simplified path vertices are the same instances as the one in\n     * the source. They must be cloned to make them truly independent from each\n     * other.\n     *\n     * @param sourceVertices The path to simplify.\n     * @param maxGap The maximum distance the edge of the contour may deviate\n     * from the source geometry.\n     * @param simplifiedVertices The simplified path.\n     * @param workingVertices It avoids allocations.\n     */\n    export const simplifyPath = (\n      sourceVertices: FloatPoint[],\n      maxGap: float,\n      simplifiedVertices: FloatPoint[] = [],\n      workingVertices: FloatPoint[] = []\n    ): FloatPoint[] => {\n      if (sourceVertices.length <= 2) {\n        simplifiedVertices.length = 0;\n        simplifiedVertices.push.apply(simplifiedVertices, sourceVertices);\n        return simplifiedVertices;\n      }\n      const maxGapSq = maxGap * maxGap;\n\n      // We start with only one rope part.\n      // Stretch a rope between the start and the end of the path.\n      let previousStepVertices: FloatPoint[] = workingVertices;\n      previousStepVertices.length = 0;\n      previousStepVertices.push(sourceVertices[0]);\n      previousStepVertices.push(sourceVertices[sourceVertices.length - 1]);\n\n      do {\n        simplifiedVertices.length = 0;\n        simplifiedVertices.push(previousStepVertices[0]);\n\n        // For each part of the rope...\n        let sourceIndex = 0;\n        for (\n          let previousStepVerticesIndex = 0;\n          previousStepVerticesIndex + 1 < previousStepVertices.length;\n          previousStepVerticesIndex++\n        ) {\n          const startVertex = previousStepVertices[previousStepVerticesIndex];\n          const endVertex = previousStepVertices[previousStepVerticesIndex + 1];\n\n          const startX = startVertex[0];\n          const startY = startVertex[1];\n          const endX = endVertex[0];\n          const endY = endVertex[1];\n\n          // Search the furthest vertex from the rope part.\n          let maxDeviationSq = maxGapSq;\n          let maxDeviationVertex: FloatPoint | null = null;\n          // The first and last vertices of the rope part are not checked.\n          for (\n            sourceIndex++;\n            sourceVertices[sourceIndex] !== endVertex;\n            sourceIndex++\n          ) {\n            const sourceVertex = sourceVertices[sourceIndex];\n\n            const deviationSq = gdjs.pathfinding.getPointSegmentDistanceSq(\n              sourceVertex[0],\n              sourceVertex[1],\n              startX,\n              startY,\n              endX,\n              endY\n            );\n            if (deviationSq > maxDeviationSq) {\n              maxDeviationSq = deviationSq;\n              maxDeviationVertex = sourceVertex;\n            }\n          }\n          // Add the furthest vertex to the rope.\n          // The current rope part is split in 2 for the next step.\n          if (maxDeviationVertex) {\n            simplifiedVertices.push(maxDeviationVertex);\n          }\n          simplifiedVertices.push(endVertex);\n        }\n\n        const swapVertices = previousStepVertices;\n        previousStepVertices = simplifiedVertices;\n        simplifiedVertices = swapVertices;\n      } while (\n        // Stop when no new vertex were added.\n        // It means that the maxGap constraint is fulfilled.\n        // Otherwise, iterate over the full path once more.\n        simplifiedVertices.length !== previousStepVertices.length\n      );\n      return simplifiedVertices;\n    };\n\n    /**\n     * Returns the distance squared from the point to the line segment.\n     *\n     * Behavior is undefined if the the closest distance is outside the\n     * line segment.\n     *\n     * @param px The X position of point (px, py).\n     * @param py The Y position of point (px, py)\n     * @param ax The X position of the line segment's vertex A.\n     * @param ay The Y position of the line segment's vertex A.\n     * @param bx The X position of the line segment's vertex B.\n     * @param by The Y position of the line segment's vertex B.\n     * @return The distance squared from the point (px, py) to line segment AB.\n     */\n    export const getPointSegmentDistanceSq = (\n      px: float,\n      py: float,\n      ax: float,\n      ay: float,\n      bx: float,\n      by: float\n    ): float => {\n      // This implementation is strongly inspired from CritterAI class \"Geometry\".\n      //\n      // Reference: http://local.wasp.uwa.edu.au/~pbourke/geometry/pointline/\n      //\n      // The goal of the algorithm is to find the point on line segment AB\n      // that is closest to P and then calculate the distance between P\n      // and that point.\n\n      const deltaABx = bx - ax;\n      const deltaABy = by - ay;\n      const deltaAPx = px - ax;\n      const deltaAPy = py - ay;\n\n      const segmentABLengthSq = deltaABx * deltaABx + deltaABy * deltaABy;\n      if (segmentABLengthSq === 0) {\n        // AB is not a line segment. So just return\n        // distanceSq from P to A\n        return deltaAPx * deltaAPx + deltaAPy * deltaAPy;\n      }\n\n      const u = (deltaAPx * deltaABx + deltaAPy * deltaABy) / segmentABLengthSq;\n      if (u < 0) {\n        // Closest point on line AB is outside outside segment AB and\n        // closer to A. So return distanceSq from P to A.\n        return deltaAPx * deltaAPx + deltaAPy * deltaAPy;\n      } else if (u > 1) {\n        // Closest point on line AB is outside segment AB and closer to B.\n        // So return distanceSq from P to B.\n        return (px - bx) * (px - bx) + (py - by) * (py - by);\n      }\n\n      // Closest point on lineAB is inside segment AB. So find the exact\n      // point on AB and calculate the distanceSq from it to P.\n\n      // The calculation in parenthesis is the location of the point on\n      // the line segment.\n      const deltaX = ax + u * deltaABx - px;\n      const deltaY = ay + u * deltaABy - py;\n\n      return deltaX * deltaX + deltaY * deltaY;\n    };\n  }\n}\n"],
  "mappings": "AAAA,GAAU,MAAV,UAAU,EAAV,CACS,GAAU,GAAV,UAAU,EAAV,CAcE,AAAM,eAAe,CAC1B,EACA,EACA,EAAmC,GACnC,EAAgC,KACf,CACjB,GAAI,EAAe,QAAU,EAC3B,SAAmB,OAAS,EAC5B,EAAmB,KAAK,MAAM,EAAoB,GAC3C,EAET,KAAM,GAAW,EAAS,EAI1B,GAAI,GAAqC,EACzC,EAAqB,OAAS,EAC9B,EAAqB,KAAK,EAAe,IACzC,EAAqB,KAAK,EAAe,EAAe,OAAS,IAEjE,EAAG,CACD,EAAmB,OAAS,EAC5B,EAAmB,KAAK,EAAqB,IAG7C,GAAI,GAAc,EAClB,OACM,GAA4B,EAChC,EAA4B,EAAI,EAAqB,OACrD,IACA,CACA,KAAM,GAAc,EAAqB,GACnC,EAAY,EAAqB,EAA4B,GAE7D,EAAS,EAAY,GACrB,EAAS,EAAY,GACrB,EAAO,EAAU,GACjB,EAAO,EAAU,GAGvB,GAAI,GAAiB,EACjB,EAAwC,KAE5C,IACE,IACA,EAAe,KAAiB,EAChC,IACA,CACA,KAAM,GAAe,EAAe,GAE9B,EAAc,EAAK,YAAY,0BACnC,EAAa,GACb,EAAa,GACb,EACA,EACA,EACA,GAEF,AAAI,EAAc,GAChB,GAAiB,EACjB,EAAqB,GAKzB,AAAI,GACF,EAAmB,KAAK,GAE1B,EAAmB,KAAK,GAG1B,KAAM,GAAe,EACrB,EAAuB,EACvB,EAAqB,QAKrB,EAAmB,SAAW,EAAqB,QAErD,MAAO,IAiBI,4BAA4B,CACvC,EACA,EACA,EACA,EACA,EACA,IACU,CASV,KAAM,GAAW,EAAK,EAChB,EAAW,EAAK,EAChB,EAAW,EAAK,EAChB,EAAW,EAAK,EAEhB,EAAoB,EAAW,EAAW,EAAW,EAC3D,GAAI,IAAsB,EAGxB,MAAO,GAAW,EAAW,EAAW,EAG1C,KAAM,GAAK,GAAW,EAAW,EAAW,GAAY,EACxD,GAAI,EAAI,EAGN,MAAO,GAAW,EAAW,EAAW,EACnC,GAAI,EAAI,EAGb,MAAQ,GAAK,GAAO,GAAK,GAAO,GAAK,GAAO,GAAK,GAQnD,KAAM,GAAS,EAAK,EAAI,EAAW,EAC7B,EAAS,EAAK,EAAI,EAAW,EAEnC,MAAO,GAAS,EAAS,EAAS,KA9JrB,uCADT",
  "names": []
}
