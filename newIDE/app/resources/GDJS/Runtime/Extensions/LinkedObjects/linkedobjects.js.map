{
  "version": 3,
  "sources": ["../../../../../../../Extensions/LinkedObjects/linkedobjects.ts"],
  "sourcesContent": ["/*\nGDevelop - LinkedObjects Extension\nCopyright (c) 2013-2016 Florian Rival (Florian.Rival@gmail.com)\n */\nnamespace gdjs {\n  /**\n   * Manages the links between objects.\n   */\n  export class LinksManager {\n    private _links = new Map<integer, IterableLinkedObjects>();\n\n    /**\n     * Get the links manager of a scene.\n     */\n    static getManager(\n      instanceContainer: gdjs.RuntimeInstanceContainer\n    ): gdjs.LinksManager {\n      // @ts-ignore\n      if (!instanceContainer.linkedObjectsManager) {\n        //Create the shared manager if necessary.\n        // @ts-ignore\n        instanceContainer.linkedObjectsManager = new gdjs.LinksManager();\n      }\n      // @ts-ignore\n      return instanceContainer.linkedObjectsManager;\n    }\n\n    /**\n     * This function is for internal use and could disappear in next versions.\n     * Prefer using:\n     * * {@link LinksManager.getObjectsLinkedWithAndNamed}\n     * * {@link LinksManager.getObjectsLinkedWith}\n     * * {@link evtTools.linkedObjects.quickPickObjectsLinkedTo}\n     *\n     * @param objA\n     * @returns the linked objects by name\n     */\n    _getMapOfObjectsLinkedWith(\n      objA: gdjs.RuntimeObject\n    ): Map<string, gdjs.RuntimeObject[]> {\n      if (!this._links.has(objA.id)) {\n        this._links.set(objA.id, new IterableLinkedObjects());\n      }\n      return this._links.get(objA.id)!.linkedObjectMap;\n    }\n\n    // These 2 following functions give JS extensions an implementation dependent access to links.\n\n    /**\n     * @returns an iterable on every object linked with objA.\n     */\n    getObjectsLinkedWith(\n      objA: gdjs.RuntimeObject\n    ): Iterable<gdjs.RuntimeObject> {\n      if (!this._links.has(objA.id)) {\n        this._links.set(objA.id, new IterableLinkedObjects());\n      }\n      return this._links.get(objA.id)!;\n    }\n\n    /**\n     * @returns an iterable of the objects with the given name that are linked with objA.\n     */\n    getObjectsLinkedWithAndNamed(\n      objA: gdjs.RuntimeObject,\n      objectName: string\n    ): Iterable<gdjs.RuntimeObject> {\n      let objects = this._getMapOfObjectsLinkedWith(objA).get(objectName);\n      if (!objects) {\n        // Give an empty Array\n        objects = gdjs.staticArray(\n          LinksManager.prototype.getObjectsLinkedWithAndNamed\n        );\n      }\n      return objects;\n    }\n\n    linkObjects(objA: gdjs.RuntimeObject, objB: gdjs.RuntimeObject) {\n      const objALinkedObjectMap = this._getMapOfObjectsLinkedWith(objA);\n      if (!objALinkedObjectMap.has(objB.getName())) {\n        objALinkedObjectMap.set(objB.getName(), []);\n      }\n      const objALinkedObjects = objALinkedObjectMap.get(objB.getName())!;\n      if (objALinkedObjects.indexOf(objB) === -1) {\n        objALinkedObjects.push(objB);\n      }\n      const objBLinkedObjectMap = this._getMapOfObjectsLinkedWith(objB);\n      if (!objBLinkedObjectMap.has(objA.getName())) {\n        objBLinkedObjectMap.set(objA.getName(), []);\n      }\n      const objBLinkedObjects = objBLinkedObjectMap.get(objA.getName())!;\n      if (objBLinkedObjects.indexOf(objA) === -1) {\n        objBLinkedObjects.push(objA);\n      }\n    }\n\n    removeAllLinksOf(removedObject: gdjs.RuntimeObject) {\n      // Remove the other side of the links\n      // Note: don't use `this._getMapOfObjectsLinkedWith` as this would\n      // create an empty map of linked objects if not existing already.\n      const links = this._links.get(removedObject.id);\n      if (!links) {\n        // No existing links to other objects.\n        // This also means no links to the object from other objects.\n        return;\n      }\n\n      for (const linkedObjects of links.linkedObjectMap.values()) {\n        for (let i = 0; i < linkedObjects.length; i++) {\n          // This is the object on the other side of the link.\n          // We find the removed object in its list of linked objects and remove it.\n          const linkedObject = linkedObjects[i];\n\n          if (this._links.has(linkedObject.id)) {\n            const otherObjList = this._links\n              .get(linkedObject.id)!\n              .linkedObjectMap.get(removedObject.getName())!;\n\n            const index = otherObjList.indexOf(removedObject);\n            if (index !== -1) {\n              otherObjList.splice(index, 1);\n            }\n          }\n        }\n      }\n\n      // Remove the links on the removedObject side.\n      this._links.delete(removedObject.id);\n    }\n\n    removeLinkBetween(objA: gdjs.RuntimeObject, objB: gdjs.RuntimeObject) {\n      if (this._links.has(objA.id)) {\n        const map = this._links.get(objA.id)!.linkedObjectMap;\n        if (map.has(objB.getName())) {\n          const list = map.get(objB.getName())!;\n          const index = list.indexOf(objB);\n          if (index !== -1) {\n            list.splice(index, 1);\n          }\n        }\n      }\n      if (this._links.has(objB.id)) {\n        const map = this._links.get(objB.id)!.linkedObjectMap;\n        if (map.has(objA.getName())) {\n          const list = map.get(objA.getName())!;\n          const index = list.indexOf(objA);\n          if (index !== -1) {\n            list.splice(index, 1);\n          }\n        }\n      }\n    }\n  }\n\n  class IterableLinkedObjects implements Iterable<gdjs.RuntimeObject> {\n    linkedObjectMap: Map<string, gdjs.RuntimeObject[]>;\n    static emptyItr: Iterator<gdjs.RuntimeObject> = {\n      next: () => ({ value: undefined, done: true }),\n    };\n\n    constructor() {\n      this.linkedObjectMap = new Map<string, gdjs.RuntimeObject[]>();\n    }\n\n    [Symbol.iterator]() {\n      let mapItr = this.linkedObjectMap.values();\n      let listItr: Iterator<gdjs.RuntimeObject> =\n        IterableLinkedObjects.emptyItr;\n\n      return {\n        next: () => {\n          let listNext = listItr.next();\n          while (listNext.done) {\n            const mapNext = mapItr.next();\n            if (mapNext.done) {\n              return listNext;\n            }\n            listItr = mapNext.value[Symbol.iterator]();\n            listNext = listItr.next();\n          }\n          return listNext;\n        },\n      };\n    }\n  }\n\n  export namespace evtTools {\n    export namespace linkedObjects {\n      gdjs.registerObjectDeletedFromSceneCallback(function (\n        instanceContainer,\n        obj\n      ) {\n        LinksManager.getManager(instanceContainer).removeAllLinksOf(obj);\n      });\n\n      export const linkObjects = function (\n        instanceContainer: gdjs.RuntimeInstanceContainer,\n        objA: gdjs.RuntimeObject,\n        objB: gdjs.RuntimeObject\n      ) {\n        if (objA === null || objB === null) {\n          return;\n        }\n        LinksManager.getManager(instanceContainer).linkObjects(objA, objB);\n      };\n\n      export const removeLinkBetween = function (\n        instanceContainer: gdjs.RuntimeInstanceContainer,\n        objA: gdjs.RuntimeObject,\n        objB: gdjs.RuntimeObject\n      ) {\n        if (objA === null || objB === null) {\n          return;\n        }\n        LinksManager.getManager(instanceContainer).removeLinkBetween(\n          objA,\n          objB\n        );\n      };\n\n      export const removeAllLinksOf = function (\n        instanceContainer: gdjs.RuntimeInstanceContainer,\n        objA: gdjs.RuntimeObject\n      ) {\n        if (objA === null) {\n          return;\n        }\n        LinksManager.getManager(instanceContainer).removeAllLinksOf(objA);\n      };\n\n      export const pickObjectsLinkedTo = function (\n        instanceContainer: gdjs.RuntimeInstanceContainer,\n        objectsLists: Hashtable<gdjs.RuntimeObject[]>,\n        obj: gdjs.RuntimeObject,\n        eventsFunctionContext: EventsFunctionContext | undefined\n      ) {\n        if (obj === null) {\n          return false;\n        }\n        const linkedObjectMap = LinksManager.getManager(\n          instanceContainer\n        )._getMapOfObjectsLinkedWith(obj);\n\n        let pickedSomething = false;\n        for (const contextObjectName in objectsLists.items) {\n          if (objectsLists.containsKey(contextObjectName)) {\n            const parentEventPickedObjects =\n              objectsLists.items[contextObjectName];\n\n            if (parentEventPickedObjects.length === 0) {\n              continue;\n            }\n\n            // Find the object names in the scene\n            const parentEventPickedObjectNames = gdjs.staticArray2(\n              gdjs.evtTools.linkedObjects.pickObjectsLinkedTo\n            );\n            parentEventPickedObjectNames.length = 0;\n            if (eventsFunctionContext) {\n              // For functions, objects lists may contain objects with different names\n              // indexed not by their name, but by the parameter name representing them.\n              // This means that each object can have a different name,\n              // so we iterate on them to get all the names.\n              for (const pickedObject of parentEventPickedObjects) {\n                if (\n                  parentEventPickedObjectNames.indexOf(pickedObject.getName()) <\n                  0\n                ) {\n                  parentEventPickedObjectNames.push(pickedObject.getName());\n                }\n              }\n            } else {\n              // In the case of a scene, the list of objects are guaranteed\n              // to be indexed by the object name (no mix of objects with\n              // different names in a list).\n              parentEventPickedObjectNames.push(contextObjectName);\n            }\n\n            // Sum the number of instances in the scene for each objects found\n            // previously in parentEventPickedObjects, so that we know if we can\n            // avoid running an intersection with the picked objects later.\n            let objectCount = 0;\n            for (const objectName of parentEventPickedObjectNames) {\n              objectCount += instanceContainer.getObjects(objectName)!.length;\n            }\n\n            if (parentEventPickedObjects.length === objectCount) {\n              // The parent event didn't make any selection on the current object,\n              // (because the number of picked objects is the total object count on the scene).\n              // There is no need to make an intersection.\n              // We will only replace the picked list with the linked object list.\n              parentEventPickedObjects.length = 0;\n              for (const objectName of parentEventPickedObjectNames) {\n                if (linkedObjectMap.has(objectName)) {\n                  const linkedObjects = linkedObjectMap.get(objectName)!;\n\n                  pickedSomething = pickedSomething || linkedObjects.length > 0;\n                  parentEventPickedObjects.push.apply(\n                    parentEventPickedObjects,\n                    linkedObjects\n                  );\n                }\n              }\n            } else {\n              // Run an intersection between objects picked by parent events\n              // and the linked ones.\n              const pickedAndLinkedObjects = gdjs.staticArray(\n                gdjs.evtTools.linkedObjects.pickObjectsLinkedTo\n              );\n              pickedAndLinkedObjects.length = 0;\n\n              for (const objectName of parentEventPickedObjectNames) {\n                if (linkedObjectMap.has(objectName)) {\n                  const linkedObjects = linkedObjectMap.get(objectName)!;\n\n                  for (const otherObject of linkedObjects) {\n                    if (parentEventPickedObjects.indexOf(otherObject) >= 0) {\n                      pickedAndLinkedObjects.push(otherObject);\n                    }\n                  }\n                }\n              }\n              pickedSomething =\n                pickedSomething || pickedAndLinkedObjects.length > 0;\n              parentEventPickedObjects.length = 0;\n              parentEventPickedObjects.push.apply(\n                parentEventPickedObjects,\n                pickedAndLinkedObjects\n              );\n              pickedAndLinkedObjects.length = 0;\n            }\n            parentEventPickedObjectNames.length = 0;\n          }\n        }\n        return pickedSomething;\n      };\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
