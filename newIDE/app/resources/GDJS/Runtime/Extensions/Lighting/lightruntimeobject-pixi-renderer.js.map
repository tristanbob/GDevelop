{
  "version": 3,
  "sources": ["../../../../../../../Extensions/Lighting/lightruntimeobject-pixi-renderer.ts"],
  "sourcesContent": ["namespace gdjs {\n  const logger = new gdjs.Logger('Light object');\n  import PIXI = GlobalPIXIModule.PIXI;\n\n  /**\n   * Pixi renderer for light runtime objects.\n   */\n  export class LightRuntimeObjectPixiRenderer {\n    _object: gdjs.LightRuntimeObject;\n    _instanceContainer: gdjs.RuntimeInstanceContainer;\n    _manager: gdjs.LightObstaclesManager;\n    _radius: number;\n    _color: [number, number, number];\n    _texture: PIXI.Texture | null = null;\n    _center: Float32Array;\n    _defaultVertexBuffer: Float32Array;\n    _vertexBuffer: Float32Array;\n    _indexBuffer: Uint16Array;\n    _light: PIXI.Mesh<PIXI.Shader> | null = null;\n    _isPreview: boolean;\n    _debugMode: boolean = false;\n    _debugLight: PIXI.Container | null = null;\n    _debugGraphics: PIXI.Graphics | null = null;\n\n    /**\n     * A polygon updated when vertices of the light are computed\n     * to be a polygon bounding the light and its obstacles.\n     */\n    _lightBoundingPoly: gdjs.Polygon;\n\n    constructor(\n      runtimeObject: gdjs.LightRuntimeObject,\n      instanceContainer: gdjs.RuntimeInstanceContainer\n    ) {\n      this._object = runtimeObject;\n      this._instanceContainer = instanceContainer;\n      this._manager = runtimeObject.getObstaclesManager();\n      this._radius = runtimeObject.getRadius();\n      const objectColor = runtimeObject._color;\n      this._color = [\n        objectColor[0] / 255,\n        objectColor[1] / 255,\n        objectColor[2] / 255,\n      ];\n      this.updateTexture();\n      this._center = new Float32Array([runtimeObject.x, runtimeObject.y]);\n      this._defaultVertexBuffer = new Float32Array(8);\n      this._vertexBuffer = new Float32Array([\n        runtimeObject.x - this._radius,\n        runtimeObject.y + this._radius,\n        runtimeObject.x + this._radius,\n        runtimeObject.y + this._radius,\n        runtimeObject.x + this._radius,\n        runtimeObject.y - this._radius,\n        runtimeObject.x - this._radius,\n        runtimeObject.y - this._radius,\n      ]);\n      this._indexBuffer = new Uint16Array([0, 1, 2, 0, 2, 3]);\n      this.updateMesh();\n      this._isPreview = instanceContainer.getGame().isPreview();\n      this._lightBoundingPoly = gdjs.Polygon.createRectangle(0, 0);\n\n      this.updateDebugMode();\n\n      // Objects will be added in lighting layer, this is just to maintain consistency.\n      if (this._light) {\n        instanceContainer\n          .getLayer('')\n          .getRenderer()\n          .addRendererObject(\n            this.getRendererObject(),\n            runtimeObject.getZOrder()\n          );\n      }\n    }\n\n    static _verticesWithAngleComparator(vertexWithAngleA, vertexWithAngleB) {\n      if (vertexWithAngleA.angle < vertexWithAngleB.angle) {\n        return -1;\n      }\n      if (vertexWithAngleA.angle > vertexWithAngleB.angle) {\n        return 1;\n      }\n      return 0;\n    }\n\n    static _computeClosestIntersectionPoint(\n      lightObject: gdjs.LightRuntimeObject,\n      angle: float,\n      polygons: Array<gdjs.Polygon>,\n      boundingSquareHalfDiag: float\n    ) {\n      const centerX = lightObject.getX();\n      const centerY = lightObject.getY();\n      const targetX = centerX + boundingSquareHalfDiag * Math.cos(angle);\n      const targetY = centerY + boundingSquareHalfDiag * Math.sin(angle);\n      let minSqDist = boundingSquareHalfDiag * boundingSquareHalfDiag;\n      const closestPoint: Array<integer | null> = [null, null];\n      for (const poly of polygons) {\n        const raycastResult = gdjs.Polygon.raycastTest(\n          poly,\n          centerX,\n          centerY,\n          targetX,\n          targetY\n        );\n        if (raycastResult.collision && raycastResult.closeSqDist <= minSqDist) {\n          minSqDist = raycastResult.closeSqDist;\n          closestPoint[0] = raycastResult.closeX;\n          closestPoint[1] = raycastResult.closeY;\n        }\n      }\n      if (closestPoint[0] && closestPoint[1]) {\n        return closestPoint;\n      }\n      return null;\n    }\n\n    getRendererObject(): PIXI.Mesh | null | PIXI.Container {\n      if (this._debugLight) {\n        return this._debugLight;\n      }\n      return this._light;\n    }\n\n    ensureUpToDate() {\n      if (this._object.isHidden()) {\n        return;\n      }\n      if (this._debugGraphics) {\n        this._updateDebugGraphics();\n      }\n      this._updateBuffers();\n    }\n\n    updateMesh(): void {\n      if (!PIXI.utils.isWebGLSupported()) {\n        logger.warn(\n          'This device does not support webgl, which is required for Lighting Extension.'\n        );\n        return;\n      }\n      this.updateTexture();\n      const fragmentShader =\n        this._texture === null\n          ? LightRuntimeObjectPixiRenderer.defaultFragmentShader\n          : LightRuntimeObjectPixiRenderer.texturedFragmentShader;\n      const shaderUniforms = {\n        center: this._center,\n        radius: this._radius,\n        color: this._color,\n      };\n      if (this._texture) {\n        // @ts-ignore\n        shaderUniforms.uSampler = this._texture;\n      }\n      const shader = PIXI.Shader.from(\n        LightRuntimeObjectPixiRenderer.defaultVertexShader,\n        fragmentShader,\n        shaderUniforms\n      );\n      const geometry = new PIXI.Geometry();\n      geometry\n        .addAttribute('aVertexPosition', this._vertexBuffer, 2)\n        .addIndex(this._indexBuffer);\n      if (!this._light) {\n        this._light = new PIXI.Mesh(geometry, shader);\n        this._light.blendMode = PIXI.BLEND_MODES.ADD;\n      } else {\n        this._light.shader = shader;\n        // @ts-ignore - replacing the read-only geometry\n        this._light.geometry = geometry;\n      }\n    }\n\n    updateRadius(): void {\n      if (!this._light) {\n        return;\n      }\n      this._radius = this._object.getRadius();\n      this._light.shader.uniforms.radius = this._radius;\n    }\n\n    updateColor(): void {\n      if (!this._light) {\n        return;\n      }\n      const objectColor = this._object._color;\n      this._color = [\n        objectColor[0] / 255,\n        objectColor[1] / 255,\n        objectColor[2] / 255,\n      ];\n      this._light.shader.uniforms.color = this._color;\n    }\n\n    updateTexture(): void {\n      const texture = this._object.getTexture();\n      this._texture =\n        texture !== ''\n          ? (this._instanceContainer\n              .getGame()\n              .getImageManager() as gdjs.PixiImageManager).getPIXITexture(\n              texture\n            )\n          : null;\n    }\n\n    updateDebugMode(): void {\n      if (!this._light) {\n        return;\n      }\n      this._debugMode = this._object.getDebugMode();\n      if (!this._debugLight && (this._isPreview || this._debugMode)) {\n        this._debugLight = new PIXI.Container();\n        this._debugLight.addChild(this._light);\n      }\n      if (this._debugMode && !this._debugGraphics) {\n        this._debugGraphics = new PIXI.Graphics();\n        (this._debugLight as PIXI.Container).addChild(this._debugGraphics);\n      }\n      if (!this._debugMode && this._debugGraphics) {\n        (this._debugLight as PIXI.Container).removeChild(this._debugGraphics);\n        this._debugGraphics.destroy();\n        this._debugGraphics = null;\n      }\n      this.ensureUpToDate();\n    }\n\n    _updateDebugGraphics() {\n      const debugGraphics = this._debugGraphics as PIXI.Graphics;\n\n      const computedVertices = this._computeLightVertices();\n      if (!computedVertices.length) {\n        debugGraphics.clear();\n        debugGraphics\n          .lineStyle(1, 16711680, 1)\n          .moveTo(this._object.x, this._object.y)\n          .lineTo(this._object.x - this._radius, this._object.y + this._radius)\n          .lineTo(this._object.x + this._radius, this._object.y + this._radius)\n          .moveTo(this._object.x, this._object.y)\n          .lineTo(this._object.x + this._radius, this._object.y + this._radius)\n          .lineTo(this._object.x + this._radius, this._object.y - this._radius)\n          .moveTo(this._object.x, this._object.y)\n          .lineTo(this._object.x + this._radius, this._object.y - this._radius)\n          .lineTo(this._object.x - this._radius, this._object.y - this._radius)\n          .moveTo(this._object.x, this._object.y)\n          .lineTo(this._object.x - this._radius, this._object.y - this._radius)\n          .lineTo(this._object.x - this._radius, this._object.y + this._radius);\n        return;\n      }\n      const vertices = new Array(2 * computedVertices.length + 2);\n      vertices[0] = this._object.x;\n      vertices[1] = this._object.y;\n      for (let i = 2; i < 2 * computedVertices.length + 2; i += 2) {\n        vertices[i] = computedVertices[i / 2 - 1][0];\n        vertices[i + 1] = computedVertices[i / 2 - 1][1];\n      }\n      debugGraphics.clear();\n      debugGraphics.moveTo(vertices[2], vertices[3]);\n      const verticesCount = vertices.length;\n      for (let i = 2; i < verticesCount; i += 2) {\n        const lineColor = i % 4 === 0 ? 16711680 : 65280;\n        const lastX = i + 2 >= verticesCount ? 2 : i + 2;\n        const lastY = i + 3 >= verticesCount ? 3 : i + 3;\n        debugGraphics\n          .lineStyle(1, lineColor, 1)\n          .lineTo(vertices[i], vertices[i + 1])\n          .lineTo(vertices[lastX], vertices[lastY])\n          .moveTo(vertices[0], vertices[1])\n          .lineTo(vertices[i], vertices[i + 1])\n          .moveTo(vertices[0], vertices[1])\n          .lineTo(vertices[lastX], vertices[lastY]);\n      }\n    }\n\n    _updateBuffers() {\n      if (!this._light) {\n        return;\n      }\n      this._center[0] = this._object.x;\n      this._center[1] = this._object.y;\n      const vertices = this._computeLightVertices();\n\n      // Fallback to simple quad when there are no obstacles around.\n      if (vertices.length === 0) {\n        this._defaultVertexBuffer[0] = this._object.x - this._radius;\n        this._defaultVertexBuffer[1] = this._object.y + this._radius;\n        this._defaultVertexBuffer[2] = this._object.x + this._radius;\n        this._defaultVertexBuffer[3] = this._object.y + this._radius;\n        this._defaultVertexBuffer[4] = this._object.x + this._radius;\n        this._defaultVertexBuffer[5] = this._object.y - this._radius;\n        this._defaultVertexBuffer[6] = this._object.x - this._radius;\n        this._defaultVertexBuffer[7] = this._object.y - this._radius;\n        this._light.shader.uniforms.center = this._center;\n        this._light.geometry\n          .getBuffer('aVertexPosition')\n          .update(this._defaultVertexBuffer);\n        this._light.geometry\n          .getIndex()\n          .update(LightRuntimeObjectPixiRenderer._defaultIndexBuffer);\n        return;\n      }\n      const verticesCount = vertices.length;\n\n      // If the array buffer which is already allocated is at most\n      // twice the size of memory required, we could avoid re-allocation\n      // and instead use a subarray. Otherwise, allocate new array buffers as\n      // there would be memory wastage.\n      let isSubArrayUsed = false;\n      let vertexBufferSubArray: Float32Array | null = null;\n      let indexBufferSubArray: Uint16Array | null = null;\n      if (this._vertexBuffer.length > 2 * verticesCount + 2) {\n        if (this._vertexBuffer.length < 4 * verticesCount + 4) {\n          isSubArrayUsed = true;\n          vertexBufferSubArray = this._vertexBuffer.subarray(\n            0,\n            2 * verticesCount + 2\n          );\n          indexBufferSubArray = this._indexBuffer.subarray(\n            0,\n            3 * verticesCount\n          );\n        } else {\n          this._vertexBuffer = new Float32Array(2 * verticesCount + 2);\n          this._indexBuffer = new Uint16Array(3 * verticesCount);\n        }\n      }\n\n      // When the allocated array buffer has less memory than\n      // required, we'll have to allocated new array buffers.\n      if (this._vertexBuffer.length < 2 * verticesCount + 2) {\n        this._vertexBuffer = new Float32Array(2 * verticesCount + 2);\n        this._indexBuffer = new Uint16Array(3 * verticesCount);\n      }\n      this._vertexBuffer[0] = this._object.x;\n      this._vertexBuffer[1] = this._object.y;\n      for (let i = 2; i < 2 * verticesCount + 2; i += 2) {\n        this._vertexBuffer[i] = vertices[i / 2 - 1][0];\n        this._vertexBuffer[i + 1] = vertices[i / 2 - 1][1];\n      }\n      for (let i = 0; i < 3 * verticesCount; i += 3) {\n        this._indexBuffer[i] = 0;\n        this._indexBuffer[i + 1] = i / 3 + 1;\n        if (i / 3 + 1 !== verticesCount) {\n          this._indexBuffer[i + 2] = i / 3 + 2;\n        } else {\n          this._indexBuffer[i + 2] = 1;\n        }\n      }\n      this._light.shader.uniforms.center = this._center;\n      if (!isSubArrayUsed) {\n        this._light.geometry\n          .getBuffer('aVertexPosition')\n          .update(this._vertexBuffer);\n        this._light.geometry.getIndex().update(this._indexBuffer);\n      } else {\n        this._light.geometry\n          .getBuffer('aVertexPosition')\n          // @ts-ignore\n          .update(vertexBufferSubArray);\n        // @ts-ignore\n        this._light.geometry.getIndex().update(indexBufferSubArray);\n      }\n    }\n\n    /**\n     * Computes the vertices of mesh using raycasting.\n     * @returns the vertices of mesh.\n     */\n    _computeLightVertices(): Array<FloatPoint> {\n      const lightObstacles: gdjs.LightObstacleRuntimeBehavior[] = [];\n      if (this._manager) {\n        this._manager.getAllObstaclesAround(\n          this._object,\n          this._radius,\n          lightObstacles\n        );\n      }\n      const searchAreaLeft = this._object.getX() - this._radius;\n      const searchAreaTop = this._object.getY() - this._radius;\n      const searchAreaRight = this._object.getX() + this._radius;\n      const searchAreaBottom = this._object.getY() + this._radius;\n\n      // Bail out early if there are no obstacles.\n      if (lightObstacles.length === 0) {\n        // @ts-ignore TODO the array should probably be pass as a parameter.\n        return lightObstacles;\n      }\n\n      // Synchronize light bounding polygon with the hitbox.\n      // Note: we suppose the hitbox is always a single rectangle.\n      const objectHitBox = this._object.getHitBoxes()[0];\n      for (let i = 0; i < 4; i++) {\n        this._lightBoundingPoly.vertices[i][0] = objectHitBox.vertices[i][0];\n        this._lightBoundingPoly.vertices[i][1] = objectHitBox.vertices[i][1];\n      }\n\n      // Create the list of polygons to compute the light vertices\n      const obstaclePolygons: Array<gdjs.Polygon> = [];\n      obstaclePolygons.push(this._lightBoundingPoly);\n      for (let i = 0; i < lightObstacles.length; i++) {\n        const obstacleHitBoxes = lightObstacles[i].owner.getHitBoxesAround(\n          searchAreaLeft,\n          searchAreaTop,\n          searchAreaRight,\n          searchAreaBottom\n        );\n        for (const hitbox of obstacleHitBoxes) {\n          obstaclePolygons.push(hitbox);\n        }\n      }\n\n      let maxX = this._object.x + this._radius;\n      let minX = this._object.x - this._radius;\n      let maxY = this._object.y + this._radius;\n      let minY = this._object.y - this._radius;\n      const flattenVertices: Array<FloatPoint> = [];\n      for (let i = 1; i < obstaclePolygons.length; i++) {\n        const vertices = obstaclePolygons[i].vertices;\n        const verticesCount = vertices.length;\n        for (let j = 0; j < verticesCount; j++) {\n          flattenVertices.push(vertices[j]);\n          if (vertices[j][0] < minX) {\n            minX = vertices[j][0];\n          }\n          if (vertices[j][0] > maxX) {\n            maxX = vertices[j][0];\n          }\n          if (vertices[j][1] < minY) {\n            minY = vertices[j][1];\n          }\n          if (vertices[j][1] > maxY) {\n            maxY = vertices[j][1];\n          }\n        }\n      }\n      obstaclePolygons[0].vertices[0][0] = minX;\n      obstaclePolygons[0].vertices[0][1] = minY;\n      obstaclePolygons[0].vertices[1][0] = maxX;\n      obstaclePolygons[0].vertices[1][1] = minY;\n      obstaclePolygons[0].vertices[2][0] = maxX;\n      obstaclePolygons[0].vertices[2][1] = maxY;\n      obstaclePolygons[0].vertices[3][0] = minX;\n      obstaclePolygons[0].vertices[3][1] = maxY;\n\n      // Find the largest diagonal length.\n      const boundingSquareHalfDiag = Math.sqrt(\n        Math.max(\n          (this._object.x - minX) * (this._object.x - minX) +\n            (this._object.y - minY) * (this._object.y - minY),\n          (maxX - this._object.x) * (maxX - this._object.x) +\n            (this._object.y - minY) * (this._object.y - minY),\n          (maxX - this._object.x) * (maxX - this._object.x) +\n            (maxY - this._object.y) * (maxY - this._object.y),\n          (this._object.x - minX) * (this._object.x - minX) +\n            (maxY - this._object.y) * (maxY - this._object.y)\n        )\n      );\n      // Add this._object.hitBoxes vertices.\n      for (let i = 0; i < 4; i++) {\n        flattenVertices.push(obstaclePolygons[0].vertices[i]);\n      }\n      const closestVertices: Array<any> = [];\n      const flattenVerticesCount = flattenVertices.length;\n      for (let i = 0; i < flattenVerticesCount; i++) {\n        const xdiff = flattenVertices[i][0] - this._object.x;\n        const ydiff = flattenVertices[i][1] - this._object.y;\n        const angle = Math.atan2(ydiff, xdiff);\n        const closestVertex = LightRuntimeObjectPixiRenderer._computeClosestIntersectionPoint(\n          this._object,\n          angle,\n          obstaclePolygons,\n          boundingSquareHalfDiag\n        );\n        if (closestVertex) {\n          closestVertices.push({ vertex: closestVertex, angle: angle });\n        }\n\n        // TODO: Check whether we need to raycast these two extra rays or not.\n        const closestVertexOffsetLeft = LightRuntimeObjectPixiRenderer._computeClosestIntersectionPoint(\n          this._object,\n          angle + 0.0001,\n          obstaclePolygons,\n          boundingSquareHalfDiag\n        );\n        if (closestVertexOffsetLeft) {\n          closestVertices.push({\n            vertex: closestVertexOffsetLeft,\n            angle: angle + 0.0001,\n          });\n        }\n        const closestVertexOffsetRight = LightRuntimeObjectPixiRenderer._computeClosestIntersectionPoint(\n          this._object,\n          angle - 0.0001,\n          obstaclePolygons,\n          boundingSquareHalfDiag\n        );\n        if (closestVertexOffsetRight) {\n          closestVertices.push({\n            vertex: closestVertexOffsetRight,\n            angle: angle - 0.0001,\n          });\n        }\n      }\n      closestVertices.sort(\n        LightRuntimeObjectPixiRenderer._verticesWithAngleComparator\n      );\n      const filteredVerticesResult = [closestVertices[0].vertex];\n      const closestVerticesCount = closestVertices.length;\n      for (let i = 1; i < closestVerticesCount; i++) {\n        if (closestVertices[i].angle !== closestVertices[i - 1].angle) {\n          filteredVerticesResult.push(closestVertices[i].vertex);\n        }\n      }\n      return filteredVerticesResult;\n    }\n\n    static _defaultIndexBuffer = new Uint16Array([0, 1, 2, 0, 2, 3]);\n    static defaultVertexShader = `\n  precision highp float;\n  attribute vec2 aVertexPosition;\n\n  uniform mat3 translationMatrix;\n  uniform mat3 projectionMatrix;\n  varying vec2 vPos;\n\n  void main() {\n      vPos = aVertexPosition;\n      gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n  }`;\n    static defaultFragmentShader = `\n  precision highp float;\n  uniform vec2 center;\n  uniform float radius;\n  uniform vec3 color;\n  varying vec2 vPos;\n\n  void main() {\n      float l = length(vPos - center);\n      float intensity = 0.0;\n      if(l < radius)\n        intensity = clamp((radius - l)*(radius - l)/(radius*radius), 0.0, 1.0);\n      gl_FragColor = vec4(color*intensity, 1.0);\n  }`;\n    static texturedFragmentShader = `\n  precision highp float;\n  uniform vec2 center;\n  uniform float radius;\n  uniform vec3 color;\n  uniform sampler2D uSampler;\n  varying vec2 vPos;\n\n  void main() {\n    vec2 topleft = vec2(center.x - radius, center.y - radius);\n    vec2 texCoord = (vPos - topleft)/(2.0 * radius);\n    gl_FragColor = (texCoord.x > 0.0 && texCoord.x < 1.0 && texCoord.y > 0.0 && texCoord.y < 1.0)\n      ? vec4(color, 1.0) * texture2D(uSampler, texCoord)\n      : vec4(0.0, 0.0, 0.0, 0.0);\n  }`;\n  }\n\n  // @ts-ignore - Register the class to let the engine use it.\n  export const LightRuntimeObjectRenderer = LightRuntimeObjectPixiRenderer;\n  export type LightRuntimeObjectRenderer = LightRuntimeObjectPixiRenderer;\n}\n"],
  "mappings": "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",
  "names": []
}
