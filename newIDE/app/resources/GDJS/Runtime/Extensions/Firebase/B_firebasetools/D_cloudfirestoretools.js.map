{
  "version": 3,
  "sources": ["../../../../../../../../Extensions/Firebase/B_firebasetools/D_cloudfirestoretools.ts"],
  "sourcesContent": ["namespace gdjs {\n  export namespace evtTools {\n    export namespace firebaseTools {\n      /**\n       * Firebase Cloud Firestore Event Tools.\n       * @namespace\n       */\n      export namespace firestore {\n        const queries = new Map<string, firebase.firestore.Query>();\n\n        /**\n         * Converts a firebase document snapshot to a plain dictionary,\n         * so that it may be serialized or converted to a {@link gdjs.Variable}.\n         *\n         * @param doc - The document snapshot.\n         * @returns - The converted object.\n         */\n        const documentSnapshotToSerializable = (\n          doc: firebase.firestore.DocumentSnapshot\n        ) => ({\n          data: doc.data(),\n          exists: doc.exists,\n          id: doc.id,\n        });\n\n        /**\n         * Converts a firebase query snapshot to a plain dictionary,\n         * so that it may be serialized or converted to a {@link gdjs.Variable}.\n         *\n         * @param query - The query snapshot.\n         * @returns - The converted object.\n         */\n        const querySnapshotToSerializable = (\n          query: firebase.firestore.QuerySnapshot\n        ) => ({\n          size: query.size,\n          empty: query.empty,\n          docs: query.docs.map(documentSnapshotToSerializable),\n        });\n\n        /**\n         * Initiate a query over a collection.\n         * @param queryID - The name of the new query.\n         * @param collectionName - The name of the collection to query.\n         */\n        export const startQuery = (queryID: string, collectionName: string) => {\n          queries.set(queryID, firebase.firestore().collection(collectionName));\n        };\n\n        /**\n         * Create a new query from a base query.\n         * @param queryID - The name of the new query.\n         * @param sourceQueryID - The name of the source query.\n         */\n        export const startQueryFrom = (\n          queryID: string,\n          sourceQueryID: string\n        ) => {\n          if (queries.has(sourceQueryID))\n            queries.set(queryID, queries.get(sourceQueryID)!);\n        };\n\n        /**\n         * Filters out documents whose fields do not match a condition\n         * from a query.\n         * @param queryID - The query to add the filter to.\n         * @param field - The field to run the condition on.\n         * @param op - The condition operator.\n         * @param value - The value to check against.\n         */\n        export const queryWhere = (\n          queryID: string,\n          field: string,\n          op: Exclude<\n            firebase.firestore.WhereFilterOp,\n            // Exclude unsupported \"batch\" operations (as they require an array as value to check)\n            'in' | 'array-contains-any' | 'not-in'\n          >,\n          value: string | number\n        ) => {\n          if (queries.has(queryID))\n            queries.set(queryID, queries.get(queryID)!.where(field, op, value));\n        };\n\n        /**\n         * Orders the documents in a query.\n         *\n         * @param queryID - The query to add the filter to.\n         * @param field - The field to order by.\n         * @param direction - The direction of ordering (ascending or descending).\n         */\n        export const queryOrderBy = (\n          queryID: string,\n          field: string,\n          direction: firebase.firestore.OrderByDirection\n        ) => {\n          if (queries.has(queryID))\n            queries.set(\n              queryID,\n              queries.get(queryID)!.orderBy(field, direction)\n            );\n        };\n\n        /**\n         * Limits the amount of documents returned by the query.\n         *\n         * @param queryID - The query to add the filter to.\n         * @param amount - The amount of documents to limit to\n         * @param last - If true, limits to the last documents instead of the first documents.\n         */\n        export const queryLimit = (\n          queryID: string,\n          amount: integer,\n          last: boolean\n        ) => {\n          if (queries.has(queryID))\n            queries.set(\n              queryID,\n              queries.get(queryID)![last ? 'limitToLast' : 'limit'](amount)\n            );\n        };\n\n        /**\n         * Makes a query skip documents after or before a certain\n         * value of a field the query was ordered with.\n         *\n         * @param queryID - The query to add the filter to.\n         * @param value - The value of the field ordered by.\n         * @param before - If set to true, all documents before the document are skipped, else all documents after it are skipped.\n         * @param includeSelf - If set to true, doesn't skip the document.\n         */\n        export const querySkipSome = (\n          queryID: string,\n          value: number,\n          before: boolean,\n          includeSelf: boolean\n        ) => {\n          if (queries.has(queryID))\n            queries.set(\n              queryID,\n              queries\n                .get(queryID)!\n                [\n                  before\n                    ? includeSelf\n                      ? 'endAt'\n                      : 'endBefore'\n                    : includeSelf\n                    ? 'startAt'\n                    : 'startAfter'\n                ](value)\n            );\n        };\n\n        /**\n         * Execute a query and store results in a callback variable.\n         *\n         * @param queryID - The query to execute.\n         * @param [callbackValueVariable] - The variable where to store the result.\n         * @param [callbackStatusVariable] - The variable where to store if the operation was successful.\n         */\n        export const executeQuery = (\n          queryID: string,\n          callbackValueVariable?: gdjs.Variable,\n          callbackStatusVariable?: gdjs.Variable\n        ) => {\n          if (!queries.has(queryID)) return;\n          queries\n            .get(queryID)!\n            .get()\n            .then((snapshot) => {\n              if (typeof callbackStatusVariable !== 'undefined')\n                callbackStatusVariable.setString('ok');\n\n              if (typeof callbackValueVariable !== 'undefined')\n                callbackValueVariable.fromJSObject(\n                  querySnapshotToSerializable(snapshot)\n                );\n            })\n            .catch((error) => {\n              if (typeof callbackStatusVariable !== 'undefined')\n                callbackStatusVariable.setString(error.message);\n            });\n        };\n\n        /**\n         * Watch a query and store results in a callback\n         * variable whenever a documents starts/stops\n         * matching the query or a document matching\n         * the query is modified.\n         *\n         * @param queryID - The query to execute.\n         * @param [callbackValueVariable] - The variable where to store the result.\n         * @param [callbackStatusVariable] - The variable where to store if the operation was successful.\n         */\n        export const watchQuery = (\n          queryID: string,\n          callbackValueVariable?: gdjs.Variable,\n          callbackStatusVariable?: gdjs.Variable\n        ) => {\n          if (!queries.has(queryID)) return;\n          queries.get(queryID)!.onSnapshot(\n            (snapshot) => {\n              if (typeof callbackStatusVariable !== 'undefined')\n                callbackStatusVariable.setString('ok');\n\n              if (typeof callbackValueVariable !== 'undefined')\n                callbackValueVariable.fromJSObject(\n                  querySnapshotToSerializable(snapshot)\n                );\n            },\n            (error) => {\n              if (typeof callbackStatusVariable !== 'undefined')\n                callbackStatusVariable.setString(error.message);\n            }\n          );\n        };\n\n        /**\n         * Adds a variable in a collection as document with a unique name.\n         * @param collectionName - The collection where to store the variable.\n         * @param variable - The variable to write.\n         * @param [callbackStateVariable] - The variable where to store the result.\n         */\n        export const addDocument = (\n          collectionName: string,\n          variable: gdjs.Variable,\n          callbackStateVariable?: gdjs.Variable\n        ) => {\n          firebase\n            .firestore()\n            .collection(collectionName)\n            .add(replaceTimestampsInObject(variable.toJSObject()))\n            .then(() => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString('ok');\n            })\n            .catch((error) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString(error.message);\n            });\n        };\n\n        /**\n         * Writes a variable in a collection as document.\n         * @param collectionName - The collection where to store the variable.\n         * @param variableName - The name under which the variable will be saved (document name).\n         * @param variable - The variable to write.\n         * @param [callbackStateVariable] - The variable where to store the result.\n         */\n        export const writeDocument = (\n          collectionName: string,\n          variableName: string,\n          variable: gdjs.Variable,\n          callbackStateVariable?: gdjs.Variable\n        ) => {\n          firebase\n            .firestore()\n            .collection(collectionName)\n            .doc(variableName)\n            .set(replaceTimestampsInObject(variable.toJSObject()))\n            .then(() => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString('ok');\n            })\n            .catch((error) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString(error.message);\n            });\n        };\n\n        /**\n         * Writes a field of a document.\n         * @param collectionName - The collection where to store the document.\n         * @param documentName - The name of the document where to write a field.\n         * @param field - The field where to write.\n         * @param value - The value to write.\n         * @param [callbackStateVariable] - The variable where to store the result.\n         * @param [merge] - Should the new field replace the document or be merged with the document?\n         */\n        export const writeField = (\n          collectionName: string,\n          documentName: string,\n          field: string,\n          value: any,\n          callbackStateVariable?: gdjs.Variable,\n          merge: boolean = true\n        ) => {\n          firebase\n            .firestore()\n            .collection(collectionName)\n            .doc(documentName)\n            .set({ [field]: replaceTimestampInString(value) }, { merge: merge })\n            .then(() => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString('ok');\n            })\n            .catch((error) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString(error.message);\n            });\n        };\n\n        /**\n         * Updates a variable/document.\n         * @param collectionName - The collection where the document is stored.\n         * @param variableName - The name under which the variable will be saved (document name).\n         * @param variable - The variable to update.\n         * @param [callbackStateVariable] - The variable where to store the result.\n         */\n        export const updateDocument = (\n          collectionName: string,\n          variableName: string,\n          variable: gdjs.Variable,\n          callbackStateVariable?: gdjs.Variable\n        ) => {\n          firebase\n            .firestore()\n            .collection(collectionName)\n            .doc(variableName)\n            .update(replaceTimestampsInObject(variable.toJSObject()))\n            .then(() => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString('ok');\n            })\n            .catch((error) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString(error.message);\n            });\n        };\n\n        /**\n         * Updates a field of a document.\n         * @param collectionName - The collection where the document is stored.\n         * @param documentName - The name of the document where to update a field.\n         * @param field - The field where to update.\n         * @param value - The value to write.\n         * @param [callbackStateVariable] - The variable where to store the result.\n         */\n        export const updateField = (\n          collectionName: string,\n          documentName: string,\n          field: string,\n          value: any,\n          callbackStateVariable?: gdjs.Variable\n        ) => {\n          firebase\n            .firestore()\n            .collection(collectionName)\n            .doc(documentName)\n            .update({ [field]: replaceTimestampInString(value) })\n            .then(() => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString('ok');\n            })\n            .catch((error) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString(error.message);\n            });\n        };\n\n        /**\n         * Deletes a document.\n         * @param collectionName - The collection where the document is stored.\n         * @param documentName - The name of the document to delete.\n         * @param [callbackStateVariable] - The variable where to store the result.\n         */\n        export const deleteDocument = (\n          collectionName: string,\n          documentName: string,\n          callbackStateVariable?: gdjs.Variable\n        ) => {\n          firebase\n            .firestore()\n            .collection(collectionName)\n            .doc(documentName)\n            .delete()\n            .then(() => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString('ok');\n            })\n            .catch((error) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString(error.message);\n            });\n        };\n\n        /**\n         * Deletes a field of a document.\n         * @param collectionName - The collection where the document is stored.\n         * @param documentName - The name of the document where to delete a field.\n         * @param field - The field to delete.\n         * @param [callbackStateVariable] - The variable where to store the result.\n         */\n        export const deleteField = (\n          collectionName: string,\n          documentName: string,\n          field: string,\n          callbackStateVariable?: gdjs.Variable\n        ) => {\n          firebase\n            .firestore()\n            .collection(collectionName)\n            .doc(documentName)\n            .update({ [field]: firebase.firestore.FieldValue.delete() })\n            .then(() => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString('ok');\n            })\n            .catch((error) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString(error.message);\n            });\n        };\n\n        /**\n         * Gets a document and store it in a variable.\n         * @param collectionName - The collection where the document is stored.\n         * @param documentName - The name of the document to get.\n         * @param [callbackValueVariable] - The variable where to store the result.\n         * @param [callbackStateVariable] - The variable where to store if the operation was successful.\n         */\n        export const getDocument = (\n          collectionName: string,\n          documentName: string,\n          callbackValueVariable?: gdjs.Variable,\n          callbackStateVariable?: gdjs.Variable\n        ) => {\n          firebase\n            .firestore()\n            .collection(collectionName)\n            .doc(documentName)\n            .get()\n            .then((doc) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString('ok');\n\n              if (callbackValueVariable)\n                callbackValueVariable.fromJSObject(doc.data());\n            })\n            .catch((error) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString(error.message);\n            });\n        };\n\n        /**\n         * Gets a field of a document and store it in a variable.\n         * @param collectionName - The collection where the document is stored.\n         * @param documentName - The name of the document.\n         * @param field - The field to get.\n         * @param [callbackValueVariable] - The variable where to store the result.\n         * @param [callbackStateVariable] - The variable where to store if the operation was successful.\n         */\n        export const getField = (\n          collectionName: string,\n          documentName: string,\n          field: string,\n          callbackValueVariable?: gdjs.Variable,\n          callbackStateVariable?: gdjs.Variable\n        ) => {\n          firebase\n            .firestore()\n            .collection(collectionName)\n            .doc(documentName)\n            .get()\n            .then((doc) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString('ok');\n\n              if (callbackValueVariable)\n                callbackValueVariable.fromJSObject(doc.get(field));\n            })\n            .catch((error) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString(error.message);\n            });\n        };\n\n        /**\n         * Checks for existence of a document.\n         * @param collectionName - The collection where the document is stored.\n         * @param documentName - The name of the document to check.\n         * @param [callbackValueVariable] - The variable where to store the result.\n         * @param [callbackStateVariable] - The variable where to store if the operation was successful.\n         */\n        export const hasDocument = (\n          collectionName: string,\n          documentName: string,\n          callbackValueVariable?: gdjs.Variable,\n          callbackStateVariable?: gdjs.Variable\n        ) => {\n          firebase\n            .firestore()\n            .collection(collectionName)\n            .doc(documentName)\n            .get()\n            .then((doc) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString('ok');\n\n              if (callbackValueVariable)\n                callbackValueVariable.setBoolean(doc.exists);\n            })\n            .catch((error) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString(error.message);\n            });\n        };\n\n        /**\n         * Checks for existence of a field.\n         * @param collectionName - The collection where the document is stored.\n         * @param documentName - The name of the document.\n         * @param field - The field to check.\n         * @param [callbackValueVariable] - The variable where to store the result.\n         * @param [callbackStateVariable] - The variable where to store if the operation was successful.\n         */\n        export const hasField = (\n          collectionName: string,\n          documentName: string,\n          field: string,\n          callbackValueVariable?: gdjs.Variable,\n          callbackStateVariable?: gdjs.Variable\n        ) => {\n          firebase\n            .firestore()\n            .collection(collectionName)\n            .doc(documentName)\n            .get()\n            .then((doc) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString('ok');\n\n              if (callbackValueVariable) {\n                const value = doc.get(field, { serverTimestamps: 'estimate' });\n                callbackValueVariable.setBoolean(\n                  doc.exists && value !== undefined && value !== null\n                );\n              }\n            })\n            .catch((error) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString(error.message);\n            });\n        };\n\n        /**\n         * Lists all the documents in a collection.\n         * @param collectionName - The collection where to count documents.\n         * @param [callbackValueVariable] - The variable where to store the result.\n         * @param [callbackStateVariable] - The variable where to store if the operation was successful.\n         *\n         * @deprecated Use a query without filters instead.\n         */\n        export const listDocuments = (\n          collectionName: string,\n          callbackValueVariable?: gdjs.Variable,\n          callbackStateVariable?: gdjs.Variable\n        ) => {\n          firebase\n            .firestore()\n            .collection(collectionName)\n            .get()\n            .then((snapshot) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString(\n                  snapshot.empty ? 'empty' : 'ok'\n                );\n\n              if (callbackValueVariable)\n                callbackValueVariable.fromJSObject(\n                  snapshot.docs.map((doc) => doc.id)\n                );\n            })\n            .catch((error) => {\n              if (typeof callbackStateVariable !== 'undefined')\n                callbackStateVariable.setString(error.message);\n            });\n        };\n\n        /**\n         * Returns a special string replaced by a firebase serverTimestamp field value.\n         */\n        export const getServerTimestamp = () =>\n          '[{__FIREBASE_SERVERSIDE_TIMESTAMP}]';\n\n        const replaceTimestampInString = (str: any) => {\n          if (str === '[{__FIREBASE_SERVERSIDE_TIMESTAMP}]')\n            return firebase.firestore.FieldValue.serverTimestamp();\n          else return str;\n        };\n\n        const replaceTimestampsInObject = (object: object): object => {\n          for (const i in object) {\n            const item = object[i];\n            if (typeof item === 'object') replaceTimestampsInObject(item);\n            else if (item === '[{__FIREBASE_SERVERSIDE_TIMESTAMP}]')\n              object[i] = firebase.firestore.FieldValue.serverTimestamp();\n          }\n          return object;\n        };\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
