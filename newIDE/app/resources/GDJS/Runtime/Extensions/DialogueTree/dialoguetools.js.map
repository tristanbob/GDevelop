{
  "version": 3,
  "sources": ["../../../../../../../Extensions/DialogueTree/dialoguetools.ts"],
  "sourcesContent": ["// @ts-nocheck - Weird usage of `this` in this file. Should be refactored.\n\nnamespace gdjs {\n  const logger = new gdjs.Logger('Dialogue tree');\n\n  gdjs.dialogueTree = {};\n  gdjs.dialogueTree.runner = new bondage.Runner();\n\n  /**\n   * Load the Dialogue Tree data of the game. Initialize The Dialogue Tree, so as it can be used in the game.\n   * @param sceneVar The variable to load the Dialogue tree data from. The data is a JSON string, created by Yarn.\n   * @param startDialogueNode The Dialogue Branch to start the Dialogue Tree from. If left empty, the data will only be loaded, but can later be initialized via another action\n   */\n  gdjs.dialogueTree.loadFromSceneVariable = function (\n    sceneVar: gdjs.Variable,\n    startDialogueNode: string\n  ) {\n    this.runner = gdjs.dialogueTree.runner;\n    try {\n      this.yarnData = JSON.parse(sceneVar.getAsString());\n      this.runner.load(this.yarnData);\n      if (startDialogueNode && startDialogueNode.length > 0) {\n        gdjs.dialogueTree.startFrom(startDialogueNode);\n      }\n    } catch (e) {\n      logger.error('Error while loading from scene variable: ', e);\n    }\n  };\n\n  /**\n   * Load the Dialogue Tree data from a JSON resource.\n   *\n   * @param instanceContainer The scene where the dialogue is running.\n   * @param jsonResourceName The JSON resource where to load the Dialogue Tree data from. The data is a JSON string usually created with [Yarn Dialogue Editor](https://github.com/InfiniteAmmoInc/Yarn).\n   * @param startDialogueNode The Dialogue Branch to start the Dialogue Tree from. If left empty, the data will only be loaded, but can later be initialized via another action\n   */\n  gdjs.dialogueTree.loadFromJsonFile = function (\n    instanceContainer: gdjs.RuntimeInstanceContainer,\n    jsonResourceName: string,\n    startDialogueNode: string\n  ) {\n    instanceContainer\n      .getGame()\n      .getJsonManager()\n      .loadJson(jsonResourceName, function (error, content) {\n        if (error) {\n          logger.error('An error happened while loading JSON resource:', error);\n        } else {\n          if (!content) {\n            return;\n          }\n          gdjs.dialogueTree.yarnData = content;\n          try {\n            gdjs.dialogueTree.runner.load(gdjs.dialogueTree.yarnData);\n          } catch (error) {\n            logger.error(\n              'An error happened while loading parsing the dialogue tree data:',\n              error\n            );\n          }\n          if (startDialogueNode && startDialogueNode.length > 0) {\n            gdjs.dialogueTree.startFrom(startDialogueNode);\n          }\n        }\n      });\n  };\n\n  /**\n   * Stop the currently running dialogue\n   */\n  gdjs.dialogueTree.stopRunningDialogue = function () {\n    if (this.dialogueIsRunning) {\n      this.dialogueIsRunning = false;\n    }\n    if (this.dialogueData) {\n      this.dialogueData = null;\n    }\n    this.dialogueText = '';\n    this.clipTextEnd = 0;\n  };\n\n  /**\n   * Check if the Dialogue Tree is currently parsing data.\n   * For example, you can do things like disabling player movement while talking to a NPC.\n   */\n  gdjs.dialogueTree.isRunning = function () {\n    if (\n      this.dialogueIsRunning &&\n      !this.dialogueData &&\n      this.dialogueText &&\n      this.clipTextEnd >= this.dialogueText.length\n    ) {\n      this.dialogueIsRunning = false;\n    }\n    return this.dialogueIsRunning;\n  };\n\n  /**\n   * Scroll the clipped text. This can be combined with a timer and user input to control how fast the dialogue line text is scrolling.\n   */\n  gdjs.dialogueTree.scrollClippedText = function () {\n    if (this.pauseScrolling || !this.dialogueIsRunning) {\n      return;\n    }\n\n    // Autoscroll commands so the user doesn't have to press again.\n    if (\n      gdjs.dialogueTree._isLineTypeCommand() &&\n      this.dialogueDataType === 'text' &&\n      this.dialogueBranchTitle === this.dialogueData.data.title &&\n      this.lineNum === this.dialogueData.lineNum &&\n      gdjs.dialogueTree.hasClippedScrollingCompleted()\n    ) {\n      gdjs.dialogueTree.goToNextDialogueLine();\n      return;\n    }\n\n    // Increment scrolling of clipped text\n    if (\n      this.dialogueText &&\n      this.dialogueDataType === 'text' &&\n      this.clipTextEnd < this.dialogueText.length\n    ) {\n      this.clipTextEnd += 1;\n    }\n  };\n\n  /**\n   * Scroll the clipped text to its end, so the entire text is printed. This can be useful in keeping the event sheet logic simpler, while supporting more variation.\n   */\n  gdjs.dialogueTree.completeClippedTextScrolling = function () {\n    if (\n      this.pauseScrolling ||\n      !this.dialogueIsRunning ||\n      !this.dialogueText ||\n      this.dialogueDataType !== 'text'\n    ) {\n      return;\n    }\n    this.clipTextEnd = this.dialogueText.length;\n  };\n\n  /**\n   * Check if text scrolling has completed.\n   * Useful to prevent the user from skipping to next line before the current one has been printed fully.\n   */\n  gdjs.dialogueTree.hasClippedScrollingCompleted = function () {\n    if (!this.dialogueIsRunning || this.dialogueDataType === '') {\n      return false;\n    }\n    if (\n      this.dialogueData &&\n      this.dialogueText.length > 0 &&\n      this.clipTextEnd >= this.dialogueText.length\n    ) {\n      if (gdjs.dialogueTree.getVariable('debug')) {\n        logger.warn(\n          'Scroll completed:',\n          this.clipTextEnd,\n          '/',\n          this.dialogueText.length\n        );\n      }\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * Get the current dialogue line with a scrolling effect (recommended).\n   * Used with the scrollClippedText to achieve a classic scrolling text, as well as any <<wait>> effects to pause scrolling.\n   */\n  gdjs.dialogueTree.getClippedLineText = function () {\n    return this.dialogueIsRunning && this.dialogueText.length\n      ? this.dialogueText.substring(0, this.clipTextEnd + 1)\n      : '';\n  };\n\n  /**\n   * Get the current complete dialogue line without using any scrolling effects.\n   * Note that using this instead getClippedLineText will skip any <<wait>> commands entirely.\n   */\n  gdjs.dialogueTree.getLineText = function () {\n    return this.dialogueIsRunning && this.dialogueText.length\n      ? this.dialogueText\n      : '';\n  };\n\n  /**\n   * Get the number of command parameters in a command with parameters that has been caught by a isCommandCalled condition\n   */\n  gdjs.dialogueTree.commandParametersCount = function () {\n    if (this.commandParameters && this.commandParameters.length > 1) {\n      return this.commandParameters.length - 1;\n    }\n    return 0;\n  };\n\n  /**\n   * Get a command parameter in any command with parameters that has been caught by a isCommandCalled condition\n   * @param paramIndex The index of the parameter to get.\n   */\n  gdjs.dialogueTree.getCommandParameter = function (paramIndex: float) {\n    if (paramIndex === -1 && this.commandParameters.length > 0) {\n      return this.commandParameters[0];\n    }\n    if (\n      this.commandParameters &&\n      this.commandParameters.length >= paramIndex + 1\n    ) {\n      const returnedParam = this.commandParameters[paramIndex + 1];\n      return returnedParam ? returnedParam : '';\n    }\n    return '';\n  };\n\n  /**\n   * Catch <<commands>> and <<commands with parameters>> from the current Dialogue Line.\n   * You can trigger custom logic that relate to the story you are telling during the dialogue.\n   *\n   * @param command The command you want to check for being called. Write it without the `<<>>`.\n   */\n  gdjs.dialogueTree.isCommandCalled = function (command: string) {\n    if (!this.dialogueIsRunning) {\n      return false;\n    }\n    const commandCalls = gdjs.dialogueTree.commandCalls;\n    const clipTextEnd = gdjs.dialogueTree.clipTextEnd;\n    const dialogueText = gdjs.dialogueTree.dialogueText;\n    if (this.pauseScrolling || !commandCalls) {\n      return false;\n    }\n    return this.commandCalls.some(function (call, index) {\n      if (clipTextEnd !== 0 && clipTextEnd < call.time) {\n        return false;\n      }\n      if (\n        call.cmd === 'wait' &&\n        (clipTextEnd === 0 || clipTextEnd !== dialogueText.length)\n      ) {\n        gdjs.dialogueTree.pauseScrolling = true;\n        setTimeout(function () {\n          gdjs.dialogueTree.pauseScrolling = false;\n          commandCalls.splice(index, 1);\n          if (gdjs.dialogueTree.getVariable('debug')) {\n            logger.info('CMD:', call);\n          }\n        }, parseInt(call.params[1], 10));\n      }\n      if (call.cmd === command) {\n        gdjs.dialogueTree.commandParameters = call.params;\n        commandCalls.splice(index, 1);\n        if (gdjs.dialogueTree.getVariable('debug')) {\n          logger.info('CMD:', call);\n        }\n        return true;\n      }\n    });\n  };\n\n  /**\n   * Internal method to allow for capping option selection.\n   */\n  gdjs.dialogueTree._normalizedOptionIndex = function (optionIndex) {\n    if (optionIndex >= this.options.length) {\n      optionIndex = this.options.length - 1;\n    }\n    if (optionIndex < 0) {\n      optionIndex = 0;\n    }\n    return optionIndex;\n  };\n\n  /**\n   * Internal method to allow for cycling option selection.\n   */\n  gdjs.dialogueTree._cycledOptionIndex = function (optionIndex) {\n    if (optionIndex >= this.options.length) {\n      optionIndex = 0;\n    }\n    if (optionIndex < 0) {\n      optionIndex = this.options.length - 1;\n    }\n    return optionIndex;\n  };\n\n  /**\n   * Get the text of an option the player can select.\n   * Used with getLineOptionsCount to render options for the player when a line of the Options type is parsed\n   * @param optionIndex The index of the option you want to get\n   */\n  gdjs.dialogueTree.getLineOption = function (optionIndex: float) {\n    if (!this.dialogueIsRunning || !this.options.length) {\n      return [];\n    }\n    optionIndex = gdjs.dialogueTree._normalizedOptionIndex(optionIndex);\n    return this.options[optionIndex];\n  };\n\n  /**\n   * Get the text of the options the player can select, along with the selection cursor.\n   * @param optionSelectionCursor The string used to draw the currently selected option's cursor\n   * @param addNewLine when true each option is rendered on a new line.\n   */\n  gdjs.dialogueTree.getLineOptionsText = function (\n    optionSelectionCursor: string,\n    addNewLine: boolean\n  ) {\n    if (!this.dialogueIsRunning || !this.options.length) {\n      return '';\n    }\n    let textResult = '';\n    this.options.forEach(function (optionText, index) {\n      if (index === gdjs.dialogueTree.selectedOption) {\n        textResult += optionSelectionCursor;\n      } else {\n        textResult += optionSelectionCursor.replace(/.*/g, ' ');\n      }\n      textResult += optionText;\n      if (addNewLine) {\n        textResult += '\\n';\n      }\n    });\n    return textResult;\n  };\n  gdjs.dialogueTree.getLineOptionsTextHorizontal = function (\n    optionSelectionCursor\n  ) {\n    return this.getLineOptionsText(optionSelectionCursor, false);\n  };\n  gdjs.dialogueTree.getLineOptionsTextVertical = function (\n    optionSelectionCursor\n  ) {\n    return this.getLineOptionsText(optionSelectionCursor, true);\n  };\n\n  /**\n   * Get the number of options that are presented to the player, during the parsing of an Options type line.\n   * @returns The number of options\n   */\n  gdjs.dialogueTree.getLineOptionsCount = function (): number {\n    if (this.dialogueIsRunning && this.options.length) {\n      return this.optionsCount;\n    }\n    return 0;\n  };\n\n  /**\n   * Confirm the currently selected option, during the parsing of an Options type line.\n   *\n   * This will advance the dialogue tree to the dialogue branch was selected by the player.\n   */\n  gdjs.dialogueTree.confirmSelectOption = function () {\n    if (!this.dialogueIsRunning) {\n      return;\n    }\n    if (\n      this.dialogueData.select &&\n      !this.selectedOptionUpdated &&\n      this.selectedOption !== -1\n    ) {\n      this.commandCalls = [];\n      try {\n        this.dialogueData.select(this.selectedOption);\n        this.dialogueData = this.dialogue.next().value;\n        gdjs.dialogueTree.goToNextDialogueLine();\n      } catch (error) {\n        logger.error(\n          `An error happened when trying to access the dialogue branch!`,\n          error\n        );\n      }\n    }\n  };\n\n  /**\n   * Select next option during Options type line parsing. Hook this to your game input.\n   */\n  gdjs.dialogueTree.selectNextOption = function () {\n    if (!this.dialogueIsRunning) {\n      return;\n    }\n    if (this.dialogueData.select) {\n      this.selectedOption += 1;\n      this.selectedOption = gdjs.dialogueTree._cycledOptionIndex(\n        this.selectedOption\n      );\n      this.selectedOptionUpdated = true;\n    }\n  };\n\n  /**\n   * Select previous option during Options type line parsing. Hook this to your game input.\n   */\n  gdjs.dialogueTree.selectPreviousOption = function () {\n    if (!this.dialogueIsRunning) {\n      return;\n    }\n    if (this.dialogueData.select) {\n      this.selectedOption -= 1;\n      this.selectedOption = gdjs.dialogueTree._cycledOptionIndex(\n        this.selectedOption\n      );\n      this.selectedOptionUpdated = true;\n    }\n  };\n\n  /**\n   * Select option by index during Options type line parsing.\n   * @param optionIndex The index of the option to select\n   */\n  gdjs.dialogueTree.selectOption = function (optionIndex: float) {\n    if (!this.dialogueIsRunning) {\n      return;\n    }\n    if (this.dialogueData.select) {\n      this.selectedOption = gdjs.dialogueTree._normalizedOptionIndex(\n        optionIndex\n      );\n      this.selectedOptionUpdated = true;\n    }\n  };\n\n  /**\n   * Get the currently selected option\n   * @returns The index of the currently selected option\n   */\n  gdjs.dialogueTree.getSelectedOption = function (): number {\n    if (!this.dialogueIsRunning) {\n      return;\n    }\n    if (this.dialogueData.select) {\n      return this.selectedOption;\n    }\n    return 0;\n  };\n\n  /**\n   * Check when the player has changed option selection since the last call to this function.\n   *\n   * Can be used to re-render your displayed dialogue options when needed.\n   *\n   * @returns true if the selected option was updated since the last call to this function\n   */\n  gdjs.dialogueTree.hasSelectedOptionChanged = function (): boolean {\n    if (this.selectedOptionUpdated) {\n      this.selectedOptionUpdated = false;\n      if (this.selectedOption === -1) {\n        this.selectedOption = 0;\n      }\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * Check the type of the Dialogue Line that is being displayed to the player at the moment.\n   *\n   * There are three types:\n   * - text - regular dialogue text is being parsed at the moment\n   * - options - the player has reached a branching choice moment where they must select one of multiple options\n   * - command - a <<command>> was called in the background, that can be used to trigger game events, but will not be displayed in the dialogue box.\n   *\n   * @param type The type you want to check for ( one of the three above )\n   */\n  gdjs.dialogueTree.isDialogueLineType = function (type: string) {\n    if (!this.dialogueIsRunning) {\n      return false;\n    }\n    if (this.commandCalls && type === 'command') {\n      if (\n        this.commandCalls.some(function (call) {\n          return (\n            gdjs.dialogueTree.clipTextEnd > call.time && call.cmd === 'wait'\n          );\n        })\n      ) {\n        return !this.pauseScrolling;\n      }\n      if (this.commandCalls.length > 0 && this.commandParameters.length > 0) {\n        return true;\n      }\n    }\n    return this.dialogueDataType === type;\n  };\n\n  /**\n   * Check if a branch exists. It is also used internally whenever you use the start from action.\n   * @param branchName The Dialogue Branch name you want to check.\n   */\n  gdjs.dialogueTree.hasDialogueBranch = function (branchName: string) {\n    return (\n      this.runner &&\n      this.runner.yarnNodes &&\n      Object.keys(this.runner.yarnNodes).some(function (node) {\n        return node === branchName;\n      })\n    );\n  };\n\n  /**\n   * Start parsing dialogue from a specified Dialogue tree branch.\n   * Can be used if you want to store multiple dialogues inside a single Dialogue tree data set.\n   * @param startDialogueNode The Dialogue Branch name you want to start parsing from.\n   */\n  gdjs.dialogueTree.startFrom = function (startDialogueNode: string) {\n    this.runner = gdjs.dialogueTree.runner;\n    if (!this.hasDialogueBranch(startDialogueNode)) {\n      return;\n    }\n    this.optionsCount = 0;\n    this.options = [];\n    this.tagParameters = [];\n    this.dialogue = this.runner.run(startDialogueNode);\n    this.dialogueText = '';\n    this.clipTextEnd = 0;\n    this.commandCalls = [];\n    this.commandParameters = [];\n    this.pauseScrolling = false;\n    this.dialogueData = this.dialogue.next().value;\n    this.dialogueBranchTags = this.dialogueData.data.tags;\n    this.dialogueBranchTitle = this.dialogueData.data.title;\n    this.dialogueBranchBody = this.dialogueData.data.body;\n    this.lineNum = this.dialogueData.lineNum;\n    if (gdjs.dialogueTree._isLineTypeText()) {\n      this.dialogueDataType = 'text';\n    } else {\n      if (gdjs.dialogueTree._isLineTypeOptions()) {\n        this.dialogueDataType = 'options';\n      } else {\n        this.dialogueDataType = 'command';\n      }\n    }\n    this.dialogueIsRunning = true;\n    gdjs.dialogueTree.goToNextDialogueLine();\n  };\n\n  /**\n   * Internal methods to check the type of a Dialogue Line\n   */\n  gdjs.dialogueTree._isLineTypeText = function () {\n    return this.dialogueData instanceof bondage.TextResult;\n  };\n  gdjs.dialogueTree._isLineTypeOptions = function () {\n    return this.dialogueData instanceof bondage.OptionsResult;\n  };\n  gdjs.dialogueTree._isLineTypeCommand = function () {\n    return this.dialogueData instanceof bondage.CommandResult;\n  };\n\n  /**\n   * This is the main lifecycle function.It runs once only when the user is advancing the dialogue to the next line.\n   * Progress Dialogue to the next line. Hook it to your game input.\n   * Note that this action can be influenced by any <<wait>> commands, but they work only if you have at least one isCommandCalled condition.\n   */\n  gdjs.dialogueTree.goToNextDialogueLine = function () {\n    if (this.pauseScrolling || !this.dialogueIsRunning) {\n      return;\n    }\n    this.optionsCount = 0;\n    this.selectedOption = -1;\n    this.selectedOptionUpdated = false;\n    if (gdjs.dialogueTree.getVariable('debug')) {\n      logger.info('Parsing:', this.dialogueData);\n    }\n    if (!this.dialogueData) {\n      gdjs.dialogueTree.stopRunningDialogue();\n    } else {\n      if (gdjs.dialogueTree._isLineTypeText()) {\n        if (\n          this.lineNum === this.dialogueData.lineNum &&\n          this.dialogueBranchTitle === this.dialogueData.data.title\n        ) {\n          this.clipTextEnd = this.dialogueText.length - 1;\n          this.dialogueText +=\n            (this.dialogueText === '' ? '' : ' ') + this.dialogueData.text;\n        } else {\n          this.clipTextEnd = 0;\n          this.dialogueText = this.dialogueData.text;\n        }\n        this.dialogueBranchTags = this.dialogueData.data.tags;\n        this.dialogueBranchTitle = this.dialogueData.data.title;\n        this.dialogueBranchBody = this.dialogueData.data.body;\n        this.lineNum = this.dialogueData.lineNum;\n        this.dialogueDataType = 'text';\n        this.dialogueData = this.dialogue.next().value;\n      } else {\n        if (gdjs.dialogueTree._isLineTypeOptions()) {\n          this.commandCalls = [];\n          this.dialogueDataType = 'options';\n          this.dialogueText = '';\n          this.clipTextEnd = 0;\n          this.optionsCount = this.dialogueData.options.length;\n          this.options = this.dialogueData.options;\n          this.selectedOptionUpdated = true;\n        } else {\n          if (gdjs.dialogueTree._isLineTypeCommand()) {\n            this.dialogueDataType = 'command';\n            const command = this.dialogueData.text.split(' ');\n\n            // If last command was to wait, increase time by one\n            const offsetTime =\n              this.commandCalls.length &&\n              this.commandCalls[this.commandCalls.length - 1].cmd === 'wait'\n                ? 1\n                : 0;\n            this.commandCalls.push({\n              cmd: command[0],\n              params: command,\n              time: this.dialogueText.length + offsetTime,\n            });\n            this.dialogueData = this.dialogue.next().value;\n            gdjs.dialogueTree.goToNextDialogueLine();\n          } else {\n            this.dialogueDataType = 'unknown';\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Get the current Dialogue Tree branch title.\n   * @returns The current branch title.\n   */\n  gdjs.dialogueTree.getBranchTitle = function (): string {\n    if (this.dialogueIsRunning) {\n      return this.dialogueBranchTitle;\n    }\n    return '';\n  };\n\n  /**\n   * Check if the currently parsed Dialogue branch title is a  query.\n   * @param title The Dialogue Branch name you want to check for.\n   */\n  gdjs.dialogueTree.branchTitleIs = function (title: string) {\n    if (this.dialogueIsRunning) {\n      return this.dialogueBranchTitle === title;\n    }\n    return false;\n  };\n\n  /**\n   * Get all the branch tags from the current Dialogue branch as a string. Useful for debugging.\n   * @returns The current branch tags, separated by a comma.\n   */\n  gdjs.dialogueTree.getBranchTags = function (): string {\n    if (this.dialogueIsRunning) {\n      return this.dialogueBranchTags.join(',');\n    }\n    return '';\n  };\n\n  /**\n   * Get one of the current Dialogue branch tags via index.\n   * @param index The index of the Dialogue Branch tag you want to get.\n   * @returns The branch tag at the specified index, or an empty string if not found.\n   */\n  gdjs.dialogueTree.getBranchTag = function (index: float): string {\n    if (this.dialogueIsRunning && this.dialogueBranchTags.length) {\n      if (index > this.dialogueBranchTags.length - 1) {\n        index = this.dialogueBranchTags.length - 1;\n      }\n      return this.dialogueBranchTags[index];\n    }\n    return '';\n  };\n\n  /**\n   * Check if the current Dialogue branch contains a specific tag.\n   * @param query The name of the Dialogue Branch tag you want to check.\n   */\n  gdjs.dialogueTree.branchContainsTag = function (query: string) {\n    this.tagParameters = [];\n    if (this.dialogueIsRunning && this.dialogueBranchTags.length) {\n      return this.dialogueBranchTags.some(function (tag) {\n        const splitTag = tag.match(/([^\\(]+)\\(([^\\)]+)\\)/i);\n        gdjs.dialogueTree.tagParameters = splitTag\n          ? splitTag[2].split(',')\n          : [];\n        return splitTag ? splitTag[1] === query : tag === query;\n      });\n    }\n    return false;\n  };\n\n  /**\n   * Get any tag(parameter,anotherParameter) from a tag captured by the branchContainsTag Condition\n   * @param paramIndex The index of the tag parameter you want to get.\n   * Leaving this empty will result in retrieving the first parameter.\n   */\n  gdjs.dialogueTree.getTagParameter = function (paramIndex: float) {\n    if (this.dialogueIsRunning && this.tagParameters.length >= paramIndex) {\n      const returnedParam = this.tagParameters[paramIndex];\n      return returnedParam ? returnedParam : '';\n    }\n    return '';\n  };\n\n  /**\n   * Get a list of all the titles of visited by the player Branches. Useful for debugging.\n   */\n  gdjs.dialogueTree.getVisitedBranchTitles = function () {\n    if (this.dialogueIsRunning) {\n      return Object.keys(this.runner.visited).join(',');\n    }\n    return '';\n  };\n\n  /**\n   * Check if a player has visited a Dialogue Branch in the past.\n   * @param title The title of the branch to check for.\n   * Leaving this empty will check if the current branch title has been visited in the past.\n   */\n  gdjs.dialogueTree.branchTitleHasBeenVisited = function (title: string) {\n    if (!title) {\n      title = this.dialogueBranchTitle;\n    }\n    return (\n      Object.keys(this.runner.visited).includes(title) &&\n      this.runner.visited[title]\n    );\n  };\n\n  /**\n   * Get the entire unparsed text of the current Dialogue Branch\n   */\n  gdjs.dialogueTree.getBranchText = function () {\n    if (this.dialogueIsRunning) {\n      return this.dialogueBranchBody;\n    }\n    return '';\n  };\n\n  /**\n   * Get the value of a variable that was created by the Dialogue parses.\n   * @param key The name of the variable you want to get the value of\n   */\n  gdjs.dialogueTree.getVariable = function (key: string) {\n    if (this.runner.variables && key in this.runner.variables.data) {\n      return this.runner.variables.get(key);\n    }\n    return '';\n  };\n\n  /**\n   * Check if a specific variable created by the Dialogue parses exists and is equal to a specific value.\n   * @param key The name of the variable you want to check the value of\n   * @param value The value you want to check against\n   */\n  gdjs.dialogueTree.compareVariable = function (\n    key: string,\n    value: string | boolean | number\n  ) {\n    if (this.runner.variables && key in this.runner.variables.data) {\n      return this.runner.variables.get(key) === value;\n    }\n    return false;\n  };\n\n  /**\n   * Set a specific variable created by the Dialogue parser to a specific value.\n   * @param key The name of the variable you want to set the value of\n   * @param value The value you want to set\n   */\n  gdjs.dialogueTree.setVariable = function (\n    key: string,\n    value: string | boolean | number\n  ) {\n    if (this.runner.variables) {\n      this.runner.variables.set(key, value);\n    }\n  };\n\n  /**\n   * Store the current State of the Dialogue Parser in a specified variable.\n   * Can be used to implement persistence in dialogue through your game's Load/Save function.\n   * That way you can later load all the dialogue choices the player has made.\n   * @param outputVariable The variable where to store the State\n   */\n  gdjs.dialogueTree.saveState = function (outputVariable: gdjs.Variable) {\n    const dialogueState = {\n      variables: gdjs.dialogueTree.runner.variables.data,\n      visited: gdjs.dialogueTree.runner.visited,\n    };\n    outputVariable.fromJSObject(dialogueState);\n  };\n\n  /**\n   * Load the current State of the Dialogue Parser from a specified variable.\n   * Can be used to implement persistence in dialogue through your game's Load/Save function.\n   * That way you can later load all the dialogue choices the player has made.\n   * @param inputVariable The structured variable where to load the State from.\n   */\n  gdjs.dialogueTree.loadState = function (inputVariable: gdjs.Variable) {\n    const loadedState = inputVariable.toJSObject();\n    if (!loadedState) {\n      logger.error('Load state variable is empty:', inputVariable);\n      return;\n    }\n    try {\n      gdjs.dialogueTree.runner.visited = loadedState.visited;\n      gdjs.dialogueTree.runner.variables.data = {};\n      Object.keys(loadedState.variables).forEach(function (key) {\n        const value = loadedState.variables[key];\n        gdjs.dialogueTree.runner.variables.set(key, value);\n      });\n    } catch (e) {\n      logger.error('Failed to load state from variable:', inputVariable, e);\n    }\n  };\n\n  /**\n   * Clear the current State of the Dialogue Parser.\n   */\n  gdjs.dialogueTree.clearState = function () {\n    gdjs.dialogueTree.runner.visited = {};\n    gdjs.dialogueTree.runner.variables.data = {};\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
