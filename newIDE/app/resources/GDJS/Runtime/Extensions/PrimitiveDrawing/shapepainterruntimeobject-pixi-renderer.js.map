{
  "version": 3,
  "sources": ["../../../../../../../Extensions/PrimitiveDrawing/shapepainterruntimeobject-pixi-renderer.ts"],
  "sourcesContent": ["namespace gdjs {\n  import PIXI = GlobalPIXIModule.PIXI;\n\n  class ShapePainterRuntimeObjectPixiRenderer {\n    _object: gdjs.ShapePainterRuntimeObject;\n    _graphics: PIXI.Graphics;\n    /**\n     * Graphics positions can need updates when shapes are added,\n     * this avoids to do it each time.\n     */\n    _positionXIsUpToDate = false;\n    /**\n     * Graphics positions can need updates when shapes are added,\n     * this avoids to do it each time.\n     */\n    _positionYIsUpToDate = false;\n    /**\n     * This allows to use the transformation of the renderer\n     * and compute it only when necessary.\n     */\n    _transformationIsUpToDate = false;\n\n    _antialiasingFilter: null | PIXI.Filter = null;\n\n    private static readonly _positionForTransformation: PIXI.IPointData = {\n      x: 0,\n      y: 0,\n    };\n\n    constructor(\n      runtimeObject: gdjs.ShapePainterRuntimeObject,\n      instanceContainer: gdjs.RuntimeInstanceContainer\n    ) {\n      this._object = runtimeObject;\n      this._graphics = new PIXI.Graphics();\n      instanceContainer\n        .getLayer('')\n        .getRenderer()\n        .addRendererObject(this._graphics, runtimeObject.getZOrder());\n      this.updateAntialiasing();\n    }\n\n    getRendererObject() {\n      return this._graphics;\n    }\n\n    clear() {\n      this._graphics.clear();\n      this.invalidateBounds();\n    }\n\n    drawRectangle(x1: float, y1: float, x2: float, y2: float) {\n      this.updateOutline();\n      this._graphics.beginFill(\n        this._object._fillColor,\n        this._object._fillOpacity / 255\n      );\n      this._graphics.drawRect(x1, y1, x2 - x1, y2 - y1);\n      this._graphics.endFill();\n      this.invalidateBounds();\n    }\n\n    drawCircle(x: float, y: float, radius: float) {\n      this.updateOutline();\n      this._graphics.beginFill(\n        this._object._fillColor,\n        this._object._fillOpacity / 255\n      );\n      this._graphics.drawCircle(x, y, radius);\n      this._graphics.endFill();\n      this.invalidateBounds();\n    }\n\n    drawLine(x1: float, y1: float, x2: float, y2: float, thickness: float) {\n      this._graphics.beginFill(\n        this._object._fillColor,\n        this._object._fillOpacity / 255\n      );\n      if (y2 === y1) {\n        this._graphics.drawRect(x1, y1 - thickness / 2, x2 - x1, thickness);\n      } else {\n        const angle = Math.atan2(y2 - y1, x2 - x1);\n        const xIncrement = Math.sin(angle) * thickness;\n        const yIncrement = Math.cos(angle) * thickness;\n        this._graphics.drawPolygon(\n          x1 + xIncrement,\n          y1 - yIncrement,\n          x1 - xIncrement,\n          y1 + yIncrement,\n          x2 - xIncrement,\n          y2 + yIncrement,\n          x2 + xIncrement,\n          y2 - yIncrement\n        );\n      }\n      this._graphics.endFill();\n      this.invalidateBounds();\n    }\n\n    drawLineV2(x1: float, y1: float, x2: float, y2: float, thickness: float) {\n      this._graphics.lineStyle(\n        thickness,\n        this._object._outlineColor,\n        this._object._outlineOpacity / 255\n      );\n      this._graphics.moveTo(x1, y1);\n      this._graphics.lineTo(x2, y2);\n      this._graphics.endFill();\n      this.invalidateBounds();\n    }\n\n    drawEllipse(x1: float, y1: float, width: float, height: float) {\n      this.updateOutline();\n      this._graphics.beginFill(\n        this._object._fillColor,\n        this._object._fillOpacity / 255\n      );\n      this._graphics.drawEllipse(x1, y1, width / 2, height / 2);\n      this._graphics.endFill();\n      this.invalidateBounds();\n    }\n\n    drawRoundedRectangle(\n      x1: float,\n      y1: float,\n      x2: float,\n      y2: float,\n      radius: float\n    ) {\n      this.updateOutline();\n      this._graphics.beginFill(\n        this._object._fillColor,\n        this._object._fillOpacity / 255\n      );\n      this._graphics.drawRoundedRect(x1, y1, x2 - x1, y2 - y1, radius);\n      this._graphics.closePath();\n      this._graphics.endFill();\n      this.invalidateBounds();\n    }\n\n    drawStar(\n      x1: float,\n      y1: float,\n      points: float,\n      radius: float,\n      innerRadius: float,\n      rotation: float\n    ) {\n      this.updateOutline();\n      this._graphics.beginFill(\n        this._object._fillColor,\n        this._object._fillOpacity / 255\n      );\n      //@ts-ignore from @pixi/graphics-extras\n      this._graphics.drawStar(\n        x1,\n        y1,\n        points,\n        radius,\n        innerRadius ? innerRadius : radius / 2,\n        rotation ? gdjs.toRad(rotation) : 0\n      );\n      this._graphics.closePath();\n      this._graphics.endFill();\n      this.invalidateBounds();\n    }\n\n    drawArc(\n      x1: float,\n      y1: float,\n      radius: float,\n      startAngle: float,\n      endAngle: float,\n      anticlockwise: boolean,\n      closePath: boolean\n    ) {\n      this.updateOutline();\n      this._graphics.beginFill(\n        this._object._fillColor,\n        this._object._fillOpacity / 255\n      );\n      this._graphics.moveTo(\n        x1 + radius * Math.cos(gdjs.toRad(startAngle)),\n        y1 + radius * Math.sin(gdjs.toRad(startAngle))\n      );\n      this._graphics.arc(\n        x1,\n        y1,\n        radius,\n        gdjs.toRad(startAngle),\n        gdjs.toRad(endAngle),\n        anticlockwise ? true : false\n      );\n      if (closePath) {\n        this._graphics.closePath();\n      }\n      this._graphics.endFill();\n      this.invalidateBounds();\n    }\n\n    drawBezierCurve(\n      x1: float,\n      y1: float,\n      cpX: float,\n      cpY: float,\n      cpX2: float,\n      cpY2: float,\n      x2: float,\n      y2: float\n    ) {\n      this.updateOutline();\n      this._graphics.beginFill(\n        this._object._fillColor,\n        this._object._fillOpacity / 255\n      );\n      this._graphics.moveTo(x1, y1);\n      this._graphics.bezierCurveTo(cpX, cpY, cpX2, cpY2, x2, y2);\n      this._graphics.endFill();\n      this.invalidateBounds();\n    }\n\n    drawQuadraticCurve(\n      x1: float,\n      y1: float,\n      cpX: float,\n      cpY: float,\n      x2: float,\n      y2: float\n    ) {\n      this.updateOutline();\n      this._graphics.beginFill(\n        this._object._fillColor,\n        this._object._fillOpacity / 255\n      );\n      this._graphics.moveTo(x1, y1);\n      this._graphics.quadraticCurveTo(cpX, cpY, x2, y2);\n      this._graphics.endFill();\n      this.invalidateBounds();\n    }\n\n    beginFillPath() {\n      this.updateOutline();\n      this._graphics.beginFill(\n        this._object._fillColor,\n        this._object._fillOpacity / 255\n      );\n    }\n\n    endFillPath() {\n      this._graphics.endFill();\n      this.invalidateBounds();\n    }\n\n    drawPathMoveTo(x1: float, y1: float) {\n      this._graphics.moveTo(x1, y1);\n    }\n\n    drawPathLineTo(x1: float, y1: float) {\n      this._graphics.lineTo(x1, y1);\n      this.invalidateBounds();\n    }\n\n    drawPathBezierCurveTo(\n      cpX: float,\n      cpY: float,\n      cpX2: float,\n      cpY2: float,\n      toX: float,\n      toY: float\n    ) {\n      this._graphics.bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY);\n      this.invalidateBounds();\n    }\n\n    drawPathArc(\n      x1: float,\n      y1: float,\n      radius: float,\n      startAngle: float,\n      endAngle: float,\n      anticlockwise: boolean\n    ) {\n      this._graphics.arc(\n        x1,\n        y1,\n        radius,\n        gdjs.toRad(startAngle),\n        gdjs.toRad(endAngle),\n        anticlockwise ? true : false\n      );\n      this.invalidateBounds();\n    }\n\n    drawPathQuadraticCurveTo(cpX: float, cpY: float, toX: float, toY: float) {\n      this._graphics.quadraticCurveTo(cpX, cpY, toX, toY);\n      this.invalidateBounds();\n    }\n\n    closePath() {\n      this._graphics.closePath();\n      this.invalidateBounds();\n    }\n\n    updateOutline(): void {\n      this._graphics.lineStyle(\n        this._object._outlineSize,\n        this._object._outlineColor,\n        this._object._outlineOpacity / 255\n      );\n    }\n\n    invalidateBounds() {\n      this._object.invalidateBounds();\n      this._positionXIsUpToDate = false;\n      this._positionYIsUpToDate = false;\n    }\n\n    updatePreRender(): void {\n      this.updatePositionIfNeeded();\n    }\n\n    updatePositionX(): void {\n      if (this._object._useAbsoluteCoordinates) {\n        this._graphics.pivot.x = 0;\n        this._graphics.position.x = 0;\n      } else {\n        // Make the drawing rotate around the rotation center.\n        this._graphics.pivot.x = this._object.getRotationCenterX();\n        // Multiply by the scale to have the scale anchor\n        // at the object position instead of the center.\n        this._graphics.position.x =\n          this._object.x +\n          this._graphics.pivot.x * Math.abs(this._graphics.scale.x);\n      }\n      this._transformationIsUpToDate = false;\n    }\n\n    updatePositionY(): void {\n      if (this._object._useAbsoluteCoordinates) {\n        this._graphics.pivot.y = 0;\n        this._graphics.position.y = 0;\n      } else {\n        this._graphics.pivot.y = this._object.getRotationCenterY();\n        this._graphics.position.y =\n          this._object.y +\n          this._graphics.pivot.y * Math.abs(this._graphics.scale.y);\n      }\n      this._transformationIsUpToDate = false;\n    }\n\n    updatePositionIfNeeded() {\n      if (!this._positionXIsUpToDate) {\n        this.updatePositionX();\n        this._positionXIsUpToDate = true;\n      }\n      if (!this._positionYIsUpToDate) {\n        this.updatePositionY();\n        this._positionYIsUpToDate = true;\n      }\n    }\n\n    updateTransformationIfNeeded() {\n      if (!this._transformationIsUpToDate) {\n        this.updatePositionIfNeeded();\n        this._graphics.updateTransform();\n      }\n      this._transformationIsUpToDate = true;\n    }\n\n    updateRotationCenter(): void {\n      // The pivot and position depends on the rotation center point.\n      this._positionXIsUpToDate = false;\n      this._positionYIsUpToDate = false;\n      // The whole transformation changes based on the rotation center point.\n      this._transformationIsUpToDate = false;\n    }\n\n    updateAngle(): void {\n      if (this._object._useAbsoluteCoordinates) {\n        this._graphics.angle = 0;\n      } else {\n        this._graphics.angle = this._object.angle;\n      }\n      this._transformationIsUpToDate = false;\n    }\n\n    updateScaleX(): void {\n      if (this._object._useAbsoluteCoordinates) {\n        this._graphics.scale.x = 1;\n      } else {\n        this._graphics.scale.x = this._object._scaleX;\n      }\n      // updatePositionX() uses scale.x\n      this._positionXIsUpToDate = false;\n      this._transformationIsUpToDate = false;\n    }\n\n    updateScaleY(): void {\n      if (this._object._useAbsoluteCoordinates) {\n        this._graphics.scale.y = 1;\n      } else {\n        this._graphics.scale.y = this._object._scaleY;\n      }\n      // updatePositionY() uses scale.y\n      this._positionYIsUpToDate = false;\n      this._transformationIsUpToDate = false;\n    }\n\n    getDrawableX(): float {\n      if (this._object._useAbsoluteCoordinates) {\n        return this._graphics.getLocalBounds().left;\n      }\n      let localBound = this._graphics.getLocalBounds().left;\n      if (this._object._flippedX) {\n        const rotationCenterX = this._object.getRotationCenterX();\n        localBound = 2 * rotationCenterX - localBound;\n      }\n      // When new shape are drawn, the bounds of the object can extend.\n      // The object position stays the same but (drawableX; drawableY) can change.\n      return (\n        this._object.getX() + localBound * Math.abs(this._graphics.scale.x)\n      );\n    }\n\n    getDrawableY(): float {\n      if (this._object._useAbsoluteCoordinates) {\n        return this._graphics.getLocalBounds().top;\n      }\n      let localBound = this._graphics.getLocalBounds().top;\n      if (this._object._flippedY) {\n        const rotationCenterY = this._object.getRotationCenterY();\n        localBound = 2 * rotationCenterY - localBound;\n      }\n      return (\n        this._object.getY() + localBound * Math.abs(this._graphics.scale.y)\n      );\n    }\n\n    getWidth(): float {\n      return this._graphics.width;\n    }\n\n    getHeight(): float {\n      return this._graphics.height;\n    }\n\n    getUnscaledWidth(): float {\n      return this._graphics.getLocalBounds().width;\n    }\n\n    getUnscaledHeight(): float {\n      return this._graphics.getLocalBounds().height;\n    }\n\n    /**\n     * @returns The drawing origin relatively to the drawable top left corner.\n     */\n    getFrameRelativeOriginX() {\n      return -this._graphics.getLocalBounds().left;\n    }\n\n    /**\n     * @returns The drawing origin relatively to the drawable top left corner.\n     */\n    getFrameRelativeOriginY() {\n      return -this._graphics.getLocalBounds().top;\n    }\n\n    transformToDrawing(point: FloatPoint): FloatPoint {\n      this.updateTransformationIfNeeded();\n      const position =\n        ShapePainterRuntimeObjectPixiRenderer._positionForTransformation;\n      position.x = point[0];\n      position.y = point[1];\n      this._graphics.localTransform.applyInverse(position, position);\n      point[0] = position.x;\n      point[1] = position.y;\n      return point;\n    }\n\n    transformToScene(point: FloatPoint): FloatPoint {\n      this.updateTransformationIfNeeded();\n      const position =\n        ShapePainterRuntimeObjectPixiRenderer._positionForTransformation;\n      position.x = point[0];\n      position.y = point[1];\n      this._graphics.localTransform.apply(position, position);\n      point[0] = position.x;\n      point[1] = position.y;\n      return point;\n    }\n\n    updateAntialiasing(): void {\n      if (this._object.getAntialiasing() !== 'none') {\n        if (!this._antialiasingFilter) {\n          this._antialiasingFilter = new PIXI.filters.FXAAFilter();\n        }\n\n        const antialiasingFilter = this._antialiasingFilter;\n        antialiasingFilter.enabled = true;\n        antialiasingFilter.multisample =\n          PIXI.MSAA_QUALITY[this._object.getAntialiasing().toUpperCase()] ||\n          PIXI.MSAA_QUALITY.LOW;\n\n        if (!this._graphics.filters) {\n          this._graphics.filters = [];\n        }\n        // Do not apply the filter if it is already present on the object.\n        if (this._graphics.filters.indexOf(antialiasingFilter) === -1) {\n          this._graphics.filters.push(antialiasingFilter);\n        }\n      } else if (this._antialiasingFilter !== null) {\n        if (!this._graphics.filters) {\n          return;\n        }\n        const antialiasingFilterIndex = this._graphics.filters.indexOf(\n          this._antialiasingFilter\n        );\n\n        if (antialiasingFilterIndex !== -1) {\n          this._graphics.filters.splice(antialiasingFilterIndex, 1);\n        }\n      }\n    }\n  }\n\n  export const ShapePainterRuntimeObjectRenderer = ShapePainterRuntimeObjectPixiRenderer;\n  export type ShapePainterRuntimeObjectRenderer = ShapePainterRuntimeObjectPixiRenderer;\n}\n"],
  "mappings": "AAAA,GAAU,MAAV,UAAU,EAAV,CACE,KAAO,GAAO,iBAAiB,KAE/B,OAA4C,CA0B1C,YACE,EACA,EACA,CAtBF,0BAAuB,GAKvB,0BAAuB,GAKvB,+BAA4B,GAE5B,yBAA0C,KAWxC,KAAK,QAAU,EACf,KAAK,UAAY,GAAI,GAAK,SAC1B,EACG,SAAS,IACT,cACA,kBAAkB,KAAK,UAAW,EAAc,aACnD,KAAK,qBAGP,mBAAoB,CAClB,MAAO,MAAK,UAGd,OAAQ,CACN,KAAK,UAAU,QACf,KAAK,mBAGP,cAAc,EAAW,EAAW,EAAW,EAAW,CACxD,KAAK,gBACL,KAAK,UAAU,UACb,KAAK,QAAQ,WACb,KAAK,QAAQ,aAAe,KAE9B,KAAK,UAAU,SAAS,EAAI,EAAI,EAAK,EAAI,EAAK,GAC9C,KAAK,UAAU,UACf,KAAK,mBAGP,WAAW,EAAU,EAAU,EAAe,CAC5C,KAAK,gBACL,KAAK,UAAU,UACb,KAAK,QAAQ,WACb,KAAK,QAAQ,aAAe,KAE9B,KAAK,UAAU,WAAW,EAAG,EAAG,GAChC,KAAK,UAAU,UACf,KAAK,mBAGP,SAAS,EAAW,EAAW,EAAW,EAAW,EAAkB,CAKrE,GAJA,KAAK,UAAU,UACb,KAAK,QAAQ,WACb,KAAK,QAAQ,aAAe,KAE1B,IAAO,EACT,KAAK,UAAU,SAAS,EAAI,EAAK,EAAY,EAAG,EAAK,EAAI,OACpD,CACL,KAAM,GAAQ,KAAK,MAAM,EAAK,EAAI,EAAK,GACjC,EAAa,KAAK,IAAI,GAAS,EAC/B,EAAa,KAAK,IAAI,GAAS,EACrC,KAAK,UAAU,YACb,EAAK,EACL,EAAK,EACL,EAAK,EACL,EAAK,EACL,EAAK,EACL,EAAK,EACL,EAAK,EACL,EAAK,GAGT,KAAK,UAAU,UACf,KAAK,mBAGP,WAAW,EAAW,EAAW,EAAW,EAAW,EAAkB,CACvE,KAAK,UAAU,UACb,EACA,KAAK,QAAQ,cACb,KAAK,QAAQ,gBAAkB,KAEjC,KAAK,UAAU,OAAO,EAAI,GAC1B,KAAK,UAAU,OAAO,EAAI,GAC1B,KAAK,UAAU,UACf,KAAK,mBAGP,YAAY,EAAW,EAAW,EAAc,EAAe,CAC7D,KAAK,gBACL,KAAK,UAAU,UACb,KAAK,QAAQ,WACb,KAAK,QAAQ,aAAe,KAE9B,KAAK,UAAU,YAAY,EAAI,EAAI,EAAQ,EAAG,EAAS,GACvD,KAAK,UAAU,UACf,KAAK,mBAGP,qBACE,EACA,EACA,EACA,EACA,EACA,CACA,KAAK,gBACL,KAAK,UAAU,UACb,KAAK,QAAQ,WACb,KAAK,QAAQ,aAAe,KAE9B,KAAK,UAAU,gBAAgB,EAAI,EAAI,EAAK,EAAI,EAAK,EAAI,GACzD,KAAK,UAAU,YACf,KAAK,UAAU,UACf,KAAK,mBAGP,SACE,EACA,EACA,EACA,EACA,EACA,EACA,CACA,KAAK,gBACL,KAAK,UAAU,UACb,KAAK,QAAQ,WACb,KAAK,QAAQ,aAAe,KAG9B,KAAK,UAAU,SACb,EACA,EACA,EACA,EACA,GAA4B,EAAS,EACrC,EAAW,EAAK,MAAM,GAAY,GAEpC,KAAK,UAAU,YACf,KAAK,UAAU,UACf,KAAK,mBAGP,QACE,EACA,EACA,EACA,EACA,EACA,EACA,EACA,CACA,KAAK,gBACL,KAAK,UAAU,UACb,KAAK,QAAQ,WACb,KAAK,QAAQ,aAAe,KAE9B,KAAK,UAAU,OACb,EAAK,EAAS,KAAK,IAAI,EAAK,MAAM,IAClC,EAAK,EAAS,KAAK,IAAI,EAAK,MAAM,KAEpC,KAAK,UAAU,IACb,EACA,EACA,EACA,EAAK,MAAM,GACX,EAAK,MAAM,GACX,KAEE,GACF,KAAK,UAAU,YAEjB,KAAK,UAAU,UACf,KAAK,mBAGP,gBACE,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,CACA,KAAK,gBACL,KAAK,UAAU,UACb,KAAK,QAAQ,WACb,KAAK,QAAQ,aAAe,KAE9B,KAAK,UAAU,OAAO,EAAI,GAC1B,KAAK,UAAU,cAAc,EAAK,EAAK,EAAM,EAAM,EAAI,GACvD,KAAK,UAAU,UACf,KAAK,mBAGP,mBACE,EACA,EACA,EACA,EACA,EACA,EACA,CACA,KAAK,gBACL,KAAK,UAAU,UACb,KAAK,QAAQ,WACb,KAAK,QAAQ,aAAe,KAE9B,KAAK,UAAU,OAAO,EAAI,GAC1B,KAAK,UAAU,iBAAiB,EAAK,EAAK,EAAI,GAC9C,KAAK,UAAU,UACf,KAAK,mBAGP,eAAgB,CACd,KAAK,gBACL,KAAK,UAAU,UACb,KAAK,QAAQ,WACb,KAAK,QAAQ,aAAe,KAIhC,aAAc,CACZ,KAAK,UAAU,UACf,KAAK,mBAGP,eAAe,EAAW,EAAW,CACnC,KAAK,UAAU,OAAO,EAAI,GAG5B,eAAe,EAAW,EAAW,CACnC,KAAK,UAAU,OAAO,EAAI,GAC1B,KAAK,mBAGP,sBACE,EACA,EACA,EACA,EACA,EACA,EACA,CACA,KAAK,UAAU,cAAc,EAAK,EAAK,EAAM,EAAM,EAAK,GACxD,KAAK,mBAGP,YACE,EACA,EACA,EACA,EACA,EACA,EACA,CACA,KAAK,UAAU,IACb,EACA,EACA,EACA,EAAK,MAAM,GACX,EAAK,MAAM,GACX,KAEF,KAAK,mBAGP,yBAAyB,EAAY,EAAY,EAAY,EAAY,CACvE,KAAK,UAAU,iBAAiB,EAAK,EAAK,EAAK,GAC/C,KAAK,mBAGP,WAAY,CACV,KAAK,UAAU,YACf,KAAK,mBAGP,eAAsB,CACpB,KAAK,UAAU,UACb,KAAK,QAAQ,aACb,KAAK,QAAQ,cACb,KAAK,QAAQ,gBAAkB,KAInC,kBAAmB,CACjB,KAAK,QAAQ,mBACb,KAAK,qBAAuB,GAC5B,KAAK,qBAAuB,GAG9B,iBAAwB,CACtB,KAAK,yBAGP,iBAAwB,CACtB,AAAI,KAAK,QAAQ,wBACf,MAAK,UAAU,MAAM,EAAI,EACzB,KAAK,UAAU,SAAS,EAAI,GAG5B,MAAK,UAAU,MAAM,EAAI,KAAK,QAAQ,qBAGtC,KAAK,UAAU,SAAS,EACtB,KAAK,QAAQ,EACb,KAAK,UAAU,MAAM,EAAI,KAAK,IAAI,KAAK,UAAU,MAAM,IAE3D,KAAK,0BAA4B,GAGnC,iBAAwB,CACtB,AAAI,KAAK,QAAQ,wBACf,MAAK,UAAU,MAAM,EAAI,EACzB,KAAK,UAAU,SAAS,EAAI,GAE5B,MAAK,UAAU,MAAM,EAAI,KAAK,QAAQ,qBACtC,KAAK,UAAU,SAAS,EACtB,KAAK,QAAQ,EACb,KAAK,UAAU,MAAM,EAAI,KAAK,IAAI,KAAK,UAAU,MAAM,IAE3D,KAAK,0BAA4B,GAGnC,wBAAyB,CACvB,AAAK,KAAK,sBACR,MAAK,kBACL,KAAK,qBAAuB,IAEzB,KAAK,sBACR,MAAK,kBACL,KAAK,qBAAuB,IAIhC,8BAA+B,CAC7B,AAAK,KAAK,2BACR,MAAK,yBACL,KAAK,UAAU,mBAEjB,KAAK,0BAA4B,GAGnC,sBAA6B,CAE3B,KAAK,qBAAuB,GAC5B,KAAK,qBAAuB,GAE5B,KAAK,0BAA4B,GAGnC,aAAoB,CAClB,AAAI,KAAK,QAAQ,wBACf,KAAK,UAAU,MAAQ,EAEvB,KAAK,UAAU,MAAQ,KAAK,QAAQ,MAEtC,KAAK,0BAA4B,GAGnC,cAAqB,CACnB,AAAI,KAAK,QAAQ,wBACf,KAAK,UAAU,MAAM,EAAI,EAEzB,KAAK,UAAU,MAAM,EAAI,KAAK,QAAQ,QAGxC,KAAK,qBAAuB,GAC5B,KAAK,0BAA4B,GAGnC,cAAqB,CACnB,AAAI,KAAK,QAAQ,wBACf,KAAK,UAAU,MAAM,EAAI,EAEzB,KAAK,UAAU,MAAM,EAAI,KAAK,QAAQ,QAGxC,KAAK,qBAAuB,GAC5B,KAAK,0BAA4B,GAGnC,cAAsB,CACpB,GAAI,KAAK,QAAQ,wBACf,MAAO,MAAK,UAAU,iBAAiB,KAEzC,GAAI,GAAa,KAAK,UAAU,iBAAiB,KACjD,GAAI,KAAK,QAAQ,UAAW,CAC1B,KAAM,GAAkB,KAAK,QAAQ,qBACrC,EAAa,EAAI,EAAkB,EAIrC,MACE,MAAK,QAAQ,OAAS,EAAa,KAAK,IAAI,KAAK,UAAU,MAAM,GAIrE,cAAsB,CACpB,GAAI,KAAK,QAAQ,wBACf,MAAO,MAAK,UAAU,iBAAiB,IAEzC,GAAI,GAAa,KAAK,UAAU,iBAAiB,IACjD,GAAI,KAAK,QAAQ,UAAW,CAC1B,KAAM,GAAkB,KAAK,QAAQ,qBACrC,EAAa,EAAI,EAAkB,EAErC,MACE,MAAK,QAAQ,OAAS,EAAa,KAAK,IAAI,KAAK,UAAU,MAAM,GAIrE,UAAkB,CAChB,MAAO,MAAK,UAAU,MAGxB,WAAmB,CACjB,MAAO,MAAK,UAAU,OAGxB,kBAA0B,CACxB,MAAO,MAAK,UAAU,iBAAiB,MAGzC,mBAA2B,CACzB,MAAO,MAAK,UAAU,iBAAiB,OAMzC,yBAA0B,CACxB,MAAO,CAAC,KAAK,UAAU,iBAAiB,KAM1C,yBAA0B,CACxB,MAAO,CAAC,KAAK,UAAU,iBAAiB,IAG1C,mBAAmB,EAA+B,CAChD,KAAK,+BACL,KAAM,GACJ,EAAsC,2BACxC,SAAS,EAAI,EAAM,GACnB,EAAS,EAAI,EAAM,GACnB,KAAK,UAAU,eAAe,aAAa,EAAU,GACrD,EAAM,GAAK,EAAS,EACpB,EAAM,GAAK,EAAS,EACb,EAGT,iBAAiB,EAA+B,CAC9C,KAAK,+BACL,KAAM,GACJ,EAAsC,2BACxC,SAAS,EAAI,EAAM,GACnB,EAAS,EAAI,EAAM,GACnB,KAAK,UAAU,eAAe,MAAM,EAAU,GAC9C,EAAM,GAAK,EAAS,EACpB,EAAM,GAAK,EAAS,EACb,EAGT,oBAA2B,CACzB,GAAI,KAAK,QAAQ,oBAAsB,OAAQ,CAC7C,AAAK,KAAK,qBACR,MAAK,oBAAsB,GAAI,GAAK,QAAQ,YAG9C,KAAM,GAAqB,KAAK,oBAChC,EAAmB,QAAU,GAC7B,EAAmB,YACjB,EAAK,aAAa,KAAK,QAAQ,kBAAkB,gBACjD,EAAK,aAAa,IAEf,KAAK,UAAU,SAClB,MAAK,UAAU,QAAU,IAGvB,KAAK,UAAU,QAAQ,QAAQ,KAAwB,IACzD,KAAK,UAAU,QAAQ,KAAK,WAErB,KAAK,sBAAwB,KAAM,CAC5C,GAAI,CAAC,KAAK,UAAU,QAClB,OAEF,KAAM,GAA0B,KAAK,UAAU,QAAQ,QACrD,KAAK,qBAGP,AAAI,IAA4B,IAC9B,KAAK,UAAU,QAAQ,OAAO,EAAyB,MArgB/D,QAqB0B,AArB1B,EAqB0B,2BAA8C,CACpE,EAAG,EACH,EAAG,GAofM,oCAAoC,IA9gBzC",
  "names": []
}
