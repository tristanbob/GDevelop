{
  "version": 3,
  "sources": ["../../../../../../../Extensions/PrimitiveDrawing/shapepainterruntimeobject.ts"],
  "sourcesContent": ["/*\n *  GDevelop JS Platform\n *  2013 Florian Rival (Florian.Rival@gmail.com)\n */\nnamespace gdjs {\n  /** Represents a color in RGB Format */\n  export type RGBColor = {\n    /** The Red component of the color, from 0 to 255. */\n    r: integer;\n    /** The Green component of the color, from 0 to 255. */\n    g: integer;\n    /** The Blue component of the color, from 0 to 255. */\n    b: integer;\n  };\n\n  export type Antialiasing = 'none' | 'low' | 'medium' | 'high';\n\n  /** Initial properties for a for {@link gdjs.ShapePainterRuntimeObject}. */\n  export type ShapePainterObjectDataType = {\n    /** The color (in RGB format) of the inner part of the painted shape */\n    fillColor: RGBColor;\n    /** The color (in RGB format) of the outline of the painted shape */\n    outlineColor: RGBColor;\n    /** The opacity of the inner part of the painted shape, from 0 to 255 */\n    fillOpacity: float;\n    /** The opacity of the outline of the painted shape, from 0 to 255 */\n    outlineOpacity: float;\n    /** The size of the outline of the painted shape, in pixels. */\n    outlineSize: float;\n    /** Use absolute coordinates? */\n    absoluteCoordinates: boolean;\n    /** Clear the previous render before the next draw? */\n    clearBetweenFrames: boolean;\n    /** The type of anti-aliasing to apply at rendering. */\n    antialiasing: Antialiasing;\n  };\n\n  export type ShapePainterObjectData = ObjectData & ShapePainterObjectDataType;\n\n  /**\n   * The ShapePainterRuntimeObject allows to draw graphics shapes on screen.\n   */\n  export class ShapePainterRuntimeObject extends gdjs.RuntimeObject {\n    _scaleX: number = 1;\n    _scaleY: number = 1;\n    _blendMode: number = 0;\n    _flippedX: boolean = false;\n    _flippedY: boolean = false;\n    _customCenter: FloatPoint | null = null;\n    _customCollisionMask: Polygon[] | null = null;\n\n    _fillColor: integer;\n    _outlineColor: integer;\n    _fillOpacity: float;\n    _outlineOpacity: float;\n    _outlineSize: float;\n    _useAbsoluteCoordinates: boolean;\n    _clearBetweenFrames: boolean;\n    _antialiasing: Antialiasing;\n    _renderer: gdjs.ShapePainterRuntimeObjectRenderer;\n\n    private static readonly _pointForTransformation: FloatPoint = [0, 0];\n\n    /**\n     * @param instanceContainer The container the object belongs to.\n     * @param shapePainterObjectData The initial properties of the object\n     */\n    constructor(\n      instanceContainer: gdjs.RuntimeInstanceContainer,\n      shapePainterObjectData: ShapePainterObjectData\n    ) {\n      super(instanceContainer, shapePainterObjectData);\n      this._fillColor = parseInt(\n        gdjs.rgbToHex(\n          shapePainterObjectData.fillColor.r,\n          shapePainterObjectData.fillColor.g,\n          shapePainterObjectData.fillColor.b\n        ),\n        16\n      );\n      this._outlineColor = parseInt(\n        gdjs.rgbToHex(\n          shapePainterObjectData.outlineColor.r,\n          shapePainterObjectData.outlineColor.g,\n          shapePainterObjectData.outlineColor.b\n        ),\n        16\n      );\n      this._fillOpacity = shapePainterObjectData.fillOpacity;\n      this._outlineOpacity = shapePainterObjectData.outlineOpacity;\n      this._outlineSize = shapePainterObjectData.outlineSize;\n      this._useAbsoluteCoordinates = shapePainterObjectData.absoluteCoordinates;\n      this._clearBetweenFrames = shapePainterObjectData.clearBetweenFrames;\n      this._antialiasing = shapePainterObjectData.antialiasing;\n      this._renderer = new gdjs.ShapePainterRuntimeObjectRenderer(\n        this,\n        instanceContainer\n      );\n\n      // *ALWAYS* call `this.onCreated()` at the very end of your object constructor.\n      this.onCreated();\n    }\n\n    getRendererObject() {\n      return this._renderer.getRendererObject();\n    }\n\n    updateFromObjectData(\n      oldObjectData: ShapePainterObjectData,\n      newObjectData: ShapePainterObjectData\n    ): boolean {\n      if (\n        oldObjectData.fillColor.r !== newObjectData.fillColor.r ||\n        oldObjectData.fillColor.g !== newObjectData.fillColor.g ||\n        oldObjectData.fillColor.b !== newObjectData.fillColor.b\n      ) {\n        this.setFillColor(\n          '' +\n            newObjectData.fillColor.r +\n            ';' +\n            newObjectData.fillColor.g +\n            ';' +\n            newObjectData.fillColor.b\n        );\n      }\n      if (\n        oldObjectData.outlineColor.r !== newObjectData.outlineColor.r ||\n        oldObjectData.outlineColor.g !== newObjectData.outlineColor.g ||\n        oldObjectData.outlineColor.b !== newObjectData.outlineColor.b\n      ) {\n        this.setOutlineColor(\n          '' +\n            newObjectData.outlineColor.r +\n            ';' +\n            newObjectData.outlineColor.g +\n            ';' +\n            newObjectData.outlineColor.b\n        );\n      }\n      if (oldObjectData.fillOpacity !== newObjectData.fillOpacity) {\n        this.setFillOpacity(newObjectData.fillOpacity);\n      }\n      if (oldObjectData.outlineOpacity !== newObjectData.outlineOpacity) {\n        this.setOutlineOpacity(newObjectData.outlineOpacity);\n      }\n      if (oldObjectData.outlineSize !== newObjectData.outlineSize) {\n        this.setOutlineSize(newObjectData.outlineSize);\n      }\n      if (\n        oldObjectData.absoluteCoordinates !== newObjectData.absoluteCoordinates\n      ) {\n        this._useAbsoluteCoordinates = newObjectData.absoluteCoordinates;\n        this._renderer.updatePositionX();\n        this._renderer.updatePositionY();\n        this._renderer.updateAngle();\n        this._renderer.updateScaleX();\n        this._renderer.updateScaleY();\n      }\n      if (\n        oldObjectData.clearBetweenFrames !== newObjectData.clearBetweenFrames\n      ) {\n        this._clearBetweenFrames = newObjectData.clearBetweenFrames;\n      }\n      return true;\n    }\n\n    stepBehaviorsPreEvents(instanceContainer: gdjs.RuntimeInstanceContainer) {\n      //We redefine stepBehaviorsPreEvents just to clear the graphics before running events.\n      if (this._clearBetweenFrames) {\n        this.clear();\n      }\n      super.stepBehaviorsPreEvents(instanceContainer);\n    }\n\n    /**\n     * Clear the graphics.\n     */\n    clear() {\n      this._renderer.clear();\n    }\n\n    getVisibilityAABB() {\n      return this._useAbsoluteCoordinates ? null : this.getAABB();\n    }\n\n    drawRectangle(x1: float, y1: float, x2: float, y2: float) {\n      this._renderer.drawRectangle(x1, y1, x2, y2);\n    }\n\n    drawCircle(x: float, y: float, radius: float) {\n      this._renderer.drawCircle(x, y, radius);\n    }\n\n    drawLine(x1: float, y1: float, x2: float, y2: float, thickness: float) {\n      this._renderer.drawLine(x1, y1, x2, y2, thickness);\n    }\n\n    drawLineV2(x1: float, y1: float, x2: float, y2: float, thickness: float) {\n      this._renderer.drawLineV2(x1, y1, x2, y2, thickness);\n    }\n\n    drawEllipse(centerX: float, centerY: float, width: float, height: float) {\n      this._renderer.drawEllipse(centerX, centerY, width, height);\n    }\n\n    drawRoundedRectangle(\n      startX1: float,\n      startY1: float,\n      endX2: float,\n      endY2: float,\n      radius: float\n    ) {\n      this._renderer.drawRoundedRectangle(\n        startX1,\n        startY1,\n        endX2,\n        endY2,\n        radius\n      );\n    }\n\n    drawStar(\n      centerX: float,\n      centerY: float,\n      points: float,\n      radius: float,\n      innerRadius: float,\n      rotation: float\n    ) {\n      this._renderer.drawStar(\n        centerX,\n        centerY,\n        points,\n        radius,\n        innerRadius,\n        rotation\n      );\n    }\n\n    drawArc(\n      centerX: float,\n      centerY: float,\n      radius: float,\n      startAngle: float,\n      endAngle: float,\n      anticlockwise: boolean,\n      closePath: boolean\n    ) {\n      this._renderer.drawArc(\n        centerX,\n        centerY,\n        radius,\n        startAngle,\n        endAngle,\n        anticlockwise,\n        closePath\n      );\n    }\n\n    drawBezierCurve(\n      x1: float,\n      y1: float,\n      cpX: float,\n      cpY: float,\n      cpX2: float,\n      cpY2: float,\n      x2: float,\n      y2: float\n    ) {\n      this._renderer.drawBezierCurve(x1, y1, cpX, cpY, cpX2, cpY2, x2, y2);\n    }\n\n    drawQuadraticCurve(\n      x1: float,\n      y1: float,\n      cpX: float,\n      cpY: float,\n      x2: float,\n      y2: float\n    ) {\n      this._renderer.drawQuadraticCurve(x1, y1, cpX, cpY, x2, y2);\n    }\n\n    beginFillPath(x1: float, y1: float) {\n      this._renderer.beginFillPath();\n      this._renderer.drawPathMoveTo(x1, y1);\n    }\n\n    endFillPath() {\n      this._renderer.endFillPath();\n    }\n\n    drawPathMoveTo(x1: float, y1: float) {\n      this._renderer.drawPathMoveTo(x1, y1);\n    }\n\n    drawPathLineTo(x1: float, y1: float) {\n      this._renderer.drawPathLineTo(x1, y1);\n    }\n\n    drawPathBezierCurveTo(\n      cpX: float,\n      cpY: float,\n      cpX2: float,\n      cpY2: float,\n      toX: float,\n      toY: float\n    ) {\n      this._renderer.drawPathBezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY);\n    }\n\n    drawPathArc(\n      cx: float,\n      cy: float,\n      radius: float,\n      startAngle: float,\n      endAngle: float,\n      anticlockwise: boolean\n    ) {\n      this._renderer.drawPathArc(\n        cx,\n        cy,\n        radius,\n        startAngle,\n        endAngle,\n        anticlockwise\n      );\n    }\n\n    drawPathQuadraticCurveTo(cpX: float, cpY: float, toX: float, toY: float) {\n      this._renderer.drawPathQuadraticCurveTo(cpX, cpY, toX, toY);\n    }\n\n    closePath() {\n      this._renderer.closePath();\n    }\n\n    setClearBetweenFrames(value: boolean): void {\n      this._clearBetweenFrames = value;\n    }\n\n    isClearedBetweenFrames(): boolean {\n      return this._clearBetweenFrames;\n    }\n\n    setAntialiasing(value: Antialiasing): void {\n      this._antialiasing = value;\n      this._renderer.updateAntialiasing();\n    }\n\n    getAntialiasing(): Antialiasing {\n      return this._antialiasing;\n    }\n\n    checkAntialiasing(valueToCompare: Antialiasing): boolean {\n      return this._antialiasing === valueToCompare;\n    }\n\n    setCoordinatesRelative(value: boolean): void {\n      this._useAbsoluteCoordinates = !value;\n    }\n\n    areCoordinatesRelative(): boolean {\n      return !this._useAbsoluteCoordinates;\n    }\n\n    /**\n     *\n     * @param rgbColor semicolon separated decimal values\n     */\n    setFillColor(rgbColor: string): void {\n      const colors = rgbColor.split(';');\n      if (colors.length < 3) {\n        return;\n      }\n      this._fillColor = parseInt(\n        gdjs.rgbToHex(\n          parseInt(colors[0], 10),\n          parseInt(colors[1], 10),\n          parseInt(colors[2], 10)\n        ),\n        16\n      );\n    }\n\n    getFillColorR(): integer {\n      return gdjs.hexNumberToRGB(this._fillColor).r;\n    }\n    getFillColorG(): integer {\n      return gdjs.hexNumberToRGB(this._fillColor).g;\n    }\n    getFillColorB(): integer {\n      return gdjs.hexNumberToRGB(this._fillColor).b;\n    }\n\n    /**\n     *\n     * @param rgbColor semicolon separated decimal values\n     */\n    setOutlineColor(rgbColor: string): void {\n      const colors = rgbColor.split(';');\n      if (colors.length < 3) {\n        return;\n      }\n      this._outlineColor = parseInt(\n        gdjs.rgbToHex(\n          parseInt(colors[0], 10),\n          parseInt(colors[1], 10),\n          parseInt(colors[2], 10)\n        ),\n        16\n      );\n      this._renderer.updateOutline();\n    }\n\n    getOutlineColorR(): integer {\n      return gdjs.hexNumberToRGB(this._outlineColor).r;\n    }\n    getOutlineColorG(): integer {\n      return gdjs.hexNumberToRGB(this._outlineColor).g;\n    }\n    getOutlineColorB(): integer {\n      return gdjs.hexNumberToRGB(this._outlineColor).b;\n    }\n\n    setOutlineSize(size: float): void {\n      this._outlineSize = size;\n      this._renderer.updateOutline();\n    }\n\n    getOutlineSize() {\n      return this._outlineSize;\n    }\n\n    /**\n     *\n     * @param opacity from 0 to 255\n     */\n    setFillOpacity(opacity: float): void {\n      this._fillOpacity = opacity;\n    }\n\n    /**\n     *\n     * @returns an opacity value from 0 to 255.\n     */\n    getFillOpacity() {\n      return this._fillOpacity;\n    }\n\n    /**\n     *\n     * @param opacity from 0 to 255\n     */\n    setOutlineOpacity(opacity: float): void {\n      this._outlineOpacity = opacity;\n      this._renderer.updateOutline();\n    }\n\n    /**\n     *\n     * @returns an opacity value from 0 to 255.\n     */\n    getOutlineOpacity() {\n      return this._outlineOpacity;\n    }\n\n    setX(x: float): void {\n      if (x === this.x) {\n        return;\n      }\n      super.setX(x);\n      this._renderer.updatePositionX();\n    }\n\n    setY(y: float): void {\n      if (y === this.y) {\n        return;\n      }\n      super.setY(y);\n      this._renderer.updatePositionY();\n    }\n\n    setAngle(angle: float): void {\n      if (angle === this.angle) {\n        return;\n      }\n      super.setAngle(angle);\n      this._renderer.updateAngle();\n      this.invalidateHitboxes();\n    }\n\n    /**\n     * The center of rotation is defined relatively\n     * to the drawing origin (the object position).\n     * This avoids the center to move on the drawing\n     * when new shapes push the bounds.\n     *\n     * When no custom center is defined, it will move\n     * to stay at the center of the drawable bounds.\n     *\n     * @param x coordinate of the custom center\n     * @param y coordinate of the custom center\n     */\n    setRotationCenter(x: float, y: float): void {\n      if (!this._customCenter) {\n        this._customCenter = [0, 0];\n      }\n      this._customCenter[0] = x;\n      this._customCenter[1] = y;\n      this._renderer.updateRotationCenter();\n    }\n\n    /**\n     * @returns The center X relatively to the drawing origin\n     * (whereas `getCenterX()` is relative to the top left drawable bound and scaled).\n     */\n    getRotationCenterX(): float {\n      return this._customCenter\n        ? this._customCenter[0]\n        : this._renderer.getUnscaledWidth() / 2 -\n            this._renderer.getFrameRelativeOriginX();\n    }\n\n    /**\n     * @returns The center Y relatively to the drawing origin\n     * (whereas `getCenterY()` is relative to the top left drawable bound and scaled).\n     */\n    getRotationCenterY(): float {\n      return this._customCenter\n        ? this._customCenter[1]\n        : this._renderer.getUnscaledHeight() / 2 -\n            this._renderer.getFrameRelativeOriginY();\n    }\n\n    getCenterX(): float {\n      if (!this._customCenter) {\n        return super.getCenterX();\n      }\n      return (\n        this._customCenter[0] * Math.abs(this._scaleX) +\n        this.getX() -\n        this.getDrawableX()\n      );\n    }\n\n    getCenterY(): float {\n      if (!this._customCenter) {\n        return super.getCenterY();\n      }\n      return (\n        this._customCenter[1] * Math.abs(this._scaleY) +\n        this.getY() -\n        this.getDrawableY()\n      );\n    }\n\n    /**\n     * Change the width of the object. This changes the scale on X axis of the object.\n     *\n     * @param newWidth The new width of the object, in pixels.\n     */\n    setWidth(newWidth: float): void {\n      const unscaledWidth = this._renderer.getUnscaledWidth();\n      if (unscaledWidth !== 0) {\n        this.setScaleX(newWidth / unscaledWidth);\n      }\n    }\n\n    /**\n     * Change the height of the object. This changes the scale on Y axis of the object.\n     *\n     * @param newHeight The new height of the object, in pixels.\n     */\n    setHeight(newHeight: float): void {\n      const unscaledHeight = this._renderer.getUnscaledHeight();\n      if (unscaledHeight !== 0) {\n        this.setScaleY(newHeight / unscaledHeight);\n      }\n    }\n\n    /**\n     * Change the scale on X and Y axis of the object.\n     *\n     * @param newScale The new scale (must be greater than 0).\n     */\n    setScale(newScale: float): void {\n      this.setScaleX(newScale);\n      this.setScaleY(newScale);\n    }\n\n    /**\n     * Change the scale on X axis of the object (changing its width).\n     *\n     * @param newScale The new scale (must be greater than 0).\n     */\n    setScaleX(newScale: float): void {\n      if (newScale < 0) {\n        newScale = 0;\n      }\n      if (newScale === Math.abs(this._scaleX)) {\n        return;\n      }\n      this._scaleX = newScale * (this._flippedX ? -1 : 1);\n      this._renderer.updateScaleX();\n      this.invalidateHitboxes();\n    }\n\n    /**\n     * Change the scale on Y axis of the object (changing its width).\n     *\n     * @param newScale The new scale (must be greater than 0).\n     */\n    setScaleY(newScale: float): void {\n      if (newScale < 0) {\n        newScale = 0;\n      }\n      if (newScale === Math.abs(this._scaleY)) {\n        return;\n      }\n      this._scaleY = newScale * (this._flippedY ? -1 : 1);\n      this._renderer.updateScaleY();\n      this.invalidateHitboxes();\n    }\n\n    flipX(enable: boolean): void {\n      if (enable !== this._flippedX) {\n        this._scaleX *= -1;\n        this._flippedX = enable;\n        this._renderer.updateScaleX();\n        this.invalidateHitboxes();\n      }\n    }\n\n    flipY(enable: boolean): void {\n      if (enable !== this._flippedY) {\n        this._scaleY *= -1;\n        this._flippedY = enable;\n        this._renderer.updateScaleY();\n        this.invalidateHitboxes();\n      }\n    }\n\n    isFlippedX(): boolean {\n      return this._flippedX;\n    }\n\n    isFlippedY(): boolean {\n      return this._flippedY;\n    }\n\n    /**\n     * Get the scale of the object (or the geometric mean of the X and Y scale in case they are different).\n     *\n     * @return the scale of the object (or the geometric mean of the X and Y scale in case they are different).\n     */\n    getScale(): number {\n      const scaleX = Math.abs(this._scaleX);\n      const scaleY = Math.abs(this._scaleY);\n      return scaleX === scaleY ? scaleX : Math.sqrt(scaleX * scaleY);\n    }\n\n    /**\n     * Get the scale of the object on Y axis.\n     *\n     * @return the scale of the object on Y axis\n     */\n    getScaleY(): float {\n      return Math.abs(this._scaleY);\n    }\n\n    /**\n     * Get the scale of the object on X axis.\n     *\n     * @return the scale of the object on X axis\n     */\n    getScaleX(): float {\n      return Math.abs(this._scaleX);\n    }\n\n    invalidateBounds() {\n      this.invalidateHitboxes();\n    }\n\n    getDrawableX(): float {\n      return this._renderer.getDrawableX();\n    }\n\n    getDrawableY(): float {\n      return this._renderer.getDrawableY();\n    }\n\n    getWidth(): float {\n      return this._renderer.getWidth();\n    }\n\n    getHeight(): float {\n      return this._renderer.getHeight();\n    }\n\n    updatePreRender(instanceContainer: gdjs.RuntimeInstanceContainer): void {\n      this._renderer.updatePreRender();\n    }\n\n    transformToDrawing(x: float, y: float) {\n      const point = ShapePainterRuntimeObject._pointForTransformation;\n      point[0] = x;\n      point[1] = y;\n      return this._renderer.transformToDrawing(point);\n    }\n\n    transformToScene(x: float, y: float) {\n      const point = ShapePainterRuntimeObject._pointForTransformation;\n      point[0] = x;\n      point[1] = y;\n      return this._renderer.transformToScene(point);\n    }\n\n    transformToDrawingX(x: float, y: float) {\n      return this.transformToDrawing(x, y)[0];\n    }\n\n    transformToDrawingY(x: float, y: float) {\n      return this.transformToDrawing(x, y)[1];\n    }\n\n    transformToSceneX(x: float, y: float) {\n      return this.transformToScene(x, y)[0];\n    }\n\n    transformToSceneY(x: float, y: float) {\n      return this.transformToScene(x, y)[1];\n    }\n\n    setRectangularCollisionMask(\n      left: float,\n      top: float,\n      right: float,\n      bottom: float\n    ) {\n      if (!this._customCollisionMask) {\n        const rectangle = new gdjs.Polygon();\n        rectangle.vertices.push([0, 0]);\n        rectangle.vertices.push([0, 0]);\n        rectangle.vertices.push([0, 0]);\n        rectangle.vertices.push([0, 0]);\n        this._customCollisionMask = [rectangle];\n      }\n      const rectangle = this._customCollisionMask[0].vertices;\n\n      rectangle[0][0] = left;\n      rectangle[0][1] = top;\n\n      rectangle[1][0] = right;\n      rectangle[1][1] = top;\n\n      rectangle[2][0] = right;\n      rectangle[2][1] = bottom;\n\n      rectangle[3][0] = left;\n      rectangle[3][1] = bottom;\n\n      this.invalidateHitboxes();\n    }\n\n    updateHitBoxes(): void {\n      this.hitBoxes = this._defaultHitBoxes;\n      const width = this.getWidth();\n      const height = this.getHeight();\n      const centerX = this.getCenterX();\n      const centerY = this.getCenterY();\n      const vertices = this.hitBoxes[0].vertices;\n      if (this._customCollisionMask) {\n        const customCollisionMaskVertices = this._customCollisionMask[0]\n          .vertices;\n        for (let i = 0; i < 4; i++) {\n          const point = this.transformToScene(\n            customCollisionMaskVertices[i][0],\n            customCollisionMaskVertices[i][1]\n          );\n          vertices[i][0] = point[0];\n          vertices[i][1] = point[1];\n        }\n      } else {\n        if (centerX === width / 2 && centerY === height / 2) {\n          vertices[0][0] = -centerX;\n          vertices[0][1] = -centerY;\n          vertices[1][0] = +centerX;\n          vertices[1][1] = -centerY;\n          vertices[2][0] = +centerX;\n          vertices[2][1] = +centerY;\n          vertices[3][0] = -centerX;\n          vertices[3][1] = +centerY;\n        } else {\n          vertices[0][0] = 0 - centerX;\n          vertices[0][1] = 0 - centerY;\n          vertices[1][0] = width - centerX;\n          vertices[1][1] = 0 - centerY;\n          vertices[2][0] = width - centerX;\n          vertices[2][1] = height - centerY;\n          vertices[3][0] = 0 - centerX;\n          vertices[3][1] = height - centerY;\n        }\n        if (!this._useAbsoluteCoordinates) {\n          this.hitBoxes[0].rotate(gdjs.toRad(this.getAngle()));\n        }\n        this.hitBoxes[0].move(\n          this.getDrawableX() + centerX,\n          this.getDrawableY() + centerY\n        );\n      }\n    }\n  }\n  gdjs.registerObject(\n    'PrimitiveDrawing::Drawer',\n    gdjs.ShapePainterRuntimeObject\n  );\n  ShapePainterRuntimeObject.supportsReinitialization = false;\n}\n"],
  "mappings": "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",
  "names": []
}
