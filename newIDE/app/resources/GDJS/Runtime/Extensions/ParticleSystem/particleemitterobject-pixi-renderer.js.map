{
  "version": 3,
  "sources": ["../../../../../../../Extensions/ParticleSystem/particleemitterobject-pixi-renderer.ts"],
  "sourcesContent": ["/*\nGDevelop - Particle System Extension\nCopyright (c) 2010-2016 Florian Rival (Florian.Rival@gmail.com)\nThis project is released under the MIT License.\n*/\n\nnamespace gdjs {\n  import PIXI = GlobalPIXIModule.PIXI;\n  export class ParticleEmitterObjectPixiRenderer {\n    renderer: any;\n    emitter: any;\n    started: boolean = false;\n\n    constructor(\n      instanceContainer: gdjs.RuntimeInstanceContainer,\n      runtimeObject: gdjs.RuntimeObject,\n      objectData: any\n    ) {\n      let texture = null;\n      const graphics = new PIXI.Graphics();\n      graphics.lineStyle(0, 0, 0);\n      graphics.beginFill(gdjs.rgbToHexNumber(255, 255, 255), 1);\n      if (objectData.rendererType === 'Point') {\n        graphics.drawCircle(0, 0, objectData.rendererParam1);\n      } else if (objectData.rendererType === 'Line') {\n        graphics.drawRect(\n          0,\n          0,\n          objectData.rendererParam1,\n          objectData.rendererParam2\n        );\n\n        // Draw an almost-invisible rectangle in the left hand to force PIXI to take a full texture with our line at the right hand\n        graphics.beginFill(gdjs.rgbToHexNumber(255, 255, 255), 0.001);\n        graphics.drawRect(\n          0,\n          0,\n          objectData.rendererParam1,\n          objectData.rendererParam2\n        );\n      } else if (objectData.textureParticleName) {\n        const sprite = new PIXI.Sprite(\n          (instanceContainer\n            .getGame()\n            .getImageManager() as gdjs.PixiImageManager).getPIXITexture(\n            objectData.textureParticleName\n          )\n        );\n        sprite.width = objectData.rendererParam1;\n        sprite.height = objectData.rendererParam2;\n        graphics.addChild(sprite);\n      } else {\n        graphics.drawRect(\n          0,\n          0,\n          objectData.rendererParam1,\n          objectData.rendererParam2\n        );\n      }\n      graphics.endFill();\n\n      // Render the texture from graphics using the PIXI Renderer.\n      // TODO: could be optimized by generating the texture only once per object type,\n      // instead of at each object creation.\n      const pixiRenderer = instanceContainer\n        .getGame()\n        .getRenderer()\n        .getPIXIRenderer();\n      //@ts-expect-error Pixi has wrong type definitions for this method\n      texture = pixiRenderer.generateTexture(graphics);\n      const config = {\n        color: {\n          list: [\n            {\n              value: gdjs\n                .rgbToHexNumber(\n                  objectData.particleRed1,\n                  objectData.particleGreen1,\n                  objectData.particleBlue1\n                )\n                .toString(16),\n              time: 0,\n            },\n            {\n              value: gdjs\n                .rgbToHexNumber(\n                  objectData.particleRed2,\n                  objectData.particleGreen2,\n                  objectData.particleBlue2\n                )\n                .toString(16),\n              time: 1,\n            },\n          ],\n          isStepped: false,\n        },\n        acceleration: {\n          x: objectData.particleGravityX,\n          y: objectData.particleGravityY,\n        },\n        lifetime: {\n          min: objectData.particleLifeTimeMin,\n          max: objectData.particleLifeTimeMax,\n        },\n        // A negative flow is \"infinite flow\" (all particles burst)\n        frequency: objectData.flow < 0 ? 0.0001 : 1.0 / objectData.flow,\n        spawnChance: 1,\n        particlesPerWave: objectData.flow < 0 ? objectData.maxParticleNb : 1,\n        maxParticles: objectData.maxParticleNb,\n        // Lifetime can be computed from the tank (the number of particles available)\n        // and the flow (number of particles emitted per seconds)\n        emitterLifetime: ParticleEmitterObjectPixiRenderer.computeLifetime(\n          objectData.flow,\n          objectData.tank\n        ),\n        pos: { x: 0, y: 0 },\n        addAtBack: false,\n        spawnType: 'circle',\n        spawnCircle: { x: 0, y: 0, r: objectData.zoneRadius },\n      };\n      // @ts-ignore\n      config.speed = {\n        list: [{ time: 0, value: objectData.emitterForceMax }],\n        minimumSpeedMultiplier:\n          objectData.emitterForceMax !== 0\n            ? objectData.emitterForceMin / objectData.emitterForceMax\n            : 1,\n        isStepped: false,\n      };\n      // @ts-ignore\n      config.alpha = {\n        list: [\n          { time: 0, value: objectData.particleAlpha1 / 255.0 },\n          { time: 1, value: objectData.particleAlpha2 / 255.0 },\n        ],\n        isStepped: false,\n      };\n      let size1 = objectData.particleSize1 / 100;\n      let size2 = objectData.particleSize2 / 100;\n      const sizeRandom1 = objectData.particleSizeRandomness1 / 100;\n      const sizeRandom2 = objectData.particleSizeRandomness2 / 100;\n      const m = sizeRandom2 !== 0 ? (1 + sizeRandom1) / (1 + sizeRandom2) : 1;\n      // @ts-ignore\n      config.scale = {\n        list: [\n          { time: 0, value: size1 * (1 + sizeRandom1) },\n          { time: 1, value: size2 * (1 + sizeRandom2) },\n        ],\n        minimumScaleMultiplier: m,\n        isStepped: false,\n      };\n      // Angle of the spray cone\n      // @ts-ignore\n      config.startRotation = {\n        min: -objectData.emitterAngleB / 2.0,\n        max: objectData.emitterAngleB / 2.0,\n      };\n      // Rotation speed of the particles\n      // @ts-ignore\n      config.rotationSpeed = {\n        min: objectData.particleAngle1,\n        max: objectData.particleAngle2,\n      };\n      // @ts-ignore\n      config.blendMode = objectData.additive ? 'ADD' : 'NORMAL';\n      this.renderer = new PIXI.Container();\n      // The embedded particle emitter is supposed to be the last minor version\n      // of the version 4 of the particle emitter object\n      // See source https://github.com/pixijs/particle-emitter/blob/v4.3.1/src/Emitter.ts\n      // @ts-ignore\n      this.emitter = new PIXI.particles.Emitter(this.renderer, texture, config);\n      this.start();\n      const layer = instanceContainer.getLayer(runtimeObject.getLayer());\n      if (layer) {\n        layer\n          .getRenderer()\n          .addRendererObject(this.renderer, runtimeObject.getZOrder());\n      }\n    }\n\n    getRendererObject() {\n      return this.renderer;\n    }\n\n    update(delta: float): void {\n      this.emitter.update(delta);\n      if (!this.started && this.getParticleCount() > 0) {\n        this.started = true;\n      }\n    }\n\n    setPosition(x: number, y: number): void {\n      this.emitter.spawnPos.x = x;\n      this.emitter.spawnPos.y = y;\n    }\n\n    setAngle(angle1: float, angle2: float): void {\n      this.emitter.minStartRotation = angle1;\n      this.emitter.maxStartRotation = angle2;\n    }\n\n    setForce(min: float, max: float): void {\n      // If max force is zero, PIXI seems to not be able to compute correctly\n      // the angle of the emitter, resulting in it staying at 0\u00B0 or 180\u00B0.\n      // See https://github.com/4ian/GDevelop/issues/4312.\n      const _max = max || 0.000001;\n      this.emitter.startSpeed.value = _max;\n      this.emitter.minimumSpeedMultiplier = min / _max;\n    }\n\n    setZoneRadius(radius: float): void {\n      this.emitter.spawnCircle.radius = radius;\n    }\n\n    setLifeTime(min: float, max: float): void {\n      this.emitter.minLifetime = min;\n      this.emitter.maxLifetime = max;\n    }\n\n    setGravity(x: float, y: float): void {\n      this.emitter.acceleration.x = x;\n      this.emitter.acceleration.y = y;\n    }\n\n    setColor(\n      r1: number,\n      g1: number,\n      b1: number,\n      r2: number,\n      g2: number,\n      b2: number\n    ): void {\n      this.emitter.startColor.value.r = r1;\n      this.emitter.startColor.value.g = g1;\n      this.emitter.startColor.value.b = b1;\n      this.emitter.startColor.next = this.emitter.startColor.next || {\n        time: 1,\n        value: {},\n      };\n      this.emitter.startColor.next.value.r = r2;\n      this.emitter.startColor.next.value.g = g2;\n      this.emitter.startColor.next.value.b = b2;\n    }\n\n    setSize(size1: float, size2: float): void {\n      this.emitter.startScale.value = size1 / 100.0;\n      if (this.emitter.startScale.next) {\n        this.emitter.startScale.next.value = size2 / 100.0;\n      }\n    }\n\n    setParticleRotationSpeed(min: float, max: float): void {\n      this.emitter.minRotationSpeed = min;\n      this.emitter.maxRotationSpeed = max;\n    }\n\n    setMaxParticlesCount(count: float): void {\n      this.emitter.maxParticles = count;\n    }\n\n    setAdditiveRendering(enabled: boolean): void {\n      this.emitter.particleBlendMode = enabled\n        ? PIXI.BLEND_MODES.ADD\n        : PIXI.BLEND_MODES.NORMAL;\n    }\n\n    setAlpha(alpha1: number, alpha2: number): void {\n      this.emitter.startAlpha.value = alpha1 / 255.0;\n      if (this.emitter.startAlpha.next) {\n        this.emitter.startAlpha.next.value = alpha2 / 255.0;\n      }\n    }\n\n    setFlow(flow: number, tank: number): void {\n      this.emitter.frequency = flow < 0 ? 0.0001 : 1.0 / flow;\n      this.emitter.emitterLifetime = ParticleEmitterObjectPixiRenderer.computeLifetime(\n        flow,\n        tank\n      );\n    }\n\n    resetEmission(flow: number, tank: number): void {\n      this.setFlow(flow, tank);\n      const wasEmitting = this.emitter.emit;\n      // The only way to recompute emitter lifetime is to start the emitter.\n      this.start();\n      if (!wasEmitting) this.stop();\n    }\n\n    isTextureNameValid(\n      texture: string,\n      instanceContainer: gdjs.RuntimeInstanceContainer\n    ): boolean {\n      const invalidPixiTexture = instanceContainer\n        .getGame()\n        .getImageManager()\n        .getInvalidPIXITexture();\n      const pixiTexture = instanceContainer\n        .getGame()\n        .getImageManager()\n        .getPIXITexture(texture);\n      return pixiTexture.valid && pixiTexture !== invalidPixiTexture;\n    }\n\n    setTextureName(\n      texture: string,\n      instanceContainer: gdjs.RuntimeInstanceContainer\n    ): void {\n      const invalidPixiTexture = instanceContainer\n        .getGame()\n        .getImageManager()\n        .getInvalidPIXITexture();\n      const pixiTexture = instanceContainer\n        .getGame()\n        .getImageManager()\n        .getPIXITexture(texture);\n      if (pixiTexture.valid && pixiTexture !== invalidPixiTexture) {\n        this.emitter.particleImages[0] = pixiTexture;\n      }\n    }\n\n    getParticleCount(): integer {\n      return this.emitter.particleCount;\n    }\n\n    stop(): void {\n      this.emitter.emit = false;\n    }\n\n    start(): void {\n      this.emitter.emit = true;\n    }\n\n    recreate(): void {\n      this.emitter.cleanup();\n    }\n\n    destroy(): void {\n      this.emitter.destroy();\n    }\n\n    hasStarted(): boolean {\n      return this.started;\n    }\n\n    static computeLifetime(flow: number, tank: number): float {\n      if (tank < 0) return -1;\n      else if (flow < 0) return 0.001;\n      else return (tank + 0.1) / flow;\n    }\n  }\n\n  // @ts-ignore - Register the class to let the engine use it.\n  export const ParticleEmitterObjectRenderer = ParticleEmitterObjectPixiRenderer;\n  export type ParticleEmitterObjectRenderer = ParticleEmitterObjectPixiRenderer;\n}\n"],
  "mappings": "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",
  "names": []
}
