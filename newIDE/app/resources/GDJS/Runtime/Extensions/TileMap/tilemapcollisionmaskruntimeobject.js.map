{
  "version": 3,
  "sources": ["../../../../../../../Extensions/TileMap/tilemapcollisionmaskruntimeobject.ts"],
  "sourcesContent": ["/// <reference path=\"helper/TileMapHelper.d.ts\" />\nnamespace gdjs {\n  /**\n   * An object that handle hitboxes for a tile map.\n   * @extends gdjs.RuntimeObject\n   */\n  export class TileMapCollisionMaskRuntimeObject extends gdjs.RuntimeObject {\n    private _tilemapJsonFile: string;\n    private _tilesetJsonFile: string;\n    private _renderer: gdjs.TileMap.TileMapCollisionMaskRenderer;\n    _collisionTileMap: gdjs.TileMap.TransformedCollisionTileMap;\n    /**\n     * The tiles are filtered according to this tag.\n     *\n     * This allows have multiple objects with different usage\n     * for the same tile map.\n     * For instance, platforms, jumpthru, ladder, spike, water...\n     */\n    private _collisionMaskTag: string;\n    private _tileMapManager: gdjs.TileMap.TileMapRuntimeManager;\n\n    /**\n     * When set to true, the hitboxes will be shown.\n     */\n    _debugMode: boolean;\n    _fillColor: integer;\n    _outlineColor: integer;\n    _fillOpacity: float;\n    _outlineOpacity: float;\n    _outlineSize: float;\n\n    _width: float;\n    _height: float;\n    _scaleX: float;\n    _scaleY: float;\n\n    /**\n     * If the owner moves, the hitboxes vertices\n     * will have to be transformed again.\n     */\n    private _transformationIsUpToDate: boolean = false;\n\n    constructor(instanceContainer: gdjs.RuntimeInstanceContainer, objectData) {\n      super(instanceContainer, objectData);\n      this._tilemapJsonFile = objectData.content.tilemapJsonFile;\n      this._tilesetJsonFile = objectData.content.tilesetJsonFile;\n      this._collisionMaskTag = objectData.content.collisionMaskTag;\n      this._debugMode = objectData.content.debugMode;\n      this._fillColor = gdjs.rgbOrHexStringToNumber(\n        objectData.content.fillColor\n      );\n      this._outlineColor = gdjs.rgbOrHexStringToNumber(\n        objectData.content.outlineColor\n      );\n      this._fillOpacity = objectData.content.fillOpacity;\n      this._outlineOpacity = objectData.content.outlineOpacity;\n      this._outlineSize = objectData.content.outlineSize;\n      this._tileMapManager = gdjs.TileMap.TileMapRuntimeManager.getManager(\n        instanceContainer\n      );\n\n      // The actual size is set when the tile map file is loaded.\n      this._width = 0;\n      this._height = 0;\n      this._scaleX = 1;\n      this._scaleY = 1;\n      const editableTileMap = new TileMapHelper.EditableTileMap(\n        1,\n        1,\n        0,\n        0,\n        new Map()\n      );\n      this._collisionTileMap = new gdjs.TileMap.TransformedCollisionTileMap(\n        editableTileMap,\n        this._collisionMaskTag\n      );\n\n      this._renderer = new gdjs.TileMap.TileMapCollisionMaskRenderer(\n        this,\n        instanceContainer\n      );\n      this._updateTileMap();\n\n      // *ALWAYS* call `this.onCreated()` at the very end of your object constructor.\n      this.onCreated();\n    }\n\n    updatePreRender(instanceContainer: gdjs.RuntimeInstanceContainer) {\n      super.updatePreRender(instanceContainer);\n\n      if (this._debugMode && this.hitBoxesDirty) {\n        this.updateHitBoxes();\n      }\n    }\n\n    getRendererObject() {\n      return this._renderer.getRendererObject();\n    }\n\n    getVisibilityAABB() {\n      return null;\n    }\n\n    updateFromObjectData(oldObjectData: any, newObjectData: any): boolean {\n      if (\n        oldObjectData.content.tilemapJsonFile !==\n        newObjectData.content.tilemapJsonFile\n      ) {\n        this.setTilemapJsonFile(newObjectData.content.tilemapJsonFile);\n      }\n      if (\n        oldObjectData.content.tilesetJsonFile !==\n        newObjectData.content.tilesetJsonFile\n      ) {\n        this.setTilesetJsonFile(newObjectData.content.tilesetJsonFile);\n      }\n      if (oldObjectData.content.debugMode !== newObjectData.content.debugMode) {\n        this.setDebugMode(newObjectData.content.debugMode);\n      }\n      if (oldObjectData.content.fillColor !== newObjectData.content.fillColor) {\n        this.setFillColor(\n          gdjs.rgbOrHexStringToNumber(newObjectData.content.fillColor)\n        );\n      }\n      if (\n        oldObjectData.content.outlineColor !==\n        newObjectData.content.outlineColor\n      ) {\n        this.setOutlineColor(\n          gdjs.rgbOrHexStringToNumber(newObjectData.content.outlineColor)\n        );\n      }\n      if (oldObjectData.fillOpacity !== newObjectData.fillOpacity) {\n        this.setFillOpacity(newObjectData.fillOpacity);\n      }\n      if (oldObjectData.outlineOpacity !== newObjectData.outlineOpacity) {\n        this.setOutlineOpacity(newObjectData.outlineOpacity);\n      }\n      if (oldObjectData.outlineSize !== newObjectData.outlineSize) {\n        this.setOutlineSize(newObjectData.outlineSize);\n      }\n      return true;\n    }\n\n    extraInitializationFromInitialInstance(initialInstanceData): void {\n      if (initialInstanceData.customSize) {\n        this.setWidth(initialInstanceData.width);\n        this.setHeight(initialInstanceData.height);\n      }\n    }\n\n    private _updateTileMap(): void {\n      this._tileMapManager.getOrLoadTileMap(\n        this._tilemapJsonFile,\n        this._tilesetJsonFile,\n        0, // levelIndex\n        (tileMap: TileMapHelper.EditableTileMap | null) => {\n          if (!tileMap) {\n            // getOrLoadTileMap already log errors.\n            return;\n          }\n\n          this._collisionTileMap = new gdjs.TileMap.TransformedCollisionTileMap(\n            tileMap,\n            this._collisionMaskTag\n          );\n          // The tile map polygons always keep the same references.\n          // It works because the tilemap is never modified.\n          this.hitBoxes = Array.from(\n            this._collisionTileMap.getAllHitboxes(this._collisionMaskTag)\n          );\n          this._renderer.redrawCollisionMask();\n\n          this._width = this._collisionTileMap.getWidth() * this._scaleX;\n          this._height = this._collisionTileMap.getHeight() * this._scaleY;\n        }\n      );\n    }\n\n    updateHitBoxes(): void {\n      this.updateTransformation();\n      // Update the RuntimeObject hitboxes attribute.\n      for (const _ of this._collisionTileMap.getAllHitboxes(\n        this._collisionMaskTag\n      )) {\n        // RuntimeObject.hitBoxes contains the same polygons instances as the\n        // hitboxes from the tiles.\n        //\n        // When hitboxes for a tile is asked to the model, they are updated\n        // according to the new object location if needed.\n        // Iterating over all the tiles forces them to update their hitboxes.\n        //\n        // The hitboxes array is built by _updateTileMap().\n      }\n      this.hitBoxesDirty = false;\n      this._renderer.redrawCollisionMask();\n      this.updateAABB();\n    }\n\n    /**\n     * Update the affine transformation according to the object position, size\n     *  and angle.\n     */\n    updateTransformation(): void {\n      if (this._transformationIsUpToDate) {\n        return;\n      }\n      const transformation = this._collisionTileMap.getTransformation();\n\n      const absScaleX = Math.abs(this._scaleX);\n      const absScaleY = Math.abs(this._scaleY);\n\n      transformation.setToIdentity();\n\n      // Translation\n      transformation.translate(this.x, this.y);\n\n      // Rotation\n      const angleInRadians = (this.angle * Math.PI) / 180;\n      transformation.rotateAround(\n        angleInRadians,\n        this.getCenterX(),\n        this.getCenterY()\n      );\n\n      // Scale\n      transformation.scale(absScaleX, absScaleY);\n\n      this._collisionTileMap.setTransformation(transformation);\n\n      this._transformationIsUpToDate = true;\n    }\n\n    /**\n     * This method is expensive and should not be called.\n     * Prefer using {@link getHitBoxesAround} rather than getHitBoxes.\n     */\n    getHitBoxes(): gdjs.Polygon[] {\n      if (this.hitBoxesDirty) {\n        this.updateHitBoxes();\n        this.updateAABB();\n        this.hitBoxesDirty = false;\n      }\n      return this.hitBoxes;\n    }\n\n    getHitBoxesAround(left: float, top: float, right: float, bottom: float) {\n      // This implementation doesn't call updateHitBoxes.\n      // It's important for good performances because there is no need to\n      // update the whole collision mask where only a few hitboxes must be\n      // checked.\n      this.updateTransformation();\n      return this._collisionTileMap.getHitboxesAround(\n        this._collisionMaskTag,\n        left,\n        top,\n        right,\n        bottom\n      );\n    }\n\n    /**\n     * insideObject usually use the AABB of the object.\n     * But, in case of a tile map, it makes more sense to look each tile individually.\n     * It returns true when there is an hitbox in the tile.\n     */\n    insideObject(x: float, y: float): boolean {\n      this.updateTransformation();\n      // This is more precise than the default implementation.\n      return this._collisionTileMap.pointIsInsideTile(\n        x,\n        y,\n        this._collisionMaskTag\n      );\n    }\n\n    // This implementation doesn't use updateHitBoxes.\n    // It's important for good performances.\n    updateAABB(): void {\n      if (this.getAngle() === 0) {\n        // Fast computation of AABB for non rotated object\n        this.aabb.min[0] = this.x;\n        this.aabb.min[1] = this.y;\n        this.aabb.max[0] = this.aabb.min[0] + this.getWidth();\n        this.aabb.max[1] = this.aabb.min[1] + this.getHeight();\n      } else {\n        const affineTransformation = this._collisionTileMap.getTransformation();\n\n        const left = 0;\n        const right = this._collisionTileMap.getWidth();\n        const top = 0;\n        const bottom = this._collisionTileMap.getHeight();\n\n        const workingPoint = this.aabb.min;\n\n        workingPoint[0] = left;\n        workingPoint[1] = top;\n        affineTransformation.transform(workingPoint, workingPoint);\n        const topLeftX = workingPoint[0];\n        const topLeftY = workingPoint[1];\n\n        workingPoint[0] = right;\n        workingPoint[1] = top;\n        affineTransformation.transform(workingPoint, workingPoint);\n        const topRightX = workingPoint[0];\n        const topRightY = workingPoint[1];\n\n        workingPoint[0] = right;\n        workingPoint[1] = bottom;\n        affineTransformation.transform(workingPoint, workingPoint);\n        const bottomRightX = workingPoint[0];\n        const bottomRightY = workingPoint[1];\n\n        workingPoint[0] = left;\n        workingPoint[1] = bottom;\n        affineTransformation.transform(workingPoint, workingPoint);\n        const bottomLeftX = workingPoint[0];\n        const bottomLeftY = workingPoint[1];\n\n        this.aabb.min[0] = Math.min(\n          topLeftX,\n          topRightX,\n          bottomRightX,\n          bottomLeftX\n        );\n        this.aabb.max[0] = Math.max(\n          topLeftX,\n          topRightX,\n          bottomRightX,\n          bottomLeftX\n        );\n        this.aabb.min[1] = Math.min(\n          topLeftY,\n          topRightY,\n          bottomRightY,\n          bottomLeftY\n        );\n        this.aabb.max[1] = Math.max(\n          topLeftY,\n          topRightY,\n          bottomRightY,\n          bottomLeftY\n        );\n      }\n    }\n\n    /**\n     * Set the Tilemap json file to display.\n     */\n    setTilemapJsonFile(tilemapJsonFile: string): void {\n      this._tilemapJsonFile = tilemapJsonFile;\n      this._updateTileMap();\n    }\n\n    getTilemapJsonFile(): string {\n      return this._tilemapJsonFile;\n    }\n\n    isTilemapJsonFile(selectedTilemapJsonFile: string): boolean {\n      return this._tilemapJsonFile === selectedTilemapJsonFile;\n    }\n\n    setTilesetJsonFile(tilesetJsonFile: string) {\n      this._tilesetJsonFile = tilesetJsonFile;\n      this._updateTileMap();\n    }\n\n    getTilesetJsonFile(): string {\n      return this._tilesetJsonFile;\n    }\n\n    isTilesetJsonFile(selectedTilesetJsonFile: string): boolean {\n      return this._tilesetJsonFile === selectedTilesetJsonFile;\n    }\n\n    /**\n     * @returns true if the hitboxes are shown.\n     */\n    getDebugMode(): boolean {\n      return this._debugMode;\n    }\n\n    /**\n     * @returns true if the hitboxes are shown.\n     */\n    setDebugMode(debugMode: boolean): void {\n      this._debugMode = debugMode;\n      this._renderer.redrawCollisionMask();\n    }\n\n    getFillColor(): integer {\n      return this._fillColor;\n    }\n\n    getOutlineColor(): integer {\n      return this._outlineColor;\n    }\n\n    setFillColor(fillColor: integer): void {\n      this._fillColor = fillColor;\n    }\n\n    setOutlineColor(outlineColor: integer): void {\n      this._outlineColor = outlineColor;\n    }\n\n    setOutlineSize(size: float): void {\n      this._outlineSize = size;\n    }\n\n    getOutlineSize(): float {\n      return this._outlineSize;\n    }\n\n    /**\n     *\n     * @param opacity from 0 to 255\n     */\n    setFillOpacity(opacity: float): void {\n      this._fillOpacity = opacity;\n    }\n\n    /**\n     *\n     * @returns an opacity value from 0 to 255.\n     */\n    getFillOpacity(): float {\n      return this._fillOpacity;\n    }\n\n    /**\n     *\n     * @param opacity from 0 to 255\n     */\n    setOutlineOpacity(opacity: float): void {\n      this._outlineOpacity = opacity;\n    }\n\n    /**\n     *\n     * @returns an opacity value from 0 to 255.\n     */\n    getOutlineOpacity(): float {\n      return this._outlineOpacity;\n    }\n\n    setX(x: float): void {\n      super.setX(x);\n      this._transformationIsUpToDate = false;\n    }\n\n    setY(y: float): void {\n      super.setY(y);\n      this._transformationIsUpToDate = false;\n    }\n\n    setAngle(angle: float): void {\n      super.setAngle(angle);\n      this._transformationIsUpToDate = false;\n    }\n\n    /**\n     * Change the width of the object. This changes the scale on X axis of the object.\n     *\n     * @param width The new width of the object, in pixels.\n     */\n    setWidth(width: float): void {\n      if (this._width === width) {\n        return;\n      }\n      this._scaleX = width / this._collisionTileMap.getWidth();\n      this._width = width;\n      this._transformationIsUpToDate = false;\n      this.invalidateHitboxes();\n    }\n\n    /**\n     * Change the height of the object. This changes the scale on Y axis of the object.\n     *\n     * @param height The new height of the object, in pixels.\n     */\n    setHeight(height: float): void {\n      if (this._height === height) {\n        return;\n      }\n      this._scaleY = height / this._collisionTileMap.getHeight();\n      this._height = height;\n      this._transformationIsUpToDate = false;\n      this.invalidateHitboxes();\n    }\n\n    /**\n     * Get the scale of the object (or the geometric mean of the X and Y scale in case they are different).\n     *\n     * @return the scale of the object (or the geometric mean of the X and Y scale in case they are different).\n     */\n    getScale(): number {\n      const scaleX = this.getScaleX();\n      const scaleY = this.getScaleY();\n      return scaleX === scaleY ? scaleX : Math.sqrt(scaleX * scaleY);\n    }\n\n    /**\n     * Change the scale on X and Y axis of the object.\n     *\n     * @param scale The new scale (must be greater than 0).\n     */\n    setScale(scale: float): void {\n      this.setScaleX(scale);\n      this.setScaleY(scale);\n    }\n\n    /**\n     * Change the scale on X axis of the object (changing its width).\n     *\n     * @param scaleX The new scale (must be greater than 0).\n     */\n    setScaleX(scaleX: float): void {\n      if (scaleX < 0) {\n        scaleX = 0;\n      }\n      if (this._scaleX === scaleX) {\n        return;\n      }\n      this._scaleX = scaleX;\n      this._width = scaleX * this._collisionTileMap.getWidth();\n      this._transformationIsUpToDate = false;\n      this.invalidateHitboxes();\n    }\n\n    /**\n     * Change the scale on Y axis of the object (changing its width).\n     *\n     * @param scaleY The new scale (must be greater than 0).\n     */\n    setScaleY(scaleY: float): void {\n      if (scaleY < 0) {\n        scaleY = 0;\n      }\n      if (this._scaleY === scaleY) {\n        return;\n      }\n      this._scaleY = scaleY;\n      this._height = scaleY * this._collisionTileMap.getHeight();\n      this._transformationIsUpToDate = false;\n      this.invalidateHitboxes();\n    }\n\n    getWidth(): float {\n      return this._width;\n    }\n\n    getHeight(): float {\n      return this._height;\n    }\n\n    getScaleX(): float {\n      return this._scaleX;\n    }\n\n    getScaleY(): float {\n      return this._scaleY;\n    }\n  }\n  gdjs.registerObject(\n    'TileMap::CollisionMask',\n    gdjs.TileMapCollisionMaskRuntimeObject\n  );\n  TileMapCollisionMaskRuntimeObject.supportsReinitialization = false;\n}\n"],
  "mappings": "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",
  "names": []
}
