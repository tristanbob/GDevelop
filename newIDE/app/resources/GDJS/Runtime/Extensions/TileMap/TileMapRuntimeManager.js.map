{
  "version": 3,
  "sources": ["../../../../../../../Extensions/TileMap/TileMapRuntimeManager.ts"],
  "sourcesContent": ["/// <reference path=\"helper/TileMapHelper.d.ts\" />\nnamespace gdjs {\n  export interface RuntimeInstanceContainer {\n    tileMapCollisionMaskManager: gdjs.TileMap.TileMapRuntimeManager;\n  }\n  export namespace TileMap {\n    import PIXI = GlobalPIXIModule.PIXI;\n\n    const logger = new gdjs.Logger('Tilemap object');\n\n    /**\n     * A holder to share tile maps across the 2 extension objects.\n     *\n     * Every instance with the same files path in properties will\n     * share the same {@link EditableTileMap} and {@link TileTextureCache}.\n     *\n     * To use a tile map with collisions, a user can create 4 objects:\n     * - one for the the rendering\n     * - one for the solid platforms\n     * - one for the jumpthrus\n     * - one for the ladders\n     *\n     * To avoid to have 4 copies of the same tile map in memory, this manager\n     * puts the tile map in cache and avoid unnecessary parsing.\n     *\n     * @see {@link TileMapManager}\n     */\n    export class TileMapRuntimeManager {\n      private _instanceContainer: gdjs.RuntimeInstanceContainer;\n      /**\n       * Delegate that actually manage the caches without anything specific to\n       * GDJS.\n       * It allows to factorize code with the IDE.\n       */\n      private _manager: TileMapHelper.TileMapManager;\n      /**\n       * @param instanceContainer The instance container.\n       */\n      private constructor(instanceContainer: gdjs.RuntimeInstanceContainer) {\n        this._instanceContainer = instanceContainer;\n        this._manager = new TileMapHelper.TileMapManager();\n      }\n\n      /**\n       * @param instanceContainer Where to set the manager instance.\n       * @returns The shared manager.\n       */\n      static getManager(\n        instanceContainer: gdjs.RuntimeInstanceContainer\n      ): TileMapRuntimeManager {\n        if (!instanceContainer.tileMapCollisionMaskManager) {\n          // Create the shared manager if necessary.\n          instanceContainer.tileMapCollisionMaskManager = new TileMapRuntimeManager(\n            instanceContainer\n          );\n        }\n        return instanceContainer.tileMapCollisionMaskManager;\n      }\n\n      /**\n       * @param tileMapJsonResourceName The resource name of the tile map.\n       * @param tileSetJsonResourceName The resource name of the tile set.\n       * @param levelIndex The level of the tile map.\n       * @param callback A function called when the tile map is parsed.\n       */\n      getOrLoadTileMap(\n        tileMapJsonResourceName: string,\n        tileSetJsonResourceName: string,\n        levelIndex: number,\n        callback: (\n          tileMapFileContent: TileMapHelper.EditableTileMap | null\n        ) => void\n      ): void {\n        this._manager.getOrLoadTileMap(\n          this._loadTileMap.bind(this),\n          tileMapJsonResourceName,\n          tileSetJsonResourceName,\n          levelIndex,\n          pako,\n          callback\n        );\n      }\n\n      /**\n       * @param getTexture The method that loads the atlas image file in memory.\n       * @param atlasImageResourceName The resource name of the atlas image.\n       * @param tileMapJsonResourceName The resource name of the tile map.\n       * @param tileSetJsonResourceName The resource name of the tile set.\n       * @param levelIndex The level of the tile map.\n       * @param callback A function called when the tiles textures are split.\n       */\n      getOrLoadTextureCache(\n        getTexture: (textureName: string) => PIXI.BaseTexture<PIXI.Resource>,\n        atlasImageResourceName: string,\n        tileMapJsonResourceName: string,\n        tileSetJsonResourceName: string,\n        levelIndex: number,\n        callback: (textureCache: TileMapHelper.TileTextureCache | null) => void\n      ): void {\n        this._manager.getOrLoadTextureCache(\n          this._loadTileMap.bind(this),\n          getTexture,\n          atlasImageResourceName,\n          tileMapJsonResourceName,\n          tileSetJsonResourceName,\n          levelIndex,\n          callback\n        );\n      }\n\n      /**\n       * Parse both JSON and set the content of the tile set in the right\n       * attribute in the tile map to merge both parsed data.\n       */\n      private _loadTileMap(\n        tileMapJsonResourceName: string,\n        tileSetJsonResourceName: string,\n        callback: (\n          tileMapFileContent: TileMapHelper.TileMapFileContent | null\n        ) => void\n      ): void {\n        this._instanceContainer\n          .getGame()\n          .getJsonManager()\n          .loadJson(tileMapJsonResourceName, (error, tileMapJsonData) => {\n            if (error) {\n              logger.error(\n                'An error happened while loading a Tilemap JSON data:',\n                error\n              );\n              callback(null);\n              return;\n            }\n            const tileMapFileContent = TileMapHelper.TileMapManager.identify(\n              tileMapJsonData\n            );\n            if (!tileMapFileContent) {\n              callback(null);\n              return;\n            }\n            if (\n              tileMapFileContent.kind === 'tiled' &&\n              tileSetJsonResourceName\n            ) {\n              this._instanceContainer\n                .getGame()\n                .getJsonManager()\n                .loadJson(tileSetJsonResourceName, (error, tileSetJsonData) => {\n                  if (error) {\n                    logger.error(\n                      'An error happened while loading Tileset JSON data:',\n                      error\n                    );\n                    callback(null);\n                    return;\n                  }\n                  const tiledMap = tileMapFileContent.data;\n                  const tileSet = tileSetJsonData as TileMapHelper.TiledTileset;\n                  tileSet.firstgid = tiledMap.tilesets[0].firstgid;\n                  tiledMap.tilesets = [tileSet];\n                  callback(tileMapFileContent);\n                });\n            } else {\n              callback(tileMapFileContent);\n            }\n          });\n      }\n    }\n  }\n}\n"],
  "mappings": "AACA,GAAU,MAAV,UAAU,EAAV,CAIS,GAAU,GAAV,UAAU,EAAV,CACL,KAAO,GAAO,iBAAiB,KAEzB,EAAS,GAAI,GAAK,OAAO,kBAmBxB,OAA4B,CAWzB,YAAY,EAAkD,CACpE,KAAK,mBAAqB,EAC1B,KAAK,SAAW,GAAI,eAAc,qBAO7B,YACL,EACuB,CACvB,MAAK,GAAkB,6BAErB,GAAkB,4BAA8B,GAAI,GAClD,IAGG,EAAkB,4BAS3B,iBACE,EACA,EACA,EACA,EAGM,CACN,KAAK,SAAS,iBACZ,KAAK,aAAa,KAAK,MACvB,EACA,EACA,EACA,KACA,GAYJ,sBACE,EACA,EACA,EACA,EACA,EACA,EACM,CACN,KAAK,SAAS,sBACZ,KAAK,aAAa,KAAK,MACvB,EACA,EACA,EACA,EACA,EACA,GAQI,aACN,EACA,EACA,EAGM,CACN,KAAK,mBACF,UACA,iBACA,SAAS,EAAyB,CAAC,EAAO,IAAoB,CAC7D,GAAI,EAAO,CACT,EAAO,MACL,uDACA,GAEF,EAAS,MACT,OAEF,KAAM,GAAqB,cAAc,eAAe,SACtD,GAEF,GAAI,CAAC,EAAoB,CACvB,EAAS,MACT,OAEF,AACE,EAAmB,OAAS,SAC5B,EAEA,KAAK,mBACF,UACA,iBACA,SAAS,EAAyB,CAAC,EAAO,IAAoB,CAC7D,GAAI,EAAO,CACT,EAAO,MACL,qDACA,GAEF,EAAS,MACT,OAEF,KAAM,GAAW,EAAmB,KAC9B,EAAU,EAChB,EAAQ,SAAW,EAAS,SAAS,GAAG,SACxC,EAAS,SAAW,CAAC,GACrB,EAAS,KAGb,EAAS,MAxIZ,EAAM,0BAtBE,+BAJT",
  "names": []
}
