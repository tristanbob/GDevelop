var gdjs;(function(h){let D;(function(C){const p=class{constructor(t,e){this._transformation=new h.AffineTransformation;this._inverseTransformation=new h.AffineTransformation;this._transformationUpToDateCount=1;this._source=t,this.tag=e,this._layers=new Map;for(const r of t.getLayers()){if(!(r instanceof TileMapHelper.EditableTileMapLayer))continue;const n=r;this._layers.set(n.id,new v(this,n))}}getTransformation(){return this._transformation}setTransformation(t){this._transformation=t;const e=this._inverseTransformation;e.copyFrom(t),e.invert(),this._invalidate()}_invalidate(){this._transformationUpToDateCount=(this._transformationUpToDateCount+1)%Number.MAX_SAFE_INTEGER}getWidth(){return this._source.getWidth()}getHeight(){return this._source.getHeight()}getTileHeight(){return this._source.getTileHeight()}getTileWidth(){return this._source.getTileWidth()}getDimensionX(){return this._source.getDimensionX()}getDimensionY(){return this._source.getDimensionY()}getTileDefinition(t){return this._source.getTileDefinition(t)}getLayer(t){return this._layers.get(t)}getLayers(){return this._layers.values()}pointIsInsideTile(t,e,r){const n=p.workingPoint;return n[0]=t,n[1]=e,this._inverseTransformation.transform(n,n),this._source.pointIsInsideTile(n[0],n[1],r)}getHitboxesAround(t,e,r,n,o){const s=this._inverseTransformation,i=p.workingPoint;i[0]=e,i[1]=r,s.transform(i,i);const a=i[0],l=i[1];i[0]=n,i[1]=r,s.transform(i,i);const f=i[0],g=i[1];i[0]=n,i[1]=o,s.transform(i,i);const y=i[0],x=i[1];i[0]=e,i[1]=o,s.transform(i,i);const b=i[0],H=i[1],I=Math.max(0,Math.floor(Math.min(a,f,y,b)/this._source.getTileWidth())),P=Math.min(this.getDimensionX()-1,Math.floor(Math.max(a,f,y,b)/this._source.getTileWidth())),L=Math.max(0,Math.floor(Math.min(l,g,x,H)/this._source.getTileHeight())),w=Math.min(this.getDimensionY()-1,Math.floor(Math.max(l,g,x,H)/this._source.getTileHeight()));return this.getHitboxes(t,I,L,P,w)}getHitboxes(t,e,r,n,o){return new c(this,t,e,r,n,o)}getAllHitboxes(t){return this.getHitboxes(t,0,0,this._source.getDimensionX()-1,this._source.getDimensionY()-1)}};let _=p;_.workingPoint=[0,0],C.TransformedCollisionTileMap=_;const m=class{constructor(t,e,r,n,o,s){this.map=t,this.tag=e,this.xMin=r,this.yMin=n,this.xMax=o,this.yMax=s}[Symbol.iterator](){let t=this.map.getLayers()[Symbol.iterator](),e=m.emptyItr;return{next:()=>{let r=e.next();for(;r.done;){const n=t.next();if(n.done)return r;e=n.value.getHitboxes(this.tag,this.xMin,this.yMin,this.xMax,this.yMax)[Symbol.iterator](),r=e.next()}return r}}}};let c=m;c.emptyItr={next:()=>({value:void 0,done:!0})};class v{constructor(t,e){this.tileMap=t,this._source=e,this._tiles=[];const r=this._source.getDimensionX(),n=this._source.getDimensionY();this._tiles.length=n;for(let o=0;o<n;o++){this._tiles[o]=[],this._tiles[o].length=r;for(let s=0;s<r;s++)this._tiles[o][s]=new T(this,s,o)}}get(t,e){const r=this._tiles[e];return r?r[t]:void 0}getDimensionX(){return this._tiles.length===0?0:this._tiles[0].length}getDimensionY(){return this._tiles.length}getWidth(){return this._source.getWidth()}getHeight(){return this._source.getHeight()}isFlippedDiagonally(t,e){return this._source.isFlippedDiagonally(t,e)}isFlippedVertically(t,e){return this._source.isFlippedVertically(t,e)}isFlippedHorizontally(t,e){return this._source.isFlippedHorizontally(t,e)}getHitboxes(t,e,r,n,o){return new d(this,t,e,r,n,o)}getAllHitboxes(t){return this.getHitboxes(t,0,0,this.getDimensionX()-1,this.getDimensionY()-1)}}C.TransformedCollisionTileMapLayer=v;const u=class{constructor(t,e,r,n,o,s){this.layer=t,this.tag=e,this.xMin=r,this.yMin=n,this.xMax=o,this.yMax=s}[Symbol.iterator](){let t=this.xMax,e=this.yMin-1,r=u.emptyItr;return{next:()=>{let n=r.next();for(;n.done;){if(t++,t>this.xMax&&(e++,t=this.xMin),e>this.yMax)return n;const o=this.layer.get(t,e);if(!o)continue;const s=o.getDefinition();!s||s.hasTaggedHitBox(this.tag)&&(r=o.getHitboxes()[Symbol.iterator](),n=r.next())}return n}}}};let d=u;d.emptyItr={next:()=>({value:void 0,done:!0})};const M=class{constructor(t,e,r){this.affineTransformationUpToDateCount=0;this.layer=t,this.x=e,this.y=r;const n=this.getDefinition();if(this.hitBoxes=[],n){const o=this.layer.tileMap.tag,s=n.getHitBoxes(o);if(s){this.hitBoxes.length=s.length;for(let i=0;i<this.hitBoxes.length;i++){const a=new h.Polygon;this.hitBoxes[i]=a,a.vertices.length=s[i].length;for(let l=0;l<a.vertices.length;l++)a.vertices[l]=[0,0]}}}}getDefinition(){return this.layer.tileMap.getTileDefinition(this.layer._source.getTileId(this.x,this.y))}_isHitboxesUpToDate(){return this.affineTransformationUpToDateCount===this.layer.tileMap._transformationUpToDateCount}_setHitboxesUpToDate(){this.affineTransformationUpToDateCount=this.layer.tileMap._transformationUpToDateCount}getHitboxes(){if(this._isHitboxesUpToDate())return this.hitBoxes;const t=this.getDefinition();if(!t)return this._setHitboxesUpToDate(),this.hitBoxes.length=0,this.hitBoxes;const e=this.layer.tileMap.tag,r=t.getHitBoxes(e);if(!r)return this._setHitboxesUpToDate(),this.hitBoxes.length=0,this.hitBoxes;const n=this.layer.tileMap.getTransformation(),o=this.layer.tileMap.getTileWidth(),s=this.layer.tileMap.getTileHeight(),i=M.workingTransformation;i.setToTranslation(o*this.x,s*this.y),this.layer.isFlippedHorizontally(this.x,this.y)&&i.flipX(o/2),this.layer.isFlippedVertically(this.x,this.y)&&i.flipY(s/2),this.layer.isFlippedDiagonally(this.x,this.y)&&(i.flipX(o/2),i.rotateAround(Math.PI/2,o/2,s/2)),i.preConcatenate(n);for(let a=0;a<this.hitBoxes.length;a++){const l=r[a],f=this.hitBoxes[a];for(let g=0;g<f.vertices.length;g++){const y=l[g],x=f.vertices[g];i.transform(y,x)}}return this._setHitboxesUpToDate(),this.hitBoxes}};let T=M;T.workingTransformation=new h.AffineTransformation})(D=h.TileMap||(h.TileMap={}))})(gdjs||(gdjs={}));
//# sourceMappingURL=TransformedTileMap.js.map
