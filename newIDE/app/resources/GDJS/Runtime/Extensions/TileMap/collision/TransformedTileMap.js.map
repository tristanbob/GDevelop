{
  "version": 3,
  "sources": ["../../../../../../../../Extensions/TileMap/collision/TransformedTileMap.ts"],
  "sourcesContent": ["/// <reference path=\"../helper/TileMapHelper.d.ts\" />\nnamespace gdjs {\n  export namespace TileMap {\n    /**\n     * A tile map transformed with an affine transformation.\n     *\n     * @see {@link getHitboxesAround} It gives a fast access to hitboxes for collision handling.\n     */\n    export class TransformedCollisionTileMap {\n      /**\n       * The model that describes the tile map.\n       */\n      private _source: TileMapHelper.EditableTileMap;\n      tag: string;\n      private _layers: Map<integer, TransformedCollisionTileMapLayer>;\n      // TODO Tiled allows to offset the layers\n      /**\n       * The transformation from the time map coordinate (in pixels)\n       * to the scene coordinate (in pixels).\n       */\n      private _transformation: gdjs.AffineTransformation = new gdjs.AffineTransformation();\n      /**\n       * The transformation from the scene coordinate (in pixels)\n       * to the time map coordinate (in pixels).\n       */\n      private _inverseTransformation: gdjs.AffineTransformation = new gdjs.AffineTransformation();\n      /**\n       * This allows tiles to know if their hitboxes must be updated.\n       * @see {@link TransformedCollisionTile.affineTransformationUpToDateCount}\n       */\n      _transformationUpToDateCount: integer = 1;\n      /**\n       * An reusable Point to avoid allocations.\n       */\n      private static readonly workingPoint: FloatPoint = [0, 0];\n\n      /**\n       * @param source The model that describes the tile map.\n       */\n      constructor(source: TileMapHelper.EditableTileMap, tag: string) {\n        this._source = source;\n        this.tag = tag;\n        this._layers = new Map<integer, TransformedCollisionTileMapLayer>();\n        for (const sourceLayer of source.getLayers()) {\n          // TODO A visitor could be used to avoid a cast.\n          if (!(sourceLayer instanceof TileMapHelper.EditableTileMapLayer)) {\n            // TODO Collision mask for object layers is not handled.\n            continue;\n          }\n          const tileLayer = sourceLayer as TileMapHelper.EditableTileMapLayer;\n          this._layers.set(\n            tileLayer.id,\n            new TransformedCollisionTileMapLayer(this, tileLayer)\n          );\n        }\n      }\n\n      /**\n       * @returns The transformation from the time map coordinate (in pixels)\n       * to the scene coordinate (in pixels).\n       */\n      getTransformation(): gdjs.AffineTransformation {\n        return this._transformation;\n      }\n\n      /**\n       * @param transformation the transformation from the time map coordinate\n       * (in pixels) to the scene coordinate (in pixels).\n       */\n      setTransformation(transformation: gdjs.AffineTransformation) {\n        this._transformation = transformation;\n\n        const inverseTransformation = this._inverseTransformation;\n        inverseTransformation.copyFrom(transformation);\n        inverseTransformation.invert();\n\n        this._invalidate();\n      }\n\n      private _invalidate() {\n        this._transformationUpToDateCount =\n          (this._transformationUpToDateCount + 1) % Number.MAX_SAFE_INTEGER;\n      }\n\n      /**\n       * @returns The tile map width in pixels.\n       */\n      getWidth() {\n        return this._source.getWidth();\n      }\n\n      /**\n       * @returns The tile map height in pixels.\n       */\n      getHeight() {\n        return this._source.getHeight();\n      }\n\n      /**\n       * @returns The tile width in pixels.\n       */\n      getTileHeight() {\n        return this._source.getTileHeight();\n      }\n\n      /**\n       * @returns The tile height in pixels.\n       */\n      getTileWidth() {\n        return this._source.getTileWidth();\n      }\n\n      /**\n       * @returns The number of tile columns in the map.\n       */\n      getDimensionX() {\n        return this._source.getDimensionX();\n      }\n\n      /**\n       * @returns The number of tile rows in the map.\n       */\n      getDimensionY() {\n        return this._source.getDimensionY();\n      }\n\n      /**\n       * @param tileId The tile identifier\n       * @returns The tile definition form the tile set.\n       */\n      getTileDefinition(tileId: integer) {\n        return this._source.getTileDefinition(tileId);\n      }\n\n      /**\n       * @param layerId The layer identifier.\n       * @returns the layer\n       */\n      getLayer(layerId: integer): TransformedCollisionTileMapLayer | undefined {\n        return this._layers.get(layerId);\n      }\n\n      /**\n       * @returns All the layers of the tile map.\n       */\n      getLayers(): Iterable<TransformedCollisionTileMapLayer> {\n        return this._layers.values();\n      }\n\n      /**\n       * Check if a point is inside a tile with a given tag.\n       *\n       * It doesn't use the tile hitboxes.\n       * It only check the point is inside the tile square.\n       *\n       * @param x The X coordinate of the point to check.\n       * @param y The Y coordinate of the point to check.\n       * @param tag The tile tag\n       * @returns true when the point is inside a tile with a given tag.\n       */\n      pointIsInsideTile(x: float, y: float, tag: string): boolean {\n        const workingPoint: FloatPoint =\n          TransformedCollisionTileMap.workingPoint;\n        workingPoint[0] = x;\n        workingPoint[1] = y;\n        this._inverseTransformation.transform(workingPoint, workingPoint);\n        return this._source.pointIsInsideTile(\n          workingPoint[0],\n          workingPoint[1],\n          tag\n        );\n      }\n\n      /**\n       * @param tag The tile tag.\n       * @param left The left border of the area in the scene.\n       * @param top The top border of the area in the scene.\n       * @param right The right border of the area in the scene.\n       * @param bottom The left border of the area in the scene.\n       * @returns At least all the hitboxes from the given area\n       * where tiles have the right tag.\n       *\n       * @see {@link gdjs.RuntimeObject.getHitboxesAround}\n       */\n      getHitboxesAround(\n        tag: string,\n        left: float,\n        top: float,\n        right: float,\n        bottom: float\n      ): Iterable<gdjs.Polygon> {\n        // Return the hitboxes from the tiles that overlap\n        // the AABB of the area in the tile map basis.\n        // Some of these tiles are not event in the given area\n        // but this is a good trade of between the number of\n        // useless returned hitboxes and the time to find them.\n\n        // Transform the vertices of the area\n        // from the scene basis to the tile map basis.\n        const inverseTransformation = this._inverseTransformation;\n        const workingPoint: FloatPoint =\n          TransformedCollisionTileMap.workingPoint;\n\n        workingPoint[0] = left;\n        workingPoint[1] = top;\n        inverseTransformation.transform(workingPoint, workingPoint);\n        const topLeftX = workingPoint[0];\n        const topLeftY = workingPoint[1];\n\n        workingPoint[0] = right;\n        workingPoint[1] = top;\n        inverseTransformation.transform(workingPoint, workingPoint);\n        const topRightX = workingPoint[0];\n        const topRightY = workingPoint[1];\n\n        workingPoint[0] = right;\n        workingPoint[1] = bottom;\n        inverseTransformation.transform(workingPoint, workingPoint);\n        const bottomRightX = workingPoint[0];\n        const bottomRightY = workingPoint[1];\n\n        workingPoint[0] = left;\n        workingPoint[1] = bottom;\n        inverseTransformation.transform(workingPoint, workingPoint);\n        const bottomLeftX = workingPoint[0];\n        const bottomLeftY = workingPoint[1];\n\n        // Calculate the AABB of the area in the tile map basis.\n        const xMin = Math.max(\n          0,\n          Math.floor(\n            Math.min(topLeftX, topRightX, bottomRightX, bottomLeftX) /\n              this._source.getTileWidth()\n          )\n        );\n        const xMax = Math.min(\n          this.getDimensionX() - 1,\n          Math.floor(\n            Math.max(topLeftX, topRightX, bottomRightX, bottomLeftX) /\n              this._source.getTileWidth()\n          )\n        );\n        const yMin = Math.max(\n          0,\n          Math.floor(\n            Math.min(topLeftY, topRightY, bottomRightY, bottomLeftY) /\n              this._source.getTileHeight()\n          )\n        );\n        const yMax = Math.min(\n          this.getDimensionY() - 1,\n          Math.floor(\n            Math.max(topLeftY, topRightY, bottomRightY, bottomLeftY) /\n              this._source.getTileHeight()\n          )\n        );\n\n        return this.getHitboxes(tag, xMin, yMin, xMax, yMax);\n      }\n\n      /**\n       * @param tag The tile tag.\n       * @param xMin The fist column to include.\n       * @param yMin The fist row to include.\n       * @param xMax The last column to include.\n       * @param yMax The last row to include.\n       * @returns All the hitboxes from the tiles overlapping\n       * the given area where tiles have the right tag.\n       */\n      getHitboxes(\n        tag: string,\n        xMin: integer,\n        yMin: integer,\n        xMax: integer,\n        yMax: integer\n      ): Iterable<gdjs.Polygon> {\n        return new MapCollisionMaskIterable(this, tag, xMin, yMin, xMax, yMax);\n      }\n\n      /**\n       * @param tag The tile tag.\n       * @returns All the hitboxes from the tiles having the right tag.\n       */\n      getAllHitboxes(tag: string): Iterable<gdjs.Polygon> {\n        return this.getHitboxes(\n          tag,\n          0,\n          0,\n          this._source.getDimensionX() - 1,\n          this._source.getDimensionY() - 1\n        );\n      }\n    }\n\n    /**\n     * Iterable over the tile hitboxes of a given area and tag.\n     */\n    class MapCollisionMaskIterable implements Iterable<gdjs.Polygon> {\n      map: TransformedCollisionTileMap;\n      tag: string;\n      xMin: integer;\n      yMin: integer;\n      xMax: integer;\n      yMax: integer;\n\n      /**\n       * Avoid to allocate an empty iterator each time\n       * the iterable is initialized.\n       */\n      static emptyItr: Iterator<gdjs.Polygon> = {\n        next: () => ({ value: undefined, done: true }),\n      };\n\n      /**\n       * @param map The tile map.\n       * @param tag The tile tag.\n       * @param xMin The fist column to include.\n       * @param yMin The fist row to include.\n       * @param xMax The last column to include.\n       * @param yMax The last row to include.\n       */\n      constructor(\n        map: TransformedCollisionTileMap,\n        tag: string,\n        xMin: integer,\n        yMin: integer,\n        xMax: integer,\n        yMax: integer\n      ) {\n        this.map = map;\n        this.tag = tag;\n        this.xMin = xMin;\n        this.yMin = yMin;\n        this.xMax = xMax;\n        this.yMax = yMax;\n      }\n\n      [Symbol.iterator]() {\n        // Flatten the iterable of each layers into one.\n        let layerItr = this.map.getLayers()[Symbol.iterator]();\n        let listItr: Iterator<gdjs.Polygon> = MapCollisionMaskIterable.emptyItr;\n\n        return {\n          next: () => {\n            let listNext = listItr.next();\n            while (listNext.done) {\n              const layerNext = layerItr.next();\n              if (layerNext.done) {\n                return listNext;\n              }\n              listItr = layerNext.value\n                .getHitboxes(\n                  this.tag,\n                  this.xMin,\n                  this.yMin,\n                  this.xMax,\n                  this.yMax\n                )\n                [Symbol.iterator]();\n              listNext = listItr.next();\n            }\n            return listNext;\n          },\n        };\n      }\n    }\n\n    /**\n     * A tile map layer transformed with an affine transformation.\n     */\n    export class TransformedCollisionTileMapLayer {\n      /**\n       * The time map that contains this layer.\n       */\n      readonly tileMap: TransformedCollisionTileMap;\n      /**\n       * The model that describes the tile map.\n       */\n      readonly _source: TileMapHelper.EditableTileMapLayer;\n      private readonly _tiles: TransformedCollisionTile[][];\n\n      /**\n       * @param tileMap The time map that contains this layer.\n       * @param source The model that describes the tile map.\n       */\n      constructor(\n        tileMap: TransformedCollisionTileMap,\n        source: TileMapHelper.EditableTileMapLayer\n      ) {\n        this.tileMap = tileMap;\n        this._source = source;\n        this._tiles = [];\n        const dimX = this._source.getDimensionX();\n        const dimY = this._source.getDimensionY();\n        this._tiles.length = dimY;\n        for (let y = 0; y < dimY; y++) {\n          this._tiles[y] = [];\n          this._tiles[y].length = dimX;\n          for (let x = 0; x < dimX; x++) {\n            this._tiles[y][x] = new TransformedCollisionTile(this, x, y);\n          }\n        }\n      }\n\n      /**\n       * @param x The layer column.\n       * @param y The layer row.\n       * @return The tile from the tile set.\n       */\n      get(x: integer, y: integer): TransformedCollisionTile | undefined {\n        const row = this._tiles[y];\n        return row ? row[x] : undefined;\n      }\n\n      /**\n       * The number of tile columns in the layer.\n       */\n      getDimensionX() {\n        return this._tiles.length === 0 ? 0 : this._tiles[0].length;\n      }\n\n      /**\n       * The number of tile rows in the layer.\n       */\n      getDimensionY() {\n        return this._tiles.length;\n      }\n\n      /**\n       * @returns The layer width in pixels.\n       */\n      getWidth() {\n        return this._source.getWidth();\n      }\n\n      /**\n       * @returns The layer height in pixels.\n       */\n      getHeight() {\n        return this._source.getHeight();\n      }\n\n      /**\n       * @param x The layer column.\n       * @param y The layer row.\n       * @returns true if the tile is flipped diagonally.\n       */\n      isFlippedDiagonally(x: integer, y: integer) {\n        return this._source.isFlippedDiagonally(x, y);\n      }\n\n      /**\n       * @param x The layer column.\n       * @param y The layer row.\n       * @returns true if the tile is flipped vertically.\n       */\n      isFlippedVertically(x: integer, y: integer) {\n        return this._source.isFlippedVertically(x, y);\n      }\n\n      /**\n       * @param x The layer column.\n       * @param y The layer row.\n       * @returns true if the tile is flipped horizontally.\n       */\n      isFlippedHorizontally(x: integer, y: integer) {\n        return this._source.isFlippedHorizontally(x, y);\n      }\n      /**\n       * @param tag The tile tag.\n       * @param xMin The fist column to include.\n       * @param yMin The fist row to include.\n       * @param xMax The last column to include.\n       * @param yMax The last row to include.\n       * @returns All the hitboxes from the tiles overlapping\n       * the given area where tiles have the right tag.\n       */\n      getHitboxes(\n        tag: string,\n        xMin: integer,\n        yMin: integer,\n        xMax: integer,\n        yMax: integer\n      ): Iterable<gdjs.Polygon> {\n        return new LayerCollisionMaskIterable(\n          this,\n          tag,\n          xMin,\n          yMin,\n          xMax,\n          yMax\n        );\n      }\n\n      /**\n       * @param tag The tile tag.\n       * @returns All the hitboxes from the tiles having the right tag.\n       */\n      getAllHitboxes(tag: string): Iterable<gdjs.Polygon> {\n        return this.getHitboxes(\n          tag,\n          0,\n          0,\n          this.getDimensionX() - 1,\n          this.getDimensionY() - 1\n        );\n      }\n    }\n\n    /**\n     * Iterable over the tile hitboxes of a given area and tag.\n     */\n    class LayerCollisionMaskIterable implements Iterable<gdjs.Polygon> {\n      layer: TransformedCollisionTileMapLayer;\n      tag: string;\n      xMin: integer;\n      yMin: integer;\n      xMax: integer;\n      yMax: integer;\n\n      /**\n       * Avoid to allocate an empty iterator each time\n       * the iterable is initialized.\n       */\n      static emptyItr: Iterator<gdjs.Polygon> = {\n        next: () => ({ value: undefined, done: true }),\n      };\n\n      /**\n       * @param map The tile map.\n       * @param tag The tile tag.\n       * @param xMin The fist column to include.\n       * @param yMin The fist row to include.\n       * @param xMax The last column to include.\n       * @param yMax The last row to include.\n       */\n      constructor(\n        layer: TransformedCollisionTileMapLayer,\n        tag: string,\n        xMin: integer,\n        yMin: integer,\n        xMax: integer,\n        yMax: integer\n      ) {\n        this.layer = layer;\n        this.tag = tag;\n        this.xMin = xMin;\n        this.yMin = yMin;\n        this.xMax = xMax;\n        this.yMax = yMax;\n      }\n\n      [Symbol.iterator]() {\n        // Flatten the iterable of each tile into one.\n\n        // xMin and yMin next increment\n        let x = this.xMax;\n        let y = this.yMin - 1;\n        let polygonItr: Iterator<gdjs.Polygon> =\n          LayerCollisionMaskIterable.emptyItr;\n\n        return {\n          next: () => {\n            let listNext = polygonItr.next();\n            while (listNext.done) {\n              x++;\n              if (x > this.xMax) {\n                y++;\n                x = this.xMin;\n              }\n              if (y > this.yMax) {\n                // done\n                return listNext;\n              }\n              const tile = this.layer.get(x, y);\n              if (!tile) {\n                continue;\n              }\n              const definition = tile.getDefinition();\n              if (!definition) {\n                continue;\n              }\n              if (definition.hasTaggedHitBox(this.tag)) {\n                polygonItr = tile.getHitboxes()[Symbol.iterator]();\n                listNext = polygonItr.next();\n              }\n            }\n            return listNext;\n          },\n        };\n      }\n    }\n\n    /**\n     * A tile transformed with an affine transformation.\n     */\n    class TransformedCollisionTile {\n      /**\n       * The layer that contains this tile.\n       */\n      readonly layer: TransformedCollisionTileMapLayer;\n      /**\n       * The column index in the layer.\n       */\n      readonly x: integer;\n      /**\n       * The row index in the layer.\n       */\n      readonly y: integer;\n      private readonly hitBoxes: gdjs.Polygon[];\n      private affineTransformationUpToDateCount: integer = 0;\n\n      /**\n       * An reusable AffineTransformation to avoid allocations.\n       */\n      private static readonly workingTransformation: gdjs.AffineTransformation = new gdjs.AffineTransformation();\n\n      /**\n       *\n       * @param layer The layer that contains this tile.\n       * @param x The column index in the layer.\n       * @param y The row index in the layer.\n       */\n      constructor(\n        layer: TransformedCollisionTileMapLayer,\n        x: integer,\n        y: integer\n      ) {\n        this.layer = layer;\n        this.x = x;\n        this.y = y;\n        const definition = this.getDefinition();\n        this.hitBoxes = [];\n        if (definition) {\n          const tag = this.layer.tileMap.tag;\n          const definitionHitboxes = definition.getHitBoxes(tag);\n          if (definitionHitboxes) {\n            this.hitBoxes.length = definitionHitboxes.length;\n            for (\n              let polygonIndex = 0;\n              polygonIndex < this.hitBoxes.length;\n              polygonIndex++\n            ) {\n              const polygon = new gdjs.Polygon();\n              this.hitBoxes[polygonIndex] = polygon;\n              polygon.vertices.length = definitionHitboxes[polygonIndex].length;\n              for (\n                let vertexIndex = 0;\n                vertexIndex < polygon.vertices.length;\n                vertexIndex++\n              ) {\n                polygon.vertices[vertexIndex] = [0, 0];\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * @returns The tile definition from the tile set.\n       */\n      getDefinition(): TileMapHelper.TileDefinition {\n        return this.layer.tileMap.getTileDefinition(\n          this.layer._source.getTileId(this.x, this.y)!\n        )!;\n      }\n\n      private _isHitboxesUpToDate() {\n        return (\n          this.affineTransformationUpToDateCount ===\n          this.layer.tileMap._transformationUpToDateCount\n        );\n      }\n\n      private _setHitboxesUpToDate() {\n        this.affineTransformationUpToDateCount = this.layer.tileMap._transformationUpToDateCount;\n      }\n\n      /**\n       * @returns The hitboxes of this tile in the scene basis.\n       */\n      getHitboxes(): Polygon[] {\n        if (this._isHitboxesUpToDate()) {\n          return this.hitBoxes;\n        }\n\n        const definition = this.getDefinition();\n        if (!definition) {\n          this._setHitboxesUpToDate();\n          // It should already be []\n          this.hitBoxes.length = 0;\n          return this.hitBoxes;\n        }\n        const tag = this.layer.tileMap.tag;\n        const definitionHitboxes = definition.getHitBoxes(tag);\n        if (!definitionHitboxes) {\n          this._setHitboxesUpToDate();\n          // It should already be []\n          this.hitBoxes.length = 0;\n          return this.hitBoxes;\n        }\n\n        const layerTransformation = this.layer.tileMap.getTransformation();\n        const width = this.layer.tileMap.getTileWidth();\n        const height = this.layer.tileMap.getTileHeight();\n\n        const tileTransformation =\n          TransformedCollisionTile.workingTransformation;\n        tileTransformation.setToTranslation(width * this.x, height * this.y);\n        if (this.layer.isFlippedHorizontally(this.x, this.y)) {\n          tileTransformation.flipX(width / 2);\n        }\n        if (this.layer.isFlippedVertically(this.x, this.y)) {\n          tileTransformation.flipY(height / 2);\n        }\n        if (this.layer.isFlippedDiagonally(this.x, this.y)) {\n          tileTransformation.flipX(width / 2);\n          tileTransformation.rotateAround(Math.PI / 2, width / 2, height / 2);\n        }\n        tileTransformation.preConcatenate(layerTransformation);\n\n        // The tile map can't change at runtime so the existing arrays can be\n        // reused safely.\n        for (\n          let polygonIndex = 0;\n          polygonIndex < this.hitBoxes.length;\n          polygonIndex++\n        ) {\n          const defPolygon = definitionHitboxes[polygonIndex];\n          const polygon = this.hitBoxes[polygonIndex];\n\n          for (\n            let vertexIndex = 0;\n            vertexIndex < polygon.vertices.length;\n            vertexIndex++\n          ) {\n            const defVertex = defPolygon[vertexIndex];\n            const vertex = polygon.vertices[vertexIndex];\n\n            tileTransformation.transform(defVertex, vertex);\n          }\n        }\n        this._setHitboxesUpToDate();\n        return this.hitBoxes;\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
