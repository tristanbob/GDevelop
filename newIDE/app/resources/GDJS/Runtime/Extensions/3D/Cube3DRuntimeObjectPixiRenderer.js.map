{
  "version": 3,
  "sources": ["../../../../../../../Extensions/3D/Cube3DRuntimeObjectPixiRenderer.ts"],
  "sourcesContent": ["namespace gdjs {\n  // Three.js materials for a cube and the order of faces in the object is different,\n  // so we keep the mapping from one to the other.\n  const faceIndexToMaterialIndex = {\n    3: 0, // right\n    2: 1, // left\n    5: 2, // bottom\n    4: 3, // top\n    0: 4, // front\n    1: 5, // back\n  };\n  const materialIndexToFaceIndex = {\n    0: 3,\n    1: 2,\n    2: 5,\n    3: 4,\n    4: 0,\n    5: 1,\n  };\n\n  const noRepeatTextureVertexIndexToUvMapping = {\n    0: [0, 0],\n    1: [1, 0],\n    2: [0, 1],\n    3: [1, 1],\n  };\n\n  const noRepeatTextureVertexIndexToUvMappingForLeftAndRightFacesTowardsZ = {\n    0: [0, 1],\n    1: [0, 0],\n    2: [1, 1],\n    3: [1, 0],\n  };\n\n  let transparentMaterial: THREE.MeshBasicMaterial;\n  const getTransparentMaterial = () => {\n    if (!transparentMaterial)\n      transparentMaterial = new THREE.MeshBasicMaterial({\n        transparent: true,\n        opacity: 0,\n        // Set the alpha test to to ensure the faces behind are rendered\n        // (no \"back face culling\" that would still be done if alphaTest is not set).\n        alphaTest: 1,\n      });\n\n    return transparentMaterial;\n  };\n\n  const getFaceMaterial = (\n    runtimeObject: gdjs.Cube3DRuntimeObject,\n    faceIndex: integer\n  ) => {\n    if (!runtimeObject.isFaceAtIndexVisible(faceIndex))\n      return getTransparentMaterial();\n\n    return runtimeObject\n      .getInstanceContainer()\n      .getGame()\n      .getImageManager()\n      .getThreeMaterial(runtimeObject.getFaceAtIndexResourceName(faceIndex), {\n        useTransparentTexture: runtimeObject.shouldUseTransparentTexture(),\n        forceBasicMaterial:\n          runtimeObject._materialType ===\n          gdjs.Cube3DRuntimeObject.MaterialType.Basic,\n      });\n  };\n\n  class Cube3DRuntimeObjectPixiRenderer extends gdjs.RuntimeObject3DRenderer {\n    private _cube3DRuntimeObject: gdjs.Cube3DRuntimeObject;\n    private _boxMesh: THREE.Mesh;\n\n    constructor(\n      runtimeObject: gdjs.Cube3DRuntimeObject,\n      instanceContainer: gdjs.RuntimeInstanceContainer\n    ) {\n      const geometry = new THREE.BoxGeometry(1, 1, 1);\n      // TODO (3D) - feature: support color instead of texture?\n      const materials = [\n        getFaceMaterial(runtimeObject, materialIndexToFaceIndex[0]),\n        getFaceMaterial(runtimeObject, materialIndexToFaceIndex[1]),\n        getFaceMaterial(runtimeObject, materialIndexToFaceIndex[2]),\n        getFaceMaterial(runtimeObject, materialIndexToFaceIndex[3]),\n        getFaceMaterial(runtimeObject, materialIndexToFaceIndex[4]),\n        getFaceMaterial(runtimeObject, materialIndexToFaceIndex[5]),\n      ];\n      const boxMesh = new THREE.Mesh(geometry, materials);\n\n      super(runtimeObject, instanceContainer, boxMesh);\n      this._boxMesh = boxMesh;\n      this._cube3DRuntimeObject = runtimeObject;\n\n      this.updateSize();\n      this.updatePosition();\n      this.updateRotation();\n    }\n\n    updateFace(faceIndex: integer) {\n      const materialIndex = faceIndexToMaterialIndex[faceIndex];\n      if (materialIndex === undefined) return;\n\n      this._boxMesh.material[materialIndex] = getFaceMaterial(\n        this._cube3DRuntimeObject,\n        faceIndex\n      );\n      if (this._cube3DRuntimeObject.isFaceAtIndexVisible(faceIndex)) {\n        this.updateTextureUvMapping(faceIndex);\n      }\n    }\n\n    updateSize(): void {\n      super.updateSize();\n      this.updateTextureUvMapping();\n    }\n\n    /**\n     * Updates the UV mapping of the geometry in order to repeat a material\n     * over the different faces of the cube.\n     * The mesh must be configured with a list of materials in order\n     * for the method to work.\n     * @param faceIndex The face index to update. If undefined, updates all the faces.\n     */\n    updateTextureUvMapping(faceIndex?: number) {\n      // @ts-ignore - position is stored as a Float32BufferAttribute\n      const pos: THREE.BufferAttribute = this._boxMesh.geometry.getAttribute(\n        'position'\n      );\n      // @ts-ignore - uv is stored as a Float32BufferAttribute\n      const uvMapping: THREE.BufferAttribute = this._boxMesh.geometry.getAttribute(\n        'uv'\n      );\n      const startIndex =\n        faceIndex === undefined ? 0 : faceIndexToMaterialIndex[faceIndex] * 4;\n      const endIndex =\n        faceIndex === undefined\n          ? 23\n          : faceIndexToMaterialIndex[faceIndex] * 4 + 3;\n      for (\n        let vertexIndex = startIndex;\n        vertexIndex <= endIndex;\n        vertexIndex++\n      ) {\n        const materialIndex = Math.floor(\n          vertexIndex /\n            // Each face of the cube has 4 points\n            4\n        );\n        const material = this._boxMesh.material[materialIndex];\n        if (!material || !material.map) {\n          continue;\n        }\n\n        const shouldRepeatTexture = this._cube3DRuntimeObject.shouldRepeatTextureOnFaceAtIndex(\n          materialIndexToFaceIndex[materialIndex]\n        );\n\n        const shouldOrientateFacesTowardsY =\n          this._cube3DRuntimeObject.getFacesOrientation() === 'Y';\n\n        let x: float, y: float;\n        switch (materialIndex) {\n          case 0:\n            // Right face\n            if (shouldRepeatTexture) {\n              if (shouldOrientateFacesTowardsY) {\n                x =\n                  -(this._boxMesh.scale.z / material.map.source.data.width) *\n                  (pos.getZ(vertexIndex) - 0.5);\n                y =\n                  -(this._boxMesh.scale.y / material.map.source.data.height) *\n                  (pos.getY(vertexIndex) + 0.5);\n              } else {\n                x =\n                  -(this._boxMesh.scale.y / material.map.source.data.width) *\n                  (pos.getY(vertexIndex) - 0.5);\n                y =\n                  (this._boxMesh.scale.z / material.map.source.data.height) *\n                  (pos.getZ(vertexIndex) - 0.5);\n              }\n            } else {\n              if (shouldOrientateFacesTowardsY) {\n                [x, y] = noRepeatTextureVertexIndexToUvMapping[vertexIndex % 4];\n              } else {\n                [\n                  x,\n                  y,\n                ] = noRepeatTextureVertexIndexToUvMappingForLeftAndRightFacesTowardsZ[\n                  vertexIndex % 4\n                ];\n              }\n            }\n            break;\n          case 1:\n            // Left face\n            if (shouldRepeatTexture) {\n              if (shouldOrientateFacesTowardsY) {\n                x =\n                  (this._boxMesh.scale.z / material.map.source.data.width) *\n                  (pos.getZ(vertexIndex) + 0.5);\n                y =\n                  -(this._boxMesh.scale.y / material.map.source.data.height) *\n                  (pos.getY(vertexIndex) + 0.5);\n              } else {\n                x =\n                  (this._boxMesh.scale.y / material.map.source.data.width) *\n                  (pos.getY(vertexIndex) + 0.5);\n                y =\n                  (this._boxMesh.scale.z / material.map.source.data.height) *\n                  (pos.getZ(vertexIndex) - 0.5);\n              }\n            } else {\n              if (shouldOrientateFacesTowardsY) {\n                [x, y] = noRepeatTextureVertexIndexToUvMapping[vertexIndex % 4];\n              } else {\n                [\n                  x,\n                  y,\n                ] = noRepeatTextureVertexIndexToUvMappingForLeftAndRightFacesTowardsZ[\n                  vertexIndex % 4\n                ];\n                x = -x;\n                y = -y;\n              }\n            }\n            break;\n          case 2:\n            // Bottom face\n            if (shouldRepeatTexture) {\n              x =\n                (this._boxMesh.scale.x / material.map.source.data.width) *\n                (pos.getX(vertexIndex) + 0.5);\n              y =\n                (this._boxMesh.scale.z / material.map.source.data.height) *\n                (pos.getZ(vertexIndex) - 0.5);\n            } else {\n              [x, y] = noRepeatTextureVertexIndexToUvMapping[vertexIndex % 4];\n            }\n            break;\n          case 3:\n            // Top face\n            if (shouldRepeatTexture) {\n              if (shouldOrientateFacesTowardsY) {\n                x =\n                  (this._boxMesh.scale.x / material.map.source.data.width) *\n                  (pos.getX(vertexIndex) + 0.5);\n                y =\n                  -(this._boxMesh.scale.z / material.map.source.data.height) *\n                  (pos.getZ(vertexIndex) + 0.5);\n              } else {\n                x =\n                  -(this._boxMesh.scale.x / material.map.source.data.width) *\n                  (pos.getX(vertexIndex) - 0.5);\n                y =\n                  (this._boxMesh.scale.z / material.map.source.data.height) *\n                  (pos.getZ(vertexIndex) - 0.5);\n              }\n            } else {\n              [x, y] = noRepeatTextureVertexIndexToUvMapping[vertexIndex % 4];\n              if (!shouldOrientateFacesTowardsY) {\n                x = -x;\n                y = -y;\n              }\n            }\n            break;\n          case 4:\n            // Front face\n            if (shouldRepeatTexture) {\n              x =\n                (this._boxMesh.scale.x / material.map.source.data.width) *\n                (pos.getX(vertexIndex) + 0.5);\n              y =\n                -(this._boxMesh.scale.y / material.map.source.data.height) *\n                (pos.getY(vertexIndex) + 0.5);\n            } else {\n              [x, y] = noRepeatTextureVertexIndexToUvMapping[vertexIndex % 4];\n            }\n            break;\n          case 5:\n            // Back face\n            const shouldBackFaceBeUpThroughXAxisRotation =\n              this._cube3DRuntimeObject.getBackFaceUpThroughWhichAxisRotation() ===\n              'X';\n\n            if (shouldRepeatTexture) {\n              x =\n                (shouldBackFaceBeUpThroughXAxisRotation ? 1 : -1) *\n                (this._boxMesh.scale.x / material.map.source.data.width) *\n                (pos.getX(vertexIndex) +\n                  (shouldBackFaceBeUpThroughXAxisRotation ? 1 : -1) * 0.5);\n              y =\n                (shouldBackFaceBeUpThroughXAxisRotation ? 1 : -1) *\n                (this._boxMesh.scale.y / material.map.source.data.height) *\n                (pos.getY(vertexIndex) +\n                  (shouldBackFaceBeUpThroughXAxisRotation ? -1 : 1) * 0.5);\n            } else {\n              [x, y] = noRepeatTextureVertexIndexToUvMapping[vertexIndex % 4];\n              if (shouldBackFaceBeUpThroughXAxisRotation) {\n                x = -x;\n                y = -y;\n              }\n            }\n            break;\n          default:\n            [x, y] = noRepeatTextureVertexIndexToUvMapping[vertexIndex % 4];\n        }\n        uvMapping.setXY(vertexIndex, x, y);\n      }\n      uvMapping.needsUpdate = true;\n    }\n\n    _updateMaterials() {\n      for (let index = 0; index < 6; index++) {\n        this.updateFace(index);\n      }\n    }\n  }\n\n  export const Cube3DRuntimeObjectRenderer = Cube3DRuntimeObjectPixiRenderer;\n  export type Cube3DRuntimeObjectRenderer = Cube3DRuntimeObjectPixiRenderer;\n}\n"],
  "mappings": "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",
  "names": []
}
