{
  "version": 3,
  "sources": ["../../../../../../../Extensions/TopDownMovementBehavior/topdownmovementruntimebehavior.ts"],
  "sourcesContent": ["/*\nGDevelop - Top-down movement Behavior Extension\nCopyright (c) 2010-2016 Florian Rival (Florian.Rival@gmail.com)\n */\n\nnamespace gdjs {\n  /**\n   * Allows an object to move in 4 or 8 directions, with customizable speed, accelerations\n   * and rotation.\n   */\n  export class TopDownMovementRuntimeBehavior extends gdjs.RuntimeBehavior {\n    //Behavior configuration:\n    private _allowDiagonals: boolean;\n    private _acceleration: float;\n    private _deceleration: float;\n    private _maxSpeed: float;\n    private _angularMaxSpeed: float;\n    private _rotateObject: boolean;\n    private _angleOffset: float;\n    private _ignoreDefaultControls: boolean;\n    private _movementAngleOffset: float;\n\n    /** The latest angle of movement, in degrees. */\n    private _angle: float = 0;\n\n    //Attributes used when moving\n    private _xVelocity: float = 0;\n    private _yVelocity: float = 0;\n    private _angularSpeed: float = 0;\n\n    // Inputs\n    private _leftKey: boolean = false;\n    private _rightKey: boolean = false;\n    private _upKey: boolean = false;\n    private _downKey: boolean = false;\n    private _leftKeyPressedDuration: float = 0;\n    private _rightKeyPressedDuration: float = 0;\n    private _upKeyPressedDuration: float = 0;\n    private _downKeyPressedDuration: float = 0;\n    private _wasStickUsed: boolean = false;\n    private _stickAngle: float = 0;\n    private _stickForce: float = 0;\n\n    // @ts-ignore The setter \"setViewpoint\" is not detected as an affectation.\n    private _basisTransformation: gdjs.TopDownMovementRuntimeBehavior.BasisTransformation | null;\n    private _temporaryPointForTransformations: FloatPoint = [0, 0];\n\n    private _topDownMovementHooks: Array<\n      gdjs.TopDownMovementRuntimeBehavior.TopDownMovementHook\n    > = [];\n\n    constructor(\n      instanceContainer: gdjs.RuntimeInstanceContainer,\n      behaviorData,\n      owner: gdjs.RuntimeObject\n    ) {\n      super(instanceContainer, behaviorData, owner);\n      this._allowDiagonals = behaviorData.allowDiagonals;\n      this._acceleration = behaviorData.acceleration;\n      this._deceleration = behaviorData.deceleration;\n      this._maxSpeed = behaviorData.maxSpeed;\n      this._angularMaxSpeed = behaviorData.angularMaxSpeed;\n      this._rotateObject = behaviorData.rotateObject;\n      this._angleOffset = behaviorData.angleOffset;\n      this._ignoreDefaultControls = behaviorData.ignoreDefaultControls;\n      this.setViewpoint(\n        behaviorData.viewpoint,\n        behaviorData.customIsometryAngle\n      );\n      this._movementAngleOffset = behaviorData.movementAngleOffset || 0;\n    }\n\n    updateFromBehaviorData(oldBehaviorData, newBehaviorData): boolean {\n      if (oldBehaviorData.allowDiagonals !== newBehaviorData.allowDiagonals) {\n        this._allowDiagonals = newBehaviorData.allowDiagonals;\n      }\n      if (oldBehaviorData.acceleration !== newBehaviorData.acceleration) {\n        this._acceleration = newBehaviorData.acceleration;\n      }\n      if (oldBehaviorData.deceleration !== newBehaviorData.deceleration) {\n        this._deceleration = newBehaviorData.deceleration;\n      }\n      if (oldBehaviorData.maxSpeed !== newBehaviorData.maxSpeed) {\n        this._maxSpeed = newBehaviorData.maxSpeed;\n      }\n      if (oldBehaviorData.angularMaxSpeed !== newBehaviorData.angularMaxSpeed) {\n        this._angularMaxSpeed = newBehaviorData.angularMaxSpeed;\n      }\n      if (oldBehaviorData.rotateObject !== newBehaviorData.rotateObject) {\n        this._rotateObject = newBehaviorData.rotateObject;\n      }\n      if (oldBehaviorData.angleOffset !== newBehaviorData.angleOffset) {\n        this._angleOffset = newBehaviorData.angleOffset;\n      }\n      if (\n        oldBehaviorData.ignoreDefaultControls !==\n        newBehaviorData.ignoreDefaultControls\n      ) {\n        this._ignoreDefaultControls = newBehaviorData.ignoreDefaultControls;\n      }\n      if (\n        oldBehaviorData.platformType !== newBehaviorData.platformType ||\n        oldBehaviorData.customIsometryAngle !==\n          newBehaviorData.customIsometryAngle\n      ) {\n        this.setViewpoint(\n          newBehaviorData.platformType,\n          newBehaviorData.customIsometryAngle\n        );\n      }\n      if (\n        oldBehaviorData.movementAngleOffset !==\n        newBehaviorData.movementAngleOffset\n      ) {\n        this._movementAngleOffset = newBehaviorData.movementAngleOffset;\n      }\n      return true;\n    }\n\n    setViewpoint(viewpoint: string, customIsometryAngle: float): void {\n      if (viewpoint === 'PixelIsometry') {\n        this._basisTransformation = new gdjs.TopDownMovementRuntimeBehavior.IsometryTransformation(\n          Math.atan(0.5)\n        );\n      } else if (viewpoint === 'TrueIsometry') {\n        this._basisTransformation = new gdjs.TopDownMovementRuntimeBehavior.IsometryTransformation(\n          Math.PI / 6\n        );\n      } else if (viewpoint === 'CustomIsometry') {\n        this._basisTransformation = new gdjs.TopDownMovementRuntimeBehavior.IsometryTransformation(\n          (customIsometryAngle * Math.PI) / 180\n        );\n      } else {\n        this._basisTransformation = null;\n      }\n    }\n\n    setAcceleration(acceleration: float): void {\n      this._acceleration = acceleration;\n    }\n\n    getAcceleration() {\n      return this._acceleration;\n    }\n\n    setDeceleration(deceleration: float): void {\n      this._deceleration = deceleration;\n    }\n\n    getDeceleration() {\n      return this._deceleration;\n    }\n\n    setMaxSpeed(maxSpeed: float): void {\n      this._maxSpeed = maxSpeed;\n    }\n\n    getMaxSpeed() {\n      return this._maxSpeed;\n    }\n\n    setAngularMaxSpeed(angularMaxSpeed: float): void {\n      this._angularMaxSpeed = angularMaxSpeed;\n    }\n\n    getAngularMaxSpeed() {\n      return this._angularMaxSpeed;\n    }\n\n    setAngleOffset(angleOffset: float): void {\n      this._angleOffset = angleOffset;\n    }\n\n    getAngleOffset() {\n      return this._angleOffset;\n    }\n\n    allowDiagonals(allow: boolean) {\n      this._allowDiagonals = allow;\n    }\n\n    diagonalsAllowed() {\n      return this._allowDiagonals;\n    }\n\n    setRotateObject(allow: boolean): void {\n      this._rotateObject = allow;\n    }\n\n    isObjectRotated(): boolean {\n      return this._rotateObject;\n    }\n\n    isMoving(): boolean {\n      return this._xVelocity !== 0 || this._yVelocity !== 0;\n    }\n\n    getSpeed(): float {\n      return Math.sqrt(\n        this._xVelocity * this._xVelocity + this._yVelocity * this._yVelocity\n      );\n    }\n\n    getXVelocity(): float {\n      return this._xVelocity;\n    }\n\n    setXVelocity(velocityX: float): void {\n      this._xVelocity = velocityX;\n    }\n\n    getYVelocity(): float {\n      return this._yVelocity;\n    }\n\n    setYVelocity(velocityY: float): void {\n      this._yVelocity = velocityY;\n    }\n\n    getAngle(): float {\n      return this._angle;\n    }\n\n    isMovementAngleAround(degreeAngle: float, tolerance: float) {\n      return (\n        Math.abs(\n          gdjs.evtTools.common.angleDifference(this._angle, degreeAngle)\n        ) <= tolerance\n      );\n    }\n\n    setMovementAngleOffset(movementAngleOffset: float): void {\n      this._movementAngleOffset = movementAngleOffset;\n    }\n\n    getMovementAngleOffset() {\n      return this._movementAngleOffset;\n    }\n\n    doStepPreEvents(instanceContainer: gdjs.RuntimeInstanceContainer) {\n      const LEFTKEY = 37;\n      const UPKEY = 38;\n      const RIGHTKEY = 39;\n      const DOWNKEY = 40;\n\n      //Get the player input:\n      // @ts-ignore\n      this._leftKey |=\n        !this._ignoreDefaultControls &&\n        instanceContainer.getGame().getInputManager().isKeyPressed(LEFTKEY);\n      // @ts-ignore\n      this._rightKey |=\n        !this._ignoreDefaultControls &&\n        instanceContainer.getGame().getInputManager().isKeyPressed(RIGHTKEY);\n      // @ts-ignore\n      this._downKey |=\n        !this._ignoreDefaultControls &&\n        instanceContainer.getGame().getInputManager().isKeyPressed(DOWNKEY);\n      // @ts-ignore\n      this._upKey |=\n        !this._ignoreDefaultControls &&\n        instanceContainer.getGame().getInputManager().isKeyPressed(UPKEY);\n\n      const elapsedTime = this.owner.getElapsedTime();\n\n      if (!this._leftKey) {\n        this._leftKeyPressedDuration = 0;\n      } else {\n        this._leftKeyPressedDuration += elapsedTime;\n      }\n      if (!this._rightKey) {\n        this._rightKeyPressedDuration = 0;\n      } else {\n        this._rightKeyPressedDuration += elapsedTime;\n      }\n      if (!this._downKey) {\n        this._downKeyPressedDuration = 0;\n      } else {\n        this._downKeyPressedDuration += elapsedTime;\n      }\n      if (!this._upKey) {\n        this._upKeyPressedDuration = 0;\n      } else {\n        this._upKeyPressedDuration += elapsedTime;\n      }\n\n      let direction = -1;\n      if (!this._allowDiagonals) {\n        if (this._upKey && !this._downKey) {\n          direction = 6;\n        } else if (!this._upKey && this._downKey) {\n          direction = 2;\n        }\n        // when 2 keys are pressed for diagonals the most recently pressed win\n        if (\n          this._leftKey &&\n          !this._rightKey &&\n          (this._upKey === this._downKey ||\n            (this._upKey &&\n              this._leftKeyPressedDuration < this._upKeyPressedDuration) ||\n            (this._downKey &&\n              this._leftKeyPressedDuration < this._downKeyPressedDuration))\n        ) {\n          direction = 4;\n        } else if (\n          this._rightKey &&\n          !this._leftKey &&\n          (this._upKey === this._downKey ||\n            (this._upKey &&\n              this._rightKeyPressedDuration < this._upKeyPressedDuration) ||\n            (this._downKey &&\n              this._rightKeyPressedDuration < this._downKeyPressedDuration))\n        ) {\n          direction = 0;\n        }\n      } else {\n        if (this._upKey && !this._downKey) {\n          if (this._leftKey && !this._rightKey) {\n            direction = 5;\n          } else if (!this._leftKey && this._rightKey) {\n            direction = 7;\n          } else {\n            direction = 6;\n          }\n        } else if (!this._upKey && this._downKey) {\n          if (this._leftKey && !this._rightKey) {\n            direction = 3;\n          } else if (!this._leftKey && this._rightKey) {\n            direction = 1;\n          } else {\n            direction = 2;\n          }\n        } else {\n          if (this._leftKey && !this._rightKey) {\n            direction = 4;\n          } else if (!this._leftKey && this._rightKey) {\n            direction = 0;\n          }\n        }\n      }\n\n      const hookContext =\n        gdjs.TopDownMovementRuntimeBehavior._topDownMovementHookContext;\n      for (const topDownMovementHook of this._topDownMovementHooks) {\n        hookContext._setDirection(direction);\n        direction = topDownMovementHook.overrideDirection(hookContext);\n      }\n      hookContext._setDirection(direction);\n      for (const topDownMovementHook of this._topDownMovementHooks) {\n        topDownMovementHook.beforeSpeedUpdate(hookContext);\n      }\n\n      const object = this.owner;\n      const timeDelta = this.owner.getElapsedTime() / 1000;\n      const previousVelocityX = this._xVelocity;\n      const previousVelocityY = this._yVelocity;\n      this._wasStickUsed = false;\n\n      // These 4 values are not actually used.\n      // JavaScript doesn't allow to declare\n      // variables without assigning them a value.\n      let directionInRad = 0;\n      let directionInDeg = 0;\n      let cos = 1;\n      let sin = 0;\n\n      // Update the speed of the object:\n      if (direction !== -1) {\n        directionInRad =\n          ((direction + this._movementAngleOffset / 45) * Math.PI) / 4.0;\n        directionInDeg = direction * 45 + this._movementAngleOffset;\n        // This makes the trigo resilient to rounding errors on directionInRad.\n        cos = Math.cos(directionInRad);\n        sin = Math.sin(directionInRad);\n        if (cos === -1 || cos === 1) {\n          sin = 0;\n        }\n        if (sin === -1 || sin === 1) {\n          cos = 0;\n        }\n        this._xVelocity += this._acceleration * timeDelta * cos;\n        this._yVelocity += this._acceleration * timeDelta * sin;\n      } else if (this._stickForce !== 0) {\n        if (!this._allowDiagonals) {\n          this._stickAngle = 90 * Math.floor((this._stickAngle + 45) / 90);\n        }\n        directionInDeg = this._stickAngle + this._movementAngleOffset;\n        directionInRad = (directionInDeg * Math.PI) / 180;\n        const norm = this._acceleration * timeDelta * this._stickForce;\n        // This makes the trigo resilient to rounding errors on directionInRad.\n        cos = Math.cos(directionInRad);\n        sin = Math.sin(directionInRad);\n        if (cos === -1 || cos === 1) {\n          sin = 0;\n        }\n        if (sin === -1 || sin === 1) {\n          cos = 0;\n        }\n        this._xVelocity += norm * cos;\n        this._yVelocity += norm * sin;\n\n        this._wasStickUsed = true;\n        this._stickForce = 0;\n      } else if (this._yVelocity !== 0 || this._xVelocity !== 0) {\n        directionInRad = Math.atan2(this._yVelocity, this._xVelocity);\n        directionInDeg = (directionInRad * 180.0) / Math.PI;\n        const xVelocityWasPositive = this._xVelocity >= 0;\n        const yVelocityWasPositive = this._yVelocity >= 0;\n        // This makes the trigo resilient to rounding errors on directionInRad.\n        cos = Math.cos(directionInRad);\n        sin = Math.sin(directionInRad);\n        if (cos === -1 || cos === 1) {\n          sin = 0;\n        }\n        if (sin === -1 || sin === 1) {\n          cos = 0;\n        }\n        this._xVelocity -= this._deceleration * timeDelta * cos;\n        this._yVelocity -= this._deceleration * timeDelta * sin;\n        if (this._xVelocity > 0 !== xVelocityWasPositive) {\n          this._xVelocity = 0;\n        }\n        if (this._yVelocity > 0 !== yVelocityWasPositive) {\n          this._yVelocity = 0;\n        }\n      }\n      const squaredSpeed =\n        this._xVelocity * this._xVelocity + this._yVelocity * this._yVelocity;\n      if (squaredSpeed > this._maxSpeed * this._maxSpeed) {\n        this._xVelocity = this._maxSpeed * cos;\n        this._yVelocity = this._maxSpeed * sin;\n      }\n\n      // No acceleration for angular speed for now.\n      this._angularSpeed = this._angularMaxSpeed;\n\n      for (const topDownMovementHook of this._topDownMovementHooks) {\n        topDownMovementHook.beforePositionUpdate(hookContext);\n      }\n\n      // Position object.\n      // This is a Verlet integration considering the acceleration as constant.\n      // If you expand deltaX or deltaY, it gives, thanks to the usage of both\n      // the old and the new velocity:\n      // \"velocity * timeDelta + acceleration * timeDelta^2 / 2\".\n      //\n      // The acceleration is not actually always constant, particularly with a gamepad,\n      // but the error is multiplied by timDelta^3. So, it shouldn't matter much.\n      const deltaX = ((previousVelocityX + this._xVelocity) / 2) * timeDelta;\n      const deltaY = ((previousVelocityY + this._yVelocity) / 2) * timeDelta;\n      if (this._basisTransformation === null) {\n        // Top-down viewpoint\n        object.setX(object.getX() + deltaX);\n        object.setY(object.getY() + deltaY);\n      } else {\n        // Isometry viewpoint\n        const point = this._temporaryPointForTransformations;\n        point[0] = deltaX;\n        point[1] = deltaY;\n        this._basisTransformation.toScreen(point, point);\n        object.setX(object.getX() + point[0]);\n        object.setY(object.getY() + point[1]);\n      }\n\n      // Also update angle if needed.\n      if (this._xVelocity !== 0 || this._yVelocity !== 0) {\n        this._angle = directionInDeg;\n        if (this._rotateObject) {\n          object.rotateTowardAngle(\n            directionInDeg + this._angleOffset,\n            this._angularSpeed\n          );\n        }\n      }\n\n      this._leftKey = false;\n      this._rightKey = false;\n      this._upKey = false;\n      this._downKey = false;\n    }\n\n    simulateControl(input: string) {\n      if (input === 'Left') {\n        this._leftKey = true;\n      } else if (input === 'Right') {\n        this._rightKey = true;\n      } else if (input === 'Up') {\n        this._upKey = true;\n      } else if (input === 'Down') {\n        this._downKey = true;\n      }\n    }\n\n    ignoreDefaultControls(ignore: boolean) {\n      this._ignoreDefaultControls = ignore;\n    }\n\n    simulateLeftKey() {\n      this._leftKey = true;\n    }\n\n    simulateRightKey() {\n      this._rightKey = true;\n    }\n\n    simulateUpKey() {\n      this._upKey = true;\n    }\n\n    simulateDownKey() {\n      this._downKey = true;\n    }\n\n    simulateStick(stickAngle: float, stickForce: float) {\n      this._stickAngle = stickAngle % 360;\n      this._stickForce = Math.max(0, Math.min(1, stickForce));\n    }\n\n    /**.\n     * @param input The control to be tested [Left,Right,Up,Down,Stick].\n     * @returns true if the key was used since the last `doStepPreEvents` call.\n     */\n    isUsingControl(input: string): boolean {\n      if (input === 'Left') {\n        return this._leftKeyPressedDuration > 0;\n      }\n      if (input === 'Right') {\n        return this._rightKeyPressedDuration > 0;\n      }\n      if (input === 'Up') {\n        return this._upKeyPressedDuration > 0;\n      }\n      if (input === 'Down') {\n        return this._downKeyPressedDuration > 0;\n      }\n      if (input === 'Stick') {\n        return this._wasStickUsed;\n      }\n      return false;\n    }\n\n    getLastStickInputAngle() {\n      return this._stickAngle;\n    }\n\n    /**\n     * A hook must typically be registered by a behavior that requires this one\n     * in its onCreate function.\n     * The hook must stay forever to avoid side effects like a hooks order\n     * change. To handle deactivated behavior, the hook can check that its\n     * behavior is activated before doing anything.\n     */\n    registerHook(\n      hook: gdjs.TopDownMovementRuntimeBehavior.TopDownMovementHook\n    ) {\n      this._topDownMovementHooks.push(hook);\n    }\n  }\n\n  export namespace TopDownMovementRuntimeBehavior {\n    export class TopDownMovementHookContext {\n      private direction: integer = -1;\n\n      /**\n       * @returns The movement direction from 0 for left to 7 for up-left and\n       * -1 for no direction.\n       */\n      getDirection(): integer {\n        return this.direction;\n      }\n\n      /**\n       * This method won't change the direction used by the top-down movement\n       * behavior.\n       */\n      _setDirection(direction: integer): void {\n        this.direction = direction;\n      }\n    }\n\n    // This should be a static attribute but it's not possible because of\n    // declaration order.\n    export const _topDownMovementHookContext = new gdjs.TopDownMovementRuntimeBehavior.TopDownMovementHookContext();\n\n    /**\n     * Allow extensions relying on the top-down movement to customize its\n     * behavior a bit.\n     */\n    export interface TopDownMovementHook {\n      /**\n       * Return the direction to use instead of the direction given in\n       * parameter.\n       */\n      overrideDirection(hookContext: TopDownMovementHookContext): integer;\n      /**\n       * Called before the acceleration and new direction is applied to the\n       * velocity.\n       */\n      beforeSpeedUpdate(hookContext: TopDownMovementHookContext): void;\n      /**\n       * Called before the velocity is applied to the object position and\n       * angle.\n       */\n      beforePositionUpdate(hookContext: TopDownMovementHookContext): void;\n    }\n\n    export interface BasisTransformation {\n      toScreen(worldPoint: FloatPoint, screenPoint: FloatPoint): void;\n    }\n\n    export class IsometryTransformation\n      implements gdjs.TopDownMovementRuntimeBehavior.BasisTransformation {\n      private _screen: float[][];\n\n      /**\n       * @param angle between the x axis and the projected isometric x axis.\n       * @throws if the angle is not in ]0; pi/4[. Note that 0 is a front viewpoint and pi/4 a top-down viewpoint.\n       */\n      constructor(angle: float) {\n        if (angle <= 0 || angle >= Math.PI / 4)\n          throw new RangeError(\n            'An isometry angle must be in ]0; pi/4] but was: ' + angle\n          );\n\n        const alpha = Math.asin(Math.tan(angle));\n        const sinA = Math.sin(alpha);\n        const cosB = Math.cos(Math.PI / 4);\n        const sinB = cosB;\n        // https://en.wikipedia.org/wiki/Isometric_projection\n        //\n        //   / 1     0    0 \\ / cosB 0 -sinB \\ / 1 0  0 \\\n        //   | 0  cosA sinA | |    0 1     0 | | 0 0 -1 |\n        //   \\ 0 -sinA cosA / \\ sinB 0  cosB / \\ 0 1  0 /\n        this._screen = [\n          [cosB, -sinB],\n          [sinA * sinB, sinA * cosB],\n        ];\n      }\n\n      toScreen(worldPoint: FloatPoint, screenPoint: FloatPoint): void {\n        const x =\n          this._screen[0][0] * worldPoint[0] +\n          this._screen[0][1] * worldPoint[1];\n        const y =\n          this._screen[1][0] * worldPoint[0] +\n          this._screen[1][1] * worldPoint[1];\n        screenPoint[0] = x;\n        screenPoint[1] = y;\n      }\n    }\n  }\n\n  gdjs.registerBehavior(\n    'TopDownMovementBehavior::TopDownMovementBehavior',\n    gdjs.TopDownMovementRuntimeBehavior\n  );\n}\n"],
  "mappings": "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",
  "names": []
}
