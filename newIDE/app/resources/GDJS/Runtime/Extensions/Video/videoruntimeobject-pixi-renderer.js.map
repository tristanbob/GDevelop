{
  "version": 3,
  "sources": ["../../../../../../../Extensions/Video/videoruntimeobject-pixi-renderer.ts"],
  "sourcesContent": ["namespace gdjs {\n  const logger = new gdjs.Logger('Video object PIXI renderer');\n\n  import PIXI = GlobalPIXIModule.PIXI;\n\n  /**\n   * The PIXI.js renderer for the VideoRuntimeObject.\n   */\n  export class VideoRuntimeObjectPixiRenderer {\n    _object: gdjs.VideoRuntimeObject;\n\n    // Load (or reset) the video\n    _pixiObject: any;\n    _textureWasValid: boolean = false;\n\n    /**\n     * @param runtimeObject The object to render\n     * @param instanceContainer The gdjs.RuntimeScene in which the object is\n     */\n    constructor(\n      runtimeObject: gdjs.VideoRuntimeObject,\n      instanceContainer: gdjs.RuntimeInstanceContainer\n    ) {\n      this._object = runtimeObject;\n      this._pixiObject = new PIXI.Sprite(\n        instanceContainer\n          .getGame()\n          .getImageManager()\n          .getPIXIVideoTexture(this._object._videoResource)\n      );\n      this._pixiObject._texture.baseTexture.resource.autoPlay = false;\n\n      // Needed to avoid video not playing/crashing in Chrome/Chromium browsers.\n      // See https://github.com/pixijs/pixi.js/issues/5996\n      this._pixiObject._texture.baseTexture.resource.source.preload = 'auto';\n      this._pixiObject._texture.baseTexture.resource.source.autoload = true;\n\n      // Will be set to true when video texture is loaded.\n      instanceContainer\n        .getLayer('')\n        .getRenderer()\n        .addRendererObject(this._pixiObject, runtimeObject.getZOrder());\n\n      // Set the anchor in the center, so that the object rotates around\n      // its center\n      this._pixiObject.anchor.x = 0.5;\n      this._pixiObject.anchor.y = 0.5;\n      this.updatePosition();\n      this.updateAngle();\n      this.updateOpacity();\n      this.updateVolume();\n      this.updateLoop();\n    }\n\n    getRendererObject() {\n      return this._pixiObject;\n    }\n\n    /**\n     * To be called when the object is removed from the scene: will pause the video.\n     */\n    onDestroy() {\n      this.pause();\n    }\n\n    ensureUpToDate() {\n      // Make sure that the video is repositioned after the texture was loaded\n      // (as width and height will change).\n      if (\n        !this._textureWasValid &&\n        this._pixiObject.texture &&\n        this._pixiObject.texture.valid\n      ) {\n        this.updatePosition();\n        this._textureWasValid = true;\n      }\n    }\n\n    updatePosition(): void {\n      this._pixiObject.position.x = this._object.x + this._pixiObject.width / 2;\n      this._pixiObject.position.y =\n        this._object.y + this._pixiObject.height / 2;\n    }\n\n    updateLoop(): void {\n      this._pixiObject._texture.baseTexture.resource.source.loop = this._object._loop;\n    }\n\n    updateVolume(): void {\n      this._pixiObject._texture.baseTexture.resource.source.volume =\n        this._object._volume / 100;\n    }\n\n    updateAngle(): void {\n      this._pixiObject.rotation = gdjs.toRad(this._object.angle);\n    }\n\n    updateOpacity(): void {\n      this._pixiObject.alpha = this._object._opacity / 255;\n    }\n\n    getWidth(): float {\n      return this._pixiObject.width;\n    }\n\n    getHeight(): float {\n      return this._pixiObject.height;\n    }\n\n    /**\n     * Set the rendered video width\n     * @param width The new width, in pixels.\n     */\n    setWidth(width: float): void {\n      this._pixiObject.width = width;\n\n      // Position needs to be updated, as position in the center of the PIXI Sprite.\n      this.updatePosition();\n    }\n\n    /**\n     * Set the rendered video height\n     * @param height The new height, in pixels.\n     */\n    setHeight(height: float): void {\n      this._pixiObject.height = height;\n\n      // Position needs to be updated, as position in the center of the PIXI Sprite.\n      this.updatePosition();\n    }\n\n    /**\n     * Get the internal HTMLVideoElement used for the video source.\n     * @returns The video element, if any.\n     */\n    _getHTMLVideoElementSource(): HTMLVideoElement | null {\n      if (\n        !this._pixiObject.texture ||\n        !this._pixiObject.texture.baseTexture.resource.source\n      ) {\n        return null;\n      }\n      const source = this._pixiObject.texture.baseTexture.resource.source;\n      if (!(source instanceof HTMLVideoElement)) {\n        return null;\n      }\n      return source;\n    }\n\n    /**\n     * Start the video\n     */\n    play() {\n      const source = this._getHTMLVideoElementSource();\n      if (!source) {\n        return;\n      }\n      const promise = source.play();\n      if (promise !== undefined) {\n        // Autoplay started\n        promise\n          .then(() => {})\n          .catch(() => {\n            // Autoplay was prevented.\n            logger.warn(\n              'The video did not start because: video is invalid or no interaction with the game has been captured before (this is blocked by the navigator: https://goo.gl/xX8pDD)'\n            );\n          });\n      }\n    }\n\n    /**\n     * Pause the video\n     */\n    pause() {\n      const source = this._getHTMLVideoElementSource();\n      if (!source) {\n        return;\n      }\n      source.pause();\n    }\n\n    // Autoplay was prevented.\n    /**\n     * Set the loop on video in renderer\n     * @param enable true to loop the video\n     */\n    setLoop(enable: boolean): void {\n      const source = this._getHTMLVideoElementSource();\n      if (!source) {\n        return;\n      }\n      source.loop = enable;\n    }\n\n    /**\n     * Set or unset mute on the video.\n     * @param enable true to mute\n     */\n    setMute(enable: boolean): void {\n      const source = this._getHTMLVideoElementSource();\n      if (!source) {\n        return;\n      }\n      this._pixiObject._texture.baseTexture.resource.source.muted = enable;\n    }\n\n    /**\n     * Return true if the video is muted.\n     */\n    isMuted(): boolean {\n      const source = this._getHTMLVideoElementSource();\n      if (!source) {\n        return false;\n      }\n      return source.muted;\n    }\n\n    /**\n     * Set the current time of the video.\n     */\n    setCurrentTime(number): void {\n      const source = this._getHTMLVideoElementSource();\n      if (!source) {\n        return;\n      }\n      source.currentTime = number;\n    }\n\n    /**\n     * Set the volume of the video, between 0 and 1.\n     * @param volume The new volume.\n     */\n    setVolume(volume: number): void {\n      const source = this._getHTMLVideoElementSource();\n      if (!source) {\n        return;\n      }\n      source.volume = volume;\n    }\n\n    /**\n     * Get the volume on video, between 0 and 1.\n     */\n    getVolume() {\n      const source = this._getHTMLVideoElementSource();\n      if (!source) {\n        return 0;\n      }\n      return source.volume;\n    }\n\n    /**\n     * Return true if the video is playing\n     */\n    isPlayed(): boolean {\n      const source = this._getHTMLVideoElementSource();\n      if (!source) {\n        return false;\n      }\n      return !source.paused && !source.ended;\n    }\n\n    /**\n     * Return true if the video is looping\n     */\n    isLooped(): boolean {\n      const source = this._getHTMLVideoElementSource();\n      if (!source) {\n        return false;\n      }\n      return source.loop;\n    }\n\n    /**\n     * Get the current time of the playback.\n     */\n    getCurrentTime(): float {\n      const source = this._getHTMLVideoElementSource();\n      if (!source) {\n        return 0;\n      }\n      return source.currentTime;\n    }\n\n    /**\n     * Get the duration of the video.\n     */\n    getDuration() {\n      const source = this._getHTMLVideoElementSource();\n      if (!source) {\n        return 0;\n      }\n      return source.duration;\n    }\n\n    /**\n     * Return true if the video has ended.\n     */\n    isEnded(): boolean {\n      const source = this._getHTMLVideoElementSource();\n      if (!source) {\n        return false;\n      }\n      return source.ended;\n    }\n\n    /**\n     * Set the playback speed (1 = 100%)\n     */\n    setPlaybackSpeed(playbackRate): void {\n      const source = this._getHTMLVideoElementSource();\n      if (!source) {\n        return;\n      }\n      source.playbackRate = playbackRate;\n    }\n\n    /**\n     * Return the playback speed (1 = 100%)\n     */\n    getPlaybackSpeed() {\n      const source = this._getHTMLVideoElementSource();\n      if (!source) {\n        return 0;\n      }\n      return source.playbackRate;\n    }\n  }\n\n  export const VideoRuntimeObjectRenderer = VideoRuntimeObjectPixiRenderer;\n  export type VideoRuntimeObjectRenderer = VideoRuntimeObjectPixiRenderer;\n}\n"],
  "mappings": "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",
  "names": []
}
