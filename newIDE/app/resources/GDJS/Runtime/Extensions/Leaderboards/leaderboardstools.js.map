{
  "version": 3,
  "sources": ["../../../../../../../Extensions/Leaderboards/leaderboardstools.ts"],
  "sourcesContent": ["/// <reference path=\"sha256.d.ts\" />\n\n// TODO EBO Replace runtimeScene to instanceContainer.\nnamespace gdjs {\n  const logger = new gdjs.Logger('Leaderboards');\n  export namespace evtTools {\n    export namespace leaderboards {\n      let _hasPlayerJustClosedLeaderboardView = false;\n\n      gdjs.registerRuntimeScenePostEventsCallback(() => {\n        // Set it back to false for the next frame.\n        _hasPlayerJustClosedLeaderboardView = false;\n      });\n\n      /**\n       * Returns true if the player has just closed the leaderboard view.\n       */\n      export const hasPlayerJustClosedLeaderboardView = () =>\n        _hasPlayerJustClosedLeaderboardView;\n\n      const computeDigest = (payload: string): string => {\n        const shaObj = new jsSHA('SHA-256', 'TEXT', { encoding: 'UTF8' });\n        shaObj.update(payload);\n        return shaObj.getHash('B64');\n      };\n\n      // Score saving\n      class ScoreSavingState {\n        lastScoreSavingStartedAt: number | null;\n        lastScoreSavingSucceededAt: number | null;\n        currentlySavingScore: number | null;\n        currentlySavingPlayerName: string | null;\n        currentlySavingPlayerId: string | null;\n        lastSavedScore: number | null;\n        lastSavedPlayerName: string | null;\n        lastSavedPlayerId: string | null;\n        lastSaveError: string | null;\n        isScoreSaving: boolean;\n        hasScoreBeenSaved: boolean;\n        hasScoreSavingErrored: boolean;\n\n        constructor() {\n          this.lastScoreSavingStartedAt = null;\n          this.lastScoreSavingSucceededAt = null;\n          this.currentlySavingScore = null;\n          this.currentlySavingPlayerName = null;\n          this.currentlySavingPlayerId = null;\n          this.lastSavedScore = null;\n          this.lastSavedPlayerName = null;\n          this.lastSavedPlayerId = null;\n          this.lastSaveError = null;\n          this.isScoreSaving = false;\n          this.hasScoreBeenSaved = false;\n          this.hasScoreSavingErrored = false;\n        }\n\n        isSameAsLastScore({\n          playerName,\n          playerId,\n          score,\n        }: {\n          playerName?: string;\n          playerId?: string;\n          score: number;\n        }): boolean {\n          return (\n            ((!!playerName && this.lastSavedPlayerName === playerName) ||\n              (!!playerId && this.lastSavedPlayerId === playerId)) &&\n            this.lastSavedScore === score\n          );\n        }\n\n        isAlreadySavingThisScore({\n          playerName,\n          playerId,\n          score,\n        }: {\n          playerName?: string;\n          playerId?: string;\n          score: number;\n        }): boolean {\n          return (\n            ((!!playerName && this.currentlySavingPlayerName === playerName) ||\n              (!!playerId && this.currentlySavingPlayerId === playerId)) &&\n            this.isScoreSaving &&\n            this.currentlySavingScore === score\n          );\n        }\n\n        isTooSoonToSaveAnotherScore(): boolean {\n          return (\n            !!this.lastScoreSavingStartedAt &&\n            Date.now() - this.lastScoreSavingStartedAt < 500\n          );\n        }\n\n        startSaving({\n          playerName,\n          playerId,\n          score,\n        }: {\n          playerName?: string;\n          playerId?: string;\n          score: number;\n        }): void {\n          this.lastScoreSavingStartedAt = Date.now();\n          this.isScoreSaving = true;\n          this.hasScoreBeenSaved = false;\n          this.hasScoreSavingErrored = false;\n          this.currentlySavingScore = score;\n          if (playerName) this.currentlySavingPlayerName = playerName;\n          if (playerId) this.currentlySavingPlayerId = playerId;\n        }\n\n        closeSaving(): void {\n          this.lastScoreSavingSucceededAt = Date.now();\n          this.lastSavedScore = this.currentlySavingScore;\n          this.lastSavedPlayerName = this.currentlySavingPlayerName;\n          this.lastSavedPlayerId = this.currentlySavingPlayerId;\n          this.isScoreSaving = false;\n          this.hasScoreBeenSaved = true;\n        }\n\n        setError(errorCode: string): void {\n          this.lastSaveError = errorCode;\n          this.isScoreSaving = false;\n          this.hasScoreBeenSaved = false;\n          this.hasScoreSavingErrored = true;\n        }\n      }\n\n      let _scoreSavingStateByLeaderboard: {\n        [leaderboardId: string]: ScoreSavingState;\n      } = {};\n\n      // Leaderboard display\n      let _requestedLeaderboardId: string | null;\n      let _leaderboardViewIframe: HTMLIFrameElement | null = null;\n      let _leaderboardViewIframeErrored: boolean = false;\n      let _leaderboardViewIframeLoading: boolean = false;\n      let _leaderboardViewIframeLoaded: boolean = false;\n      let _errorTimeoutId: NodeJS.Timeout | null = null;\n      let _leaderboardViewClosingCallback:\n        | ((event: MessageEvent) => void)\n        | null = null;\n\n      const _loaderContainer: HTMLDivElement = document.createElement('div');\n      _loaderContainer.style.backgroundColor = '#000000';\n      _loaderContainer.style.display = 'flex';\n      _loaderContainer.style.height = '100%';\n      _loaderContainer.style.width = '100%';\n      _loaderContainer.style.justifyContent = 'center';\n      _loaderContainer.style.alignItems = 'center';\n      _loaderContainer.style.position = 'relative';\n      _loaderContainer.style.zIndex = '2';\n      const _loader = document.createElement('img');\n      _loader.setAttribute('width', '50px');\n      _loader.setAttribute(\n        'src',\n        'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCI+CjxjaXJjbGUgb3BhY2l0eT0nMC4yNScgY3g9IjEyIiBjeT0iMTIiIHI9IjEwIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iNCI+PC9jaXJjbGU+CjxwYXRoIG9wYWNpdHk9JzAuNzUnIGZpbGw9IiNGRkZGRkYiIGQ9Ik00IDEyYTggOCAwIDAxOC04VjBDNS4zNzMgMCAwIDUuMzczIDAgMTJoNHptMiA1LjI5MUE3Ljk2MiA3Ljk2MiAwIDAxNCAxMkgwYzAgMy4wNDIgMS4xMzUgNS44MjQgMyA3LjkzOGwzLTIuNjQ3eiI+PC9wYXRoPgo8L3N2Zz4='\n      );\n      try {\n        _loader.animate(\n          [{ transform: 'rotate(0deg)' }, { transform: 'rotate(359deg)' }],\n          {\n            duration: 3000,\n            iterations: Infinity,\n          }\n        );\n      } catch {\n        logger.warn('Animation not supported, loader will be fixed.');\n      }\n      _loaderContainer.appendChild(_loader);\n\n      const getLastScoreSavingState = function ({\n        hasSucceeded,\n      }: {\n        hasSucceeded: boolean;\n      }): ScoreSavingState | null {\n        const getDateField = (scoreSavingState: ScoreSavingState) =>\n          hasSucceeded\n            ? scoreSavingState.lastScoreSavingSucceededAt\n            : scoreSavingState.lastScoreSavingStartedAt;\n        const scoreSavingStates = Object.values(\n          _scoreSavingStateByLeaderboard\n        ).filter((scoreSavingState) => !!getDateField(scoreSavingState));\n        if (scoreSavingStates.length === 0) return null;\n\n        let lastScoreSavingState = scoreSavingStates[0];\n        scoreSavingStates.forEach((scoreSavingState) => {\n          const currentItemDate = getDateField(scoreSavingState);\n          const lastItemDate = getDateField(lastScoreSavingState);\n          if (\n            currentItemDate &&\n            lastItemDate &&\n            currentItemDate > lastItemDate\n          ) {\n            lastScoreSavingState = scoreSavingState;\n          }\n        });\n        return lastScoreSavingState;\n      };\n\n      const saveScore = function ({\n        leaderboardId,\n        playerName,\n        authenticatedPlayerData,\n        score,\n        scoreSavingState,\n        runtimeScene,\n      }: {\n        leaderboardId: string;\n        playerName?: string | null;\n        authenticatedPlayerData?: { playerId: string; playerToken: string };\n        score: number;\n        scoreSavingState: ScoreSavingState;\n        runtimeScene: gdjs.RuntimeScene;\n      }) {\n        const rootApi = runtimeScene\n          .getGame()\n          .isUsingGDevelopDevelopmentEnvironment()\n          ? 'https://api-dev.gdevelop.io'\n          : 'https://api.gdevelop.io';\n        const baseUrl = `${rootApi}/play`;\n        const game = runtimeScene.getGame();\n        const payloadObject = {\n          score: score,\n          sessionId: game.getSessionId(),\n          clientPlayerId: game.getPlayerId(),\n          location:\n            typeof window !== 'undefined' && (window as any).location\n              ? (window as any).location.href\n              : '',\n        };\n        const headers = {\n          'Content-Type': 'application/json',\n        };\n        let leaderboardEntryCreationUrl = `${baseUrl}/game/${gdjs.projectData.properties.projectUuid}/leaderboard/${leaderboardId}/entry`;\n        if (authenticatedPlayerData) {\n          headers[\n            'Authorization'\n          ] = `player-game-token ${authenticatedPlayerData.playerToken}`;\n          leaderboardEntryCreationUrl += `?playerId=${authenticatedPlayerData.playerId}`;\n        } else {\n          // In case playerName is empty or undefined, the formatting will generate a random name.\n          payloadObject['playerName'] = formatPlayerName(playerName);\n        }\n        const payload = JSON.stringify(payloadObject);\n        headers['Digest'] = computeDigest(payload);\n\n        fetch(leaderboardEntryCreationUrl, {\n          body: payload,\n          method: 'POST',\n          headers: headers,\n        }).then(\n          (response) => {\n            if (!response.ok) {\n              const errorCode = response.status.toString();\n              logger.error(\n                'Server responded with an error:',\n                errorCode,\n                response.statusText\n              );\n              scoreSavingState.setError(errorCode);\n              return;\n            }\n\n            scoreSavingState.closeSaving();\n\n            return response.text().then(\n              (text) => {},\n              (error) => {\n                logger.warn(\n                  'An error occurred when reading response but score has been saved:',\n                  error\n                );\n              }\n            );\n          },\n          (error) => {\n            logger.error('Error while submitting a leaderboard score:', error);\n            const errorCode = 'REQUEST_NOT_SENT';\n            scoreSavingState.setError(errorCode);\n          }\n        );\n      };\n\n      export const savePlayerScore = function (\n        runtimeScene: gdjs.RuntimeScene,\n        leaderboardId: string,\n        score: float,\n        playerName: string\n      ) {\n        let scoreSavingState: ScoreSavingState;\n        if (_scoreSavingStateByLeaderboard[leaderboardId]) {\n          scoreSavingState = _scoreSavingStateByLeaderboard[leaderboardId];\n          let shouldStartSaving = true;\n          if (\n            shouldStartSaving &&\n            scoreSavingState.isAlreadySavingThisScore({ playerName, score })\n          ) {\n            logger.warn(\n              'There is already a request to save with this player name and this score. Ignoring this one.'\n            );\n            shouldStartSaving = false;\n          }\n\n          if (\n            shouldStartSaving &&\n            scoreSavingState.isSameAsLastScore({ playerName, score })\n          ) {\n            logger.warn(\n              'The player and score to be sent are the same as previous one. Ignoring this one.'\n            );\n            scoreSavingState.setError('SAME_AS_PREVIOUS');\n            shouldStartSaving = false;\n          }\n\n          if (\n            shouldStartSaving &&\n            scoreSavingState.isTooSoonToSaveAnotherScore()\n          ) {\n            logger.warn(\n              'Last entry was sent too little time ago. Ignoring this one.'\n            );\n            scoreSavingState.setError('TOO_FAST');\n            shouldStartSaving = false;\n            // Set the starting time to cancel all the following attempts that\n            // are started too early after this one.\n            scoreSavingState.lastScoreSavingStartedAt = Date.now();\n          }\n          if (!shouldStartSaving) {\n            return;\n          }\n        } else {\n          scoreSavingState = new ScoreSavingState();\n          _scoreSavingStateByLeaderboard[leaderboardId] = scoreSavingState;\n        }\n\n        scoreSavingState.startSaving({ playerName, score });\n\n        saveScore({\n          leaderboardId,\n          playerName,\n          score,\n          scoreSavingState,\n          runtimeScene,\n        });\n      };\n\n      export const saveConnectedPlayerScore = function (\n        runtimeScene: gdjs.RuntimeScene,\n        leaderboardId: string,\n        score: float\n      ) {\n        let scoreSavingState: ScoreSavingState;\n        const playerId = gdjs.playerAuthentication.getUserId();\n        const playerToken = gdjs.playerAuthentication.getUserToken();\n        if (!playerId || !playerToken) {\n          logger.warn(\n            'Cannot save a score for a connected player if the player is not connected.'\n          );\n          return;\n        }\n        if (_scoreSavingStateByLeaderboard[leaderboardId]) {\n          scoreSavingState = _scoreSavingStateByLeaderboard[leaderboardId];\n          let shouldStartSaving = true;\n          if (\n            shouldStartSaving &&\n            scoreSavingState.isAlreadySavingThisScore({ playerId, score })\n          ) {\n            logger.warn(\n              'There is already a request to save with this player ID and this score. Ignoring this one.'\n            );\n            shouldStartSaving = false;\n          }\n\n          if (\n            shouldStartSaving &&\n            scoreSavingState.isSameAsLastScore({ playerId, score })\n          ) {\n            logger.warn(\n              'The player and score to be sent are the same as previous one. Ignoring this one.'\n            );\n            scoreSavingState.setError('SAME_AS_PREVIOUS');\n            shouldStartSaving = false;\n          }\n\n          if (\n            shouldStartSaving &&\n            scoreSavingState.isTooSoonToSaveAnotherScore()\n          ) {\n            logger.warn(\n              'Last entry was sent too little time ago. Ignoring this one.'\n            );\n            scoreSavingState.setError('TOO_FAST');\n            shouldStartSaving = false;\n            // Set the starting time to cancel all the following attempts that\n            // are started too early after this one.\n            scoreSavingState.lastScoreSavingStartedAt = Date.now();\n          }\n          if (!shouldStartSaving) {\n            return;\n          }\n        } else {\n          scoreSavingState = new ScoreSavingState();\n          _scoreSavingStateByLeaderboard[leaderboardId] = scoreSavingState;\n        }\n\n        scoreSavingState.startSaving({ playerId, score });\n\n        saveScore({\n          leaderboardId,\n          authenticatedPlayerData: { playerId, playerToken },\n          score,\n          scoreSavingState,\n          runtimeScene,\n        });\n      };\n\n      export const isSaving = function (leaderboardId?: string): boolean {\n        if (leaderboardId) {\n          return _scoreSavingStateByLeaderboard[leaderboardId]\n            ? _scoreSavingStateByLeaderboard[leaderboardId].isScoreSaving\n            : false;\n        }\n\n        const lastScoreSavingState = getLastScoreSavingState({\n          hasSucceeded: false,\n        });\n        return lastScoreSavingState\n          ? lastScoreSavingState.isScoreSaving\n          : false;\n      };\n\n      export const hasBeenSaved = function (leaderboardId?: string): boolean {\n        if (leaderboardId) {\n          return _scoreSavingStateByLeaderboard[leaderboardId]\n            ? _scoreSavingStateByLeaderboard[leaderboardId].hasScoreBeenSaved\n            : false;\n        }\n\n        const lastScoreSavingState = getLastScoreSavingState({\n          hasSucceeded: true,\n        });\n        return lastScoreSavingState\n          ? lastScoreSavingState.hasScoreBeenSaved\n          : false;\n      };\n\n      export const hasSavingErrored = function (\n        leaderboardId?: string\n      ): boolean {\n        if (leaderboardId) {\n          return _scoreSavingStateByLeaderboard[leaderboardId]\n            ? _scoreSavingStateByLeaderboard[leaderboardId]\n                .hasScoreSavingErrored\n            : false;\n        }\n\n        const lastScoreSavingState = getLastScoreSavingState({\n          hasSucceeded: false,\n        });\n        return lastScoreSavingState\n          ? lastScoreSavingState.hasScoreSavingErrored\n          : false;\n      };\n\n      export const getLastSaveError = function (\n        leaderboardId?: string\n      ): string | null {\n        if (leaderboardId) {\n          return _scoreSavingStateByLeaderboard[leaderboardId]\n            ? _scoreSavingStateByLeaderboard[leaderboardId].lastSaveError\n            : 'NO_DATA_ERROR';\n        }\n\n        const lastScoreSavingState = getLastScoreSavingState({\n          hasSucceeded: false,\n        });\n        return lastScoreSavingState\n          ? lastScoreSavingState.lastSaveError\n          : 'NO_DATA_ERROR';\n      };\n\n      export const formatPlayerName = function (\n        rawName?: string | null\n      ): string {\n        if (\n          !rawName ||\n          typeof rawName !== 'string' ||\n          (typeof rawName === 'string' && rawName.length === 0)\n        ) {\n          return `Player${Math.round(\n            (Math.random() * 9 + 1) * 10000 // Number between 10,000 and 99,999\n          )}`;\n        }\n        return rawName\n          .trim()\n          .normalize('NFD')\n          .replace(/[\\u0300-\\u036f]/g, '')\n          .replace(/\\s/g, '_')\n          .replace(/[^\\w|-]/g, '')\n          .slice(0, 30);\n      };\n\n      const checkLeaderboardAvailability = function (\n        url: string\n      ): Promise<boolean> {\n        return fetch(url, {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n        }).then(\n          (response) => {\n            if (!response.ok) {\n              logger.error(\n                `Error while fetching leaderboard view, server returned: ${response.status} ${response.statusText}`\n              );\n              return false;\n            }\n            return true;\n          },\n          (err) => {\n            logger.error('Error while fetching leaderboard view:', err);\n            return false;\n          }\n        );\n      };\n\n      const receiveMessageFromLeaderboardView = function (\n        runtimeScene: gdjs.RuntimeScene,\n        displayLoader: boolean,\n        event: MessageEvent\n      ) {\n        switch (event.data) {\n          case 'closeLeaderboardView':\n            _hasPlayerJustClosedLeaderboardView = true;\n            closeLeaderboardView(runtimeScene);\n            break;\n          case 'leaderboardViewLoaded':\n            if (displayLoader) {\n              if (_errorTimeoutId) clearTimeout(_errorTimeoutId);\n              displayLoaderInLeaderboardView(false, runtimeScene, {\n                callOnErrorIfDomElementContainerMissing: false,\n              });\n            }\n            if (!_leaderboardViewIframe) {\n              handleErrorDisplayingLeaderboard(\n                runtimeScene,\n                \"The leaderboard view couldn't be found. Doing nothing.\"\n              );\n              return;\n            }\n            _leaderboardViewIframe.style.opacity = '1';\n            _leaderboardViewIframeLoaded = true;\n            _leaderboardViewIframeLoading = false;\n\n            break;\n        }\n      };\n\n      const handleErrorDisplayingLeaderboard = function (\n        runtimeScene: gdjs.RuntimeScene,\n        message: string\n      ) {\n        logger.error(message);\n        _leaderboardViewIframeErrored = true;\n        _leaderboardViewIframeLoading = false;\n        closeLeaderboardView(runtimeScene);\n      };\n\n      const resetLeaderboardDisplayErrorTimeout = (\n        runtimeScene: gdjs.RuntimeScene\n      ) => {\n        if (_errorTimeoutId) clearTimeout(_errorTimeoutId);\n        _errorTimeoutId = setTimeout(() => {\n          if (!_leaderboardViewIframeLoaded) {\n            handleErrorDisplayingLeaderboard(\n              runtimeScene,\n              'Leaderboard page did not send message in time. Closing leaderboard view.'\n            );\n          }\n        }, 5000);\n      };\n\n      const displayLoaderInLeaderboardView = function (\n        yesOrNo: boolean,\n        runtimeScene: gdjs.RuntimeScene,\n        options: { callOnErrorIfDomElementContainerMissing: boolean }\n      ): boolean {\n        const domElementContainer = runtimeScene\n          .getGame()\n          .getRenderer()\n          .getDomElementContainer();\n        if (!domElementContainer) {\n          if (options.callOnErrorIfDomElementContainerMissing) {\n            handleErrorDisplayingLeaderboard(\n              runtimeScene,\n              \"The div element covering the game couldn't be found, the leaderboard cannot be displayed.\"\n            );\n          }\n          return false;\n        }\n        if (yesOrNo) {\n          if (\n            domElementContainer.children &&\n            domElementContainer.children.length > 0\n          ) {\n            domElementContainer.insertBefore(\n              _loaderContainer,\n              domElementContainer.children[0]\n            );\n          } else {\n            domElementContainer.appendChild(_loaderContainer);\n          }\n          if (_leaderboardViewIframe) {\n            _leaderboardViewIframe.style.opacity = '0';\n          }\n        } else {\n          try {\n            domElementContainer.removeChild(_loaderContainer);\n            if (_leaderboardViewIframe) {\n              _leaderboardViewIframe.style.opacity = '1';\n            }\n          } catch {}\n        }\n        return true;\n      };\n\n      const computeLeaderboardDisplayingIframe = function (\n        url: string\n      ): HTMLIFrameElement {\n        const iframe = document.createElement('iframe');\n\n        iframe.src = url;\n        iframe.id = 'leaderboard-view';\n        iframe.style.position = 'absolute';\n        // To trigger iframe loading and be able to listen to its events, use `opacity: 0` instead of `visibility: hidden` or `display: none`\n        iframe.style.opacity = '0';\n        iframe.style.pointerEvents = 'all';\n        iframe.style.backgroundColor = '#FFFFFF';\n        iframe.style.top = '0px';\n        iframe.style.height = '100%';\n        iframe.style.left = '0px';\n        iframe.style.width = '100%';\n        iframe.style.border = 'none';\n\n        return iframe;\n      };\n\n      export const displayLeaderboard = function (\n        runtimeScene: gdjs.RuntimeScene,\n        leaderboardId: string,\n        displayLoader: boolean\n      ) {\n        // First ensure we're not trying to display multiple times the same leaderboard (in which case\n        // we \"de-duplicate\" the request to display it).\n        if (leaderboardId === _requestedLeaderboardId) {\n          if (_leaderboardViewIframeLoading) {\n            logger.warn(\n              `Already loading the view for the requested loader (${leaderboardId}), ignoring.`\n            );\n            return;\n          }\n          if (_leaderboardViewIframeLoaded) {\n            logger.warn(\n              `Already loaded the view for the requested loader (${leaderboardId}), ignoring.`\n            );\n            return;\n          }\n        }\n\n        // We are now assured we want to display a new (or different) leaderboard: start loading it.\n        _requestedLeaderboardId = leaderboardId;\n        _leaderboardViewIframeErrored = false;\n        _leaderboardViewIframeLoaded = false;\n        _leaderboardViewIframeLoading = true;\n\n        if (displayLoader) {\n          displayLoaderInLeaderboardView(true, runtimeScene, {\n            callOnErrorIfDomElementContainerMissing: true,\n          });\n        }\n\n        const gameId = gdjs.projectData.properties.projectUuid;\n        const isDev = runtimeScene\n          .getGame()\n          .isUsingGDevelopDevelopmentEnvironment();\n        const targetUrl = `https://gd.games/games/${gameId}/leaderboard/${leaderboardId}?inGameEmbedded=true${\n          isDev ? '&dev=true' : ''\n        }`;\n        checkLeaderboardAvailability(targetUrl).then(\n          (isAvailable) => {\n            if (leaderboardId !== _requestedLeaderboardId) {\n              logger.warn(\n                `Received a response for leaderboard ${leaderboardId} though the last leaderboard requested is ${_requestedLeaderboardId}, ignoring this response.`\n              );\n              return;\n            }\n            if (!isAvailable) {\n              handleErrorDisplayingLeaderboard(\n                runtimeScene,\n                'Leaderboard data could not be fetched. Closing leaderboard view if there is one.'\n              );\n              return;\n            }\n\n            if (_leaderboardViewIframe) {\n              resetLeaderboardDisplayErrorTimeout(runtimeScene);\n              if (displayLoader) {\n                displayLoaderInLeaderboardView(true, runtimeScene, {\n                  callOnErrorIfDomElementContainerMissing: false,\n                });\n              }\n              _leaderboardViewIframe.src = targetUrl;\n            } else {\n              const domElementContainer = runtimeScene\n                .getGame()\n                .getRenderer()\n                .getDomElementContainer();\n              if (!domElementContainer) {\n                handleErrorDisplayingLeaderboard(\n                  runtimeScene,\n                  \"The div element covering the game couldn't be found, the leaderboard cannot be displayed.\"\n                );\n                return;\n              }\n\n              resetLeaderboardDisplayErrorTimeout(runtimeScene);\n\n              _leaderboardViewIframe = computeLeaderboardDisplayingIframe(\n                targetUrl\n              );\n              if (typeof window !== 'undefined') {\n                _leaderboardViewClosingCallback = (event: MessageEvent) => {\n                  receiveMessageFromLeaderboardView(\n                    runtimeScene,\n                    displayLoader,\n                    event\n                  );\n                };\n                (window as any).addEventListener(\n                  'message',\n                  _leaderboardViewClosingCallback,\n                  true\n                );\n              }\n              domElementContainer.appendChild(_leaderboardViewIframe);\n            }\n          },\n          (err) => {\n            logger.error(err);\n            handleErrorDisplayingLeaderboard(\n              runtimeScene,\n              'An error occurred when fetching leaderboard data. Closing leaderboard view if there is one.'\n            );\n            return;\n          }\n        );\n      };\n\n      export const isLeaderboardViewErrored = function (): boolean {\n        return _leaderboardViewIframeErrored;\n      };\n\n      export const isLeaderboardViewLoaded = function (): boolean {\n        return _leaderboardViewIframeLoaded;\n      };\n\n      export const isLeaderboardViewLoading = function (): boolean {\n        return _leaderboardViewIframeLoading;\n      };\n\n      export const closeLeaderboardView = function (\n        runtimeScene: gdjs.RuntimeScene\n      ) {\n        try {\n          displayLoaderInLeaderboardView(false, runtimeScene, {\n            callOnErrorIfDomElementContainerMissing: false,\n          });\n\n          if (!_leaderboardViewIframe) {\n            logger.info(\n              \"The iframe displaying the current leaderboard couldn't be found, the leaderboard view must be already closed.\"\n            );\n            return;\n          }\n          const domElementContainer = runtimeScene\n            .getGame()\n            .getRenderer()\n            .getDomElementContainer();\n          if (!domElementContainer) {\n            logger.info(\n              \"The div element covering the game couldn't be found, the leaderboard view must be already closed.\"\n            );\n            return;\n          }\n\n          if (typeof window !== 'undefined') {\n            (window as any).removeEventListener(\n              'message',\n              _leaderboardViewClosingCallback,\n              true\n            );\n            _leaderboardViewClosingCallback = null;\n          }\n          domElementContainer.removeChild(_leaderboardViewIframe);\n          _leaderboardViewIframe = null;\n        } finally {\n          // Don't reset the loading flag (the view of another leaderboard might be loading)\n          // or the error flag (we want to persist the error flag even after the view is closed),\n          // but reset the flag indicating the view is loaded (if it was).\n          _leaderboardViewIframeLoaded = false;\n\n          const gameCanvas = runtimeScene.getGame().getRenderer().getCanvas();\n          if (gameCanvas) gameCanvas.focus();\n        }\n      };\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
