{
  "version": 3,
  "sources": ["../../../../../../GDJS/Runtime/debugger-client/websocket-debugger-client.ts"],
  "sourcesContent": ["namespace gdjs {\n  const logger = new gdjs.Logger('Debugger client (websocket)');\n\n  /**\n   * This debugger client connects to a websocket server, exchanging\n   * and receiving messages with this server.\n   */\n  export class WebsocketDebuggerClient extends gdjs.AbstractDebuggerClient {\n    _ws: WebSocket | null;\n\n    /**\n     * @param path - The path of the property to modify, starting from the RuntimeGame.\n     */\n    constructor(runtimeGame: RuntimeGame) {\n      super(runtimeGame);\n      this._ws = null;\n      if (typeof WebSocket === 'undefined') {\n        logger.log(\"WebSocket is not defined, the debugger won't work.\");\n        return;\n      }\n\n      const that = this;\n      try {\n        // Find the WebSocket server to connect to using the address that was stored\n        // in the options by the editor. If not, try the default address, though it's unlikely\n        // to work - which is ok, the game can run without a debugger server.\n        const runtimeGameOptions = runtimeGame.getAdditionalOptions();\n        const address =\n          (runtimeGameOptions &&\n            runtimeGameOptions.websocketDebuggerServerAddress) ||\n          '127.0.0.1';\n        const port =\n          (runtimeGameOptions &&\n            runtimeGameOptions.websocketDebuggerServerPort) ||\n          '3030';\n        this._ws = new WebSocket('ws://' + address + ':' + port + '/');\n      } catch (e) {\n        logger.log(\n          \"WebSocket could not initialize, debugger/hot-reload won't work.\"\n        );\n        return;\n      }\n      this._ws.onopen = function open() {\n        logger.info('Debugger connection open');\n      };\n      this._ws.onclose = function close() {\n        logger.info('Debugger connection closed');\n      };\n      this._ws.onerror = function errored(error) {\n        logger.warn('Debugger client error:', error);\n      };\n      this._ws.onmessage = function incoming(message) {\n        let data: any = null;\n        try {\n          data = JSON.parse(message.data);\n        } catch (error) {\n          logger.info('Debugger received a badly formatted message:', error);\n        }\n        that.handleCommand(data);\n      };\n    }\n\n    protected _sendMessage(message: string) {\n      if (!this._ws) {\n        logger.warn('No connection to debugger opened to send a message.');\n        return;\n      }\n      if (this._ws.readyState === 1) this._ws.send(message);\n    }\n  }\n\n  //Register the class to let the engine use it.\n  // @ts-ignore\n  export const DebuggerClient = WebsocketDebuggerClient;\n}\n"],
  "mappings": "AAAA,GAAU,MAAV,UAAU,EAAV,CACE,KAAM,GAAS,GAAI,GAAK,OAAO,+BAMxB,eAAsC,GAAK,sBAAuB,CAMvE,YAAY,EAA0B,CACpC,MAAM,GAEN,GADA,KAAK,IAAM,KACP,MAAO,YAAc,YAAa,CACpC,EAAO,IAAI,sDACX,OAGF,KAAM,GAAO,KACb,GAAI,CAIF,KAAM,GAAqB,EAAY,uBACjC,EACH,GACC,EAAmB,gCACrB,YACI,EACH,GACC,EAAmB,6BACrB,OACF,KAAK,IAAM,GAAI,WAAU,QAAU,EAAU,IAAM,EAAO,UAC1D,CACA,EAAO,IACL,mEAEF,OAEF,KAAK,IAAI,OAAS,UAAgB,CAChC,EAAO,KAAK,6BAEd,KAAK,IAAI,QAAU,UAAiB,CAClC,EAAO,KAAK,+BAEd,KAAK,IAAI,QAAU,SAAiB,EAAO,CACzC,EAAO,KAAK,yBAA0B,IAExC,KAAK,IAAI,UAAY,SAAkB,EAAS,CAC9C,GAAI,GAAY,KAChB,GAAI,CACF,EAAO,KAAK,MAAM,EAAQ,YACnB,EAAP,CACA,EAAO,KAAK,+CAAgD,GAE9D,EAAK,cAAc,IAIb,aAAa,EAAiB,CACtC,GAAI,CAAC,KAAK,IAAK,CACb,EAAO,KAAK,uDACZ,OAEF,AAAI,KAAK,IAAI,aAAe,GAAG,KAAK,IAAI,KAAK,IA5D1C,EAAM,0BAkEA,iBAAiB,IAzEtB",
  "names": []
}
