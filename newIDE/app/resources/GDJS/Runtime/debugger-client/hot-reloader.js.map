{
  "version": 3,
  "sources": ["../../../../../../GDJS/Runtime/debugger-client/hot-reloader.ts"],
  "sourcesContent": ["namespace gdjs {\n  const logger = new gdjs.Logger('Hot reloader');\n  export type HotReloaderLog = {\n    message: string;\n    kind: 'fatal' | 'error' | 'warning' | 'info';\n  };\n\n  export type ChangedRuntimeBehavior = {\n    oldBehaviorConstructor: Function;\n    newBehaviorConstructor: Function;\n    behaviorTypeName: string;\n  };\n\n  /**\n   * Reload scripts/data of an exported game and applies the changes\n   * to the running runtime game.\n   */\n  export class HotReloader {\n    _runtimeGame: gdjs.RuntimeGame;\n    _reloadedScriptElement: Record<string, HTMLScriptElement> = {};\n    _logs: HotReloaderLog[] = [];\n    _alreadyLoadedScriptFiles: Record<string, boolean> = {};\n\n    /**\n     * @param runtimeGame - The `gdjs.RuntimeGame` to be hot-reloaded.\n     */\n    constructor(runtimeGame: gdjs.RuntimeGame) {\n      this._runtimeGame = runtimeGame;\n    }\n\n    static groupByPersistentUuid<\n      ObjectWithPersistentId extends { persistentUuid: string | null }\n    >(\n      objectsWithPersistentId: ObjectWithPersistentId[]\n    ): Record<string, ObjectWithPersistentId> {\n      return objectsWithPersistentId.reduce(function (objectsMap, object) {\n        if (object.persistentUuid) {\n          objectsMap[object.persistentUuid] = object;\n        }\n        return objectsMap;\n      }, {});\n    }\n\n    _canReloadScriptFile(srcFilename: string): boolean {\n      function endsWith(str: string, suffix: string): boolean {\n        const suffixPosition = str.indexOf(suffix);\n        return (\n          suffixPosition !== -1 && suffixPosition === str.length - suffix.length\n        );\n      }\n\n      // Never reload .h script files, as they are leaking by mistake from C++ extensions.\n      if (endsWith(srcFilename, '.h')) {\n        return false;\n      }\n\n      // Make sure some files are loaded only once.\n      if (this._alreadyLoadedScriptFiles[srcFilename]) {\n        if (\n          // Don't reload Box2d as it would confuse and crash the asm.js library.\n          endsWith(srcFilename, 'box2d.js') ||\n          // Don't reload sha256.js library.\n          endsWith(srcFilename, 'sha256.js') ||\n          // Don't reload shifty.js library.\n          endsWith(srcFilename, 'shifty.js') ||\n          // Don't reload shopify-buy library.\n          endsWith(srcFilename, 'shopify-buy.umd.polyfilled.min.js') ||\n          // Don't reload pixi-multistyle-text library.\n          endsWith(srcFilename, 'pixi-multistyle-text.umd.js') ||\n          // Don't reload pixi-tilemap library.\n          endsWith(srcFilename, 'pixi-tilemap.umd.js') ||\n          // Don't reload bondage.js library.\n          endsWith(srcFilename, 'bondage.min.js') ||\n          // Don't reload pixi-particles library.\n          endsWith(srcFilename, 'pixi-particles-pixi-renderer.min.js') ||\n          // Don't reload pixi-tilemap amd pixi-tilemap-helper libraries.\n          endsWith(srcFilename, 'pixi-tilemap.umd.js') ||\n          endsWith(srcFilename, 'pixi-tilemap-helper.js') ||\n          // Don't reload pako library (used in pixi-tilemap)\n          endsWith(srcFilename, 'pako/dist/pako.min')\n        ) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    _reloadScript(srcFilename: string): Promise<void> {\n      function endsWith(str: string, suffix: string): boolean {\n        const suffixPosition = str.indexOf(suffix);\n        return (\n          suffixPosition !== -1 && suffixPosition === str.length - suffix.length\n        );\n      }\n      if (!this._canReloadScriptFile(srcFilename)) {\n        this._logs.push({\n          kind: 'info',\n          message:\n            'Not reloading ' +\n            srcFilename +\n            ' as it is blocked for hot-reloading.',\n        });\n        return Promise.resolve();\n      }\n      const head = document.getElementsByTagName('head')[0];\n      if (!head) {\n        return Promise.reject(\n          new Error('No head element found, are you in a navigator?')\n        );\n      }\n      return new Promise((resolve, reject) => {\n        const existingScriptElement = this._reloadedScriptElement[srcFilename];\n        if (existingScriptElement) {\n          head.removeChild(existingScriptElement);\n        } else {\n          // Check if there is an existing scriptElement in head\n          const headScriptElements = head.getElementsByTagName('script');\n          for (let i = 0; i < headScriptElements.length; ++i) {\n            const scriptElement = headScriptElements[i];\n            if (endsWith(scriptElement.src, srcFilename)) {\n              head.removeChild(scriptElement);\n            }\n          }\n        }\n        const reloadedScriptElement = document.createElement('script');\n        reloadedScriptElement.src = srcFilename + '?timestamp=' + Date.now();\n        reloadedScriptElement.onload = () => {\n          resolve();\n        };\n        reloadedScriptElement.onerror = (event) => {\n          reject(event);\n        };\n        head.appendChild(reloadedScriptElement);\n        this._reloadedScriptElement[srcFilename] = reloadedScriptElement;\n      });\n    }\n\n    hotReload(): Promise<HotReloaderLog[]> {\n      logger.info('Hot reload started');\n      this._runtimeGame.pause(true);\n      this._logs = [];\n\n      // Save old data of the project, to be used to compute\n      // the difference between the old and new project data:\n\n      const oldProjectData: ProjectData = gdjs.projectData;\n\n      const oldScriptFiles = gdjs.runtimeGameOptions\n        .scriptFiles as RuntimeGameOptionsScriptFile[];\n\n      oldScriptFiles.forEach((scriptFile) => {\n        this._alreadyLoadedScriptFiles[scriptFile.path] = true;\n      });\n      const oldBehaviorConstructors: { [key: string]: Function } = {};\n\n      for (let behaviorTypeName in gdjs.behaviorsTypes.items) {\n        oldBehaviorConstructors[behaviorTypeName] =\n          gdjs.behaviorsTypes.items[behaviorTypeName];\n      }\n\n      // Reload projectData and runtimeGameOptions stored by convention in data.js:\n      return this._reloadScript('data.js').then(() => {\n        const newProjectData: ProjectData = gdjs.projectData;\n\n        const newRuntimeGameOptions: RuntimeGameOptions =\n          gdjs.runtimeGameOptions;\n\n        const newScriptFiles = newRuntimeGameOptions.scriptFiles as RuntimeGameOptionsScriptFile[];\n        const projectDataOnlyExport = !!newRuntimeGameOptions.projectDataOnlyExport;\n\n        // Reload the changed scripts, which will have the side effects of re-running\n        // the new scripts, potentially replacing the code of the free functions from\n        // extensions (which is fine) and registering updated behaviors (which will\n        // need to be re-instantiated in runtime objects).\n        return this.reloadScriptFiles(\n          newProjectData,\n          oldScriptFiles,\n          newScriptFiles,\n          projectDataOnlyExport\n        )\n          .then(() => {\n            const changedRuntimeBehaviors = this._computeChangedRuntimeBehaviors(\n              oldBehaviorConstructors,\n              gdjs.behaviorsTypes.items\n            );\n            return this._hotReloadRuntimeGame(\n              oldProjectData,\n              newProjectData,\n              changedRuntimeBehaviors,\n              this._runtimeGame\n            );\n          })\n          .catch((error) => {\n            const errorTarget = error.target;\n            if (errorTarget instanceof HTMLScriptElement) {\n              this._logs.push({\n                kind: 'fatal',\n                message: 'Unable to reload script:' + errorTarget.src,\n              });\n            } else {\n              this._logs.push({\n                kind: 'fatal',\n                message:\n                  'Unexpected error happened while hot-reloading:' +\n                  error.message,\n              });\n            }\n          })\n          .then(() => {\n            logger.info('Hot reload finished with logs:', this._logs);\n            this._runtimeGame.pause(false);\n            return this._logs;\n          });\n      });\n    }\n\n    _computeChangedRuntimeBehaviors(\n      oldBehaviorConstructors: Record<string, Function>,\n      newBehaviorConstructors: Record<string, Function>\n    ): ChangedRuntimeBehavior[] {\n      const changedRuntimeBehaviors: ChangedRuntimeBehavior[] = [];\n      for (let behaviorTypeName in oldBehaviorConstructors) {\n        const oldBehaviorConstructor =\n          oldBehaviorConstructors[behaviorTypeName];\n        const newBehaviorConstructor =\n          newBehaviorConstructors[behaviorTypeName];\n        if (!newBehaviorConstructor) {\n          this._logs.push({\n            kind: 'warning',\n            message:\n              'Behavior with type ' +\n              behaviorTypeName +\n              ' was removed from the registered behaviors in gdjs.',\n          });\n        } else {\n          if (oldBehaviorConstructor !== newBehaviorConstructor) {\n            this._logs.push({\n              kind: 'info',\n              message:\n                'Behavior with type ' +\n                behaviorTypeName +\n                ' was changed, and will be re-instantiated in gdjs.RuntimeObjects using it.',\n            });\n            changedRuntimeBehaviors.push({\n              oldBehaviorConstructor,\n              newBehaviorConstructor,\n              behaviorTypeName,\n            });\n          }\n        }\n      }\n      return changedRuntimeBehaviors;\n    }\n\n    reloadScriptFiles(\n      newProjectData: ProjectData,\n      oldScriptFiles: RuntimeGameOptionsScriptFile[],\n      newScriptFiles: RuntimeGameOptionsScriptFile[],\n      projectDataOnlyExport: boolean\n    ): Promise<void[]> {\n      const reloadPromises: Array<Promise<void>> = [];\n\n      // Reload events, only if they were exported.\n      if (!projectDataOnlyExport) {\n        newProjectData.layouts.forEach((_layoutData, index) => {\n          reloadPromises.push(this._reloadScript('code' + index + '.js'));\n        });\n      }\n      for (let i = 0; i < newScriptFiles.length; ++i) {\n        const newScriptFile = newScriptFiles[i];\n        const oldScriptFile = oldScriptFiles.filter(\n          (scriptFile) => scriptFile.path === newScriptFile.path\n        )[0];\n        if (!oldScriptFile) {\n          // Script file added\n          this._logs.push({\n            kind: 'info',\n            message:\n              'Loading ' +\n              newScriptFile.path +\n              ' as it was added to the list of scripts.',\n          });\n          reloadPromises.push(this._reloadScript(newScriptFile.path));\n        } else {\n          // Script file changed, which can be the case for extensions created\n          // from the editor, containing free functions or behaviors.\n          if (newScriptFile.hash !== oldScriptFile.hash) {\n            this._logs.push({\n              kind: 'info',\n              message:\n                'Reloading ' + newScriptFile.path + ' because it was changed.',\n            });\n            reloadPromises.push(this._reloadScript(newScriptFile.path));\n          }\n        }\n      }\n      for (let i = 0; i < oldScriptFiles.length; ++i) {\n        const oldScriptFile = oldScriptFiles[i];\n        const newScriptFile = newScriptFiles.filter(\n          (scriptFile) => scriptFile.path === oldScriptFile.path\n        )[0];\n\n        // A file may be removed because of a partial preview.\n        if (!newScriptFile && !projectDataOnlyExport) {\n          this._logs.push({\n            kind: 'warning',\n            message: 'Script file ' + oldScriptFile.path + ' was removed.',\n          });\n        }\n      }\n      return Promise.all(reloadPromises);\n    }\n\n    _hotReloadRuntimeGame(\n      oldProjectData: ProjectData,\n      newProjectData: ProjectData,\n      changedRuntimeBehaviors: ChangedRuntimeBehavior[],\n      runtimeGame: gdjs.RuntimeGame\n    ): Promise<void> {\n      return new Promise((resolve) => {\n        // Update project data and re-load assets (sound/image/font/json managers\n        // will take care of reloading only what is needed).\n        runtimeGame.setProjectData(newProjectData);\n        runtimeGame.loadAllAssets(() => {\n          this._hotReloadVariablesContainer(\n            oldProjectData.variables,\n            newProjectData.variables,\n            runtimeGame.getVariables()\n          );\n\n          // Reload runtime scenes\n          const sceneStack = runtimeGame.getSceneStack();\n          sceneStack._stack.forEach((runtimeScene) => {\n            const oldLayoutData = oldProjectData.layouts.filter(\n              (layoutData) => layoutData.name === runtimeScene.getName()\n            )[0];\n            const newLayoutData = newProjectData.layouts.filter(\n              (layoutData) => layoutData.name === runtimeScene.getName()\n            )[0];\n            if (oldLayoutData && newLayoutData) {\n              this._hotReloadRuntimeScene(\n                oldLayoutData,\n                newLayoutData,\n                changedRuntimeBehaviors,\n                runtimeScene\n              );\n            } else {\n              // A scene was removed. Not hot-reloading this.\n              this._logs.push({\n                kind: 'error',\n                message:\n                  'Scene ' +\n                  oldLayoutData.name +\n                  ' was removed. A fresh preview should be launched.',\n              });\n            }\n          });\n\n          // Reload changes in external layouts\n          newProjectData.externalLayouts.forEach((newExternalLayoutData) => {\n            const oldExternalLayoutData = oldProjectData.externalLayouts.filter(\n              (externalLayoutData) =>\n                externalLayoutData.name === newExternalLayoutData.name\n            )[0];\n            if (\n              oldExternalLayoutData &&\n              // Check if there are actual changes, to avoid useless work trying to\n              // hot-reload all the scenes.\n              !HotReloader.deepEqual(\n                oldExternalLayoutData,\n                newExternalLayoutData\n              )\n            ) {\n              sceneStack._stack.forEach((runtimeScene) => {\n                this._hotReloadRuntimeSceneInstances(\n                  oldExternalLayoutData.instances,\n                  newExternalLayoutData.instances,\n                  runtimeScene\n                );\n              });\n            }\n          });\n          resolve();\n        });\n      });\n    }\n\n    _hotReloadVariablesContainer(\n      oldVariablesData: RootVariableData[],\n      newVariablesData: RootVariableData[],\n      variablesContainer: gdjs.VariablesContainer\n    ): void {\n      newVariablesData.forEach((newVariableData) => {\n        const variableName = newVariableData.name;\n        const oldVariableData = oldVariablesData.find(\n          (variable) => variable.name === variableName\n        );\n        const variable = variablesContainer.get(newVariableData.name);\n\n        if (!oldVariableData) {\n          // New variable\n          variablesContainer.add(\n            variableName,\n            new gdjs.Variable(newVariableData)\n          );\n        } else if (\n          gdjs.Variable.isPrimitive(newVariableData.type || 'number') &&\n          (oldVariableData.value !== newVariableData.value ||\n            !gdjs.Variable.isPrimitive(oldVariableData.type || 'number'))\n        ) {\n          // Variable value was changed or was converted from\n          // a structure to a variable with value.\n          variablesContainer.remove(variableName);\n          variablesContainer.add(\n            variableName,\n            new gdjs.Variable(newVariableData)\n          );\n        } else if (\n          !gdjs.Variable.isPrimitive(newVariableData.type || 'number')\n        ) {\n          // Variable is a structure or array (or was converted from a primitive\n          // to one of those).\n          if (newVariableData.type === 'structure')\n            this._hotReloadStructureVariable(\n              //@ts-ignore If the type is structure, it is assured that the children have a name\n              oldVariableData.children,\n              newVariableData.children,\n              variable\n            );\n          else {\n            // Arrays cannot be hot reloaded.\n            // As indices can change at runtime, and in the IDE, they can be desynchronized.\n            // It will in that case mess up the whole array,\n            // and there is no way to know if that was the case.\n            //\n            // We therefore just replace the old array with the new one.\n            variablesContainer.remove(variableName);\n            variablesContainer.add(\n              variableName,\n              new gdjs.Variable(newVariableData)\n            );\n          }\n        }\n      });\n      oldVariablesData.forEach((oldVariableData) => {\n        const newVariableData = newVariablesData.find(\n          (variable) => variable.name === oldVariableData.name\n        );\n\n        if (!newVariableData) {\n          // Variable was removed\n          variablesContainer.remove(oldVariableData.name);\n        }\n      });\n    }\n\n    _hotReloadStructureVariable(\n      oldChildren: RootVariableData[],\n      newChildren: RootVariableData[],\n      variable: gdjs.Variable\n    ): void {\n      if (oldChildren) {\n        oldChildren.forEach((oldChildVariableData) => {\n          const newChildVariableData = newChildren.find(\n            (childVariableData) =>\n              childVariableData.name === oldChildVariableData.name\n          );\n\n          if (!newChildVariableData) {\n            // Child variable was removed.\n            variable.removeChild(oldChildVariableData.name);\n          } else if (\n            gdjs.Variable.isPrimitive(newChildVariableData.type || 'number') &&\n            (oldChildVariableData.value !== newChildVariableData.value ||\n              !gdjs.Variable.isPrimitive(oldChildVariableData.type || 'number'))\n          ) {\n            // The child variable value was changed or was converted from\n            // structure to a variable with value.\n            variable.addChild(\n              newChildVariableData.name,\n              new gdjs.Variable(newChildVariableData)\n            );\n          } else if (\n            !gdjs.Variable.isPrimitive(newChildVariableData.type || 'number')\n          ) {\n            // Variable is a structure or array (or was converted from a primitive\n            // to one of those).\n            if (newChildVariableData.type === 'structure')\n              this._hotReloadStructureVariable(\n                //@ts-ignore If the type is structure, it is assured that the children have a name\n                oldChildVariableData.children,\n                newChildVariableData.children as Required<VariableData>[],\n                variable.getChild(newChildVariableData.name)\n              );\n            else {\n              // Arrays cannot be hot reloaded.\n              // As indices can change at runtime, and in the IDE, they can be desynchronized.\n              // It will in that case mess up the whole array,\n              // and there is no way to know if that was the case.\n              //\n              // We therefore just replace the old array with the new one.\n              variable.addChild(\n                newChildVariableData.name,\n                new gdjs.Variable(newChildVariableData)\n              );\n            }\n          }\n        });\n        newChildren.forEach((newChildVariableData) => {\n          const oldChildVariableData = oldChildren.find(\n            (childVariableData) =>\n              childVariableData.name === newChildVariableData.name\n          );\n\n          if (!oldChildVariableData) {\n            // Child variable was added\n            variable.addChild(\n              newChildVariableData.name,\n              new gdjs.Variable(newChildVariableData)\n            );\n          }\n        });\n      } else {\n        // Variable was converted from a value to a structure:\n        newChildren.forEach((newChildVariableData) => {\n          variable.addChild(\n            newChildVariableData.name,\n            new gdjs.Variable(newChildVariableData)\n          );\n        });\n      }\n    }\n\n    _hotReloadRuntimeScene(\n      oldLayoutData: LayoutData,\n      newLayoutData: LayoutData,\n      changedRuntimeBehaviors: ChangedRuntimeBehavior[],\n      runtimeScene: gdjs.RuntimeScene\n    ): void {\n      runtimeScene.setBackgroundColor(\n        newLayoutData.r,\n        newLayoutData.v,\n        newLayoutData.b\n      );\n      if (oldLayoutData.title !== newLayoutData.title) {\n        runtimeScene\n          .getGame()\n          .getRenderer()\n          .setWindowTitle(newLayoutData.title);\n      }\n      this._hotReloadVariablesContainer(\n        oldLayoutData.variables as Required<VariableData>[],\n        newLayoutData.variables as Required<VariableData>[],\n        runtimeScene.getVariables()\n      );\n      this._hotReloadRuntimeSceneBehaviorsSharedData(\n        oldLayoutData.behaviorsSharedData,\n        newLayoutData.behaviorsSharedData,\n        runtimeScene\n      );\n\n      // Re-instantiate any gdjs.RuntimeBehavior that was changed.\n      this._reinstantiateRuntimeSceneRuntimeBehaviors(\n        changedRuntimeBehaviors,\n        newLayoutData.objects,\n        runtimeScene\n      );\n      this._hotReloadRuntimeSceneObjects(\n        oldLayoutData.objects,\n        newLayoutData.objects,\n        runtimeScene\n      );\n      this._hotReloadRuntimeSceneInstances(\n        oldLayoutData.instances,\n        newLayoutData.instances,\n        runtimeScene\n      );\n      this._hotReloadRuntimeSceneLayers(\n        oldLayoutData.layers,\n        newLayoutData.layers,\n        runtimeScene\n      );\n\n      // Update the events generated code launched at each frame. Events generated code\n      // script files were already reloaded at the beginning of the hot-reload. Note that\n      // if they have not changed, it's still fine to call this, it will be basically a\n      // no-op.\n      runtimeScene.setEventsGeneratedCodeFunction(newLayoutData);\n    }\n\n    _hotReloadRuntimeSceneBehaviorsSharedData(\n      oldBehaviorsSharedData: BehaviorSharedData[],\n      newBehaviorsSharedData: BehaviorSharedData[],\n      runtimeScene: gdjs.RuntimeScene\n    ): void {\n      oldBehaviorsSharedData.forEach((oldBehaviorSharedData) => {\n        const name = oldBehaviorSharedData.name;\n        const newBehaviorSharedData = newBehaviorsSharedData.filter(\n          (behaviorSharedData) => behaviorSharedData.name === name\n        )[0];\n        if (!newBehaviorSharedData) {\n          // Behavior shared data was removed.\n          runtimeScene.setInitialSharedDataForBehavior(\n            oldBehaviorSharedData.name,\n            null\n          );\n        } else {\n          if (\n            !HotReloader.deepEqual(oldBehaviorSharedData, newBehaviorSharedData)\n          ) {\n            // Behavior shared data was modified\n            runtimeScene.setInitialSharedDataForBehavior(\n              newBehaviorSharedData.name,\n              newBehaviorSharedData\n            );\n          }\n        }\n      });\n      newBehaviorsSharedData.forEach((newBehaviorSharedData) => {\n        const name = newBehaviorSharedData.name;\n        const oldBehaviorSharedData = oldBehaviorsSharedData.filter(\n          (behaviorSharedData) => behaviorSharedData.name === name\n        )[0];\n        if (!oldBehaviorSharedData) {\n          // Behavior shared data was added\n          runtimeScene.setInitialSharedDataForBehavior(\n            newBehaviorSharedData.name,\n            newBehaviorSharedData\n          );\n        }\n      });\n    }\n\n    _reinstantiateRuntimeSceneRuntimeBehaviors(\n      changedRuntimeBehaviors: ChangedRuntimeBehavior[],\n      newObjects: ObjectData[],\n      runtimeScene: gdjs.RuntimeScene\n    ): void {\n      newObjects.forEach((newObjectData) => {\n        const objectName = newObjectData.name;\n        const newBehaviors = newObjectData.behaviors;\n        const runtimeObjects = runtimeScene.getObjects(objectName)!;\n        changedRuntimeBehaviors.forEach((changedRuntimeBehavior) => {\n          const behaviorTypeName = changedRuntimeBehavior.behaviorTypeName;\n\n          // If the changed behavior is used by the object, re-instantiate\n          // it.\n          newBehaviors\n            .filter((behaviorData) => behaviorData.type === behaviorTypeName)\n            .forEach((changedBehaviorNewData) => {\n              const name = changedBehaviorNewData.name;\n              this._logs.push({\n                kind: 'info',\n                message:\n                  'Re-instantiating behavior named \"' +\n                  name +\n                  '\" for instances of object \"' +\n                  objectName +\n                  '\".',\n              });\n              runtimeObjects.forEach((runtimeObject) => {\n                this._reinstantiateRuntimeObjectRuntimeBehavior(\n                  changedBehaviorNewData,\n                  runtimeObject\n                );\n              });\n            });\n        });\n      });\n    }\n\n    _reinstantiateRuntimeObjectRuntimeBehavior(\n      behaviorData: BehaviorData,\n      runtimeObject: gdjs.RuntimeObject\n    ): void {\n      const behaviorName = behaviorData.name;\n      const oldRuntimeBehavior = runtimeObject.getBehavior(behaviorName);\n      if (!oldRuntimeBehavior) {\n        return;\n      }\n\n      // Remove and re-add the behavior so that it's using the newly\n      // registered gdjs.RuntimeBehavior.\n      runtimeObject.removeBehavior(behaviorName);\n      runtimeObject.addNewBehavior(behaviorData);\n      const newRuntimeBehavior = runtimeObject.getBehavior(behaviorName);\n      if (!newRuntimeBehavior) {\n        this._logs.push({\n          kind: 'error',\n          message:\n            'Could not create behavior ' +\n            behaviorName +\n            ' (type: ' +\n            behaviorData.type +\n            ') for object ' +\n            runtimeObject.getName(),\n        });\n        return;\n      }\n\n      // Copy the properties from the old behavior to the new one.\n      for (let behaviorProperty in oldRuntimeBehavior) {\n        if (!oldRuntimeBehavior.hasOwnProperty(behaviorProperty)) {\n          continue;\n        }\n        if (behaviorProperty === '_behaviorData') {\n          // For property \"_behaviorData\"  that we know to be an object,\n          // do a copy of each property of\n          // this object so that we keep the new ones (useful if a new property was added).\n          newRuntimeBehavior[behaviorProperty] =\n            newRuntimeBehavior[behaviorProperty] || {};\n          for (let property in oldRuntimeBehavior[behaviorProperty]) {\n            newRuntimeBehavior[behaviorProperty][property] =\n              oldRuntimeBehavior[behaviorProperty][property];\n          }\n        } else {\n          newRuntimeBehavior[behaviorProperty] =\n            oldRuntimeBehavior[behaviorProperty];\n        }\n      }\n      return;\n    }\n\n    _hotReloadRuntimeSceneObjects(\n      oldObjects: ObjectData[],\n      newObjects: ObjectData[],\n      runtimeScene: gdjs.RuntimeScene\n    ): void {\n      oldObjects.forEach((oldObjectData) => {\n        const name = oldObjectData.name;\n        const newObjectData = newObjects.filter(\n          (objectData) => objectData.name === name\n        )[0];\n\n        // Note: if an object is renamed in the editor, it will be considered as removed,\n        // and the new object name as a new object to register.\n        // It's not ideal because living instances of the object will be destroyed,\n        // but it would be complex to iterate over instances of the object and change\n        // its name (it's not expected to change).\n        if (!newObjectData || oldObjectData.type !== newObjectData.type) {\n          // Object was removed or object type was changed (considered as a removal of the old object)\n          runtimeScene.unregisterObject(name);\n        } else {\n          if (runtimeScene.isObjectRegistered(name)) {\n            this._hotReloadRuntimeSceneObject(\n              oldObjectData,\n              newObjectData,\n              runtimeScene\n            );\n          }\n        }\n      });\n      newObjects.forEach((newObjectData) => {\n        const name = newObjectData.name;\n        const oldObjectData = oldObjects.filter(\n          (layerData) => layerData.name === name\n        )[0];\n        if (\n          (!oldObjectData || oldObjectData.type !== newObjectData.type) &&\n          !runtimeScene.isObjectRegistered(name)\n        ) {\n          // Object was added or object type was changed (considered as adding the new object)\n          runtimeScene.registerObject(newObjectData);\n        }\n      });\n    }\n\n    _hotReloadRuntimeSceneObject(\n      oldObjectData: ObjectData,\n      newObjectData: ObjectData,\n      runtimeScene: gdjs.RuntimeScene\n    ): void {\n      let hotReloadSucceeded = true;\n      if (!HotReloader.deepEqual(oldObjectData, newObjectData)) {\n        this._logs.push({\n          kind: 'info',\n          message:\n            'Object \"' +\n            newObjectData.name +\n            '\" was modified and is hot-reloaded.',\n        });\n\n        // Register the updated object data, used for new instances.\n        runtimeScene.updateObject(newObjectData);\n\n        // Update existing instances\n        const runtimeObjects = runtimeScene.getObjects(newObjectData.name)!;\n\n        // Update instances state\n        runtimeObjects.forEach((runtimeObject) => {\n          // Update the runtime object\n          hotReloadSucceeded =\n            runtimeObject.updateFromObjectData(oldObjectData, newObjectData) &&\n            hotReloadSucceeded;\n        });\n\n        // Don't update the variables, behaviors and effects for each runtime object to avoid\n        // doing the check for differences for every single object.\n\n        // Update variables\n        runtimeObjects.forEach((runtimeObject) => {\n          this._hotReloadVariablesContainer(\n            oldObjectData.variables as Required<VariableData>[],\n            newObjectData.variables as Required<VariableData>[],\n            runtimeObject.getVariables()\n          );\n        });\n\n        // Update behaviors\n        this._hotReloadRuntimeObjectsBehaviors(\n          oldObjectData.behaviors,\n          newObjectData.behaviors,\n          runtimeObjects\n        );\n\n        // Update effects\n        this._hotReloadRuntimeObjectsEffects(\n          oldObjectData.effects,\n          newObjectData.effects,\n          runtimeObjects\n        );\n      }\n      if (!hotReloadSucceeded) {\n        this._logs.push({\n          kind: 'error',\n          message:\n            'Object \"' +\n            newObjectData.name +\n            '\" could not be hot-reloaded. A fresh preview should be run.',\n        });\n      }\n    }\n\n    _hotReloadRuntimeObjectsBehaviors(\n      oldBehaviors: BehaviorData[],\n      newBehaviors: BehaviorData[],\n      runtimeObjects: gdjs.RuntimeObject[]\n    ): void {\n      oldBehaviors.forEach((oldBehaviorData) => {\n        const name = oldBehaviorData.name;\n        const newBehaviorData = newBehaviors.filter(\n          (behaviorData) => behaviorData.name === name\n        )[0];\n        if (!newBehaviorData) {\n          // Behavior was removed\n          runtimeObjects.forEach((runtimeObject) => {\n            if (runtimeObject.hasBehavior(name)) {\n              if (!runtimeObject.removeBehavior(name)) {\n                this._logs.push({\n                  kind: 'error',\n                  message:\n                    'Behavior ' +\n                    name +\n                    ' could not be removed from object' +\n                    runtimeObject.getName(),\n                });\n              }\n            }\n          });\n        } else {\n          if (!HotReloader.deepEqual(oldBehaviorData, newBehaviorData)) {\n            let hotReloadSucceeded = true;\n            runtimeObjects.forEach((runtimeObject) => {\n              const runtimeBehavior = runtimeObject.getBehavior(\n                newBehaviorData.name\n              );\n              if (runtimeBehavior) {\n                hotReloadSucceeded =\n                  this._hotReloadRuntimeBehavior(\n                    oldBehaviorData,\n                    newBehaviorData,\n                    runtimeBehavior\n                  ) && hotReloadSucceeded;\n              }\n            });\n            if (!hotReloadSucceeded) {\n              this._logs.push({\n                kind: 'error',\n                message:\n                  newBehaviorData.name + ' behavior could not be hot-reloaded.',\n              });\n            }\n          }\n        }\n      });\n      newBehaviors.forEach((newBehaviorData) => {\n        const name = newBehaviorData.name;\n        const oldBehaviorData = oldBehaviors.filter(\n          (layerData) => layerData.name === name\n        )[0];\n        if (!oldBehaviorData) {\n          // Behavior was added\n          let hotReloadSucceeded = true;\n          runtimeObjects.forEach((runtimeObject) => {\n            hotReloadSucceeded =\n              runtimeObject.addNewBehavior(newBehaviorData) &&\n              hotReloadSucceeded;\n          });\n          if (!hotReloadSucceeded) {\n            this._logs.push({\n              kind: 'error',\n              message:\n                newBehaviorData.name +\n                ' behavior could not be added during hot-reload.',\n            });\n          }\n        }\n      });\n    }\n\n    _hotReloadRuntimeObjectsEffects(\n      oldEffects: EffectData[],\n      newEffects: EffectData[],\n      runtimeObjects: RuntimeObject[]\n    ): void {\n      oldEffects.forEach((oldEffectData) => {\n        const name = oldEffectData.name;\n        const newEffectData = newEffects.filter(\n          (effectData) => effectData.name === name\n        )[0];\n        if (!newEffectData) {\n          // Effect was removed.\n          runtimeObjects.forEach((runtimeObject) => {\n            if (runtimeObject.hasEffect(name)) {\n              if (!runtimeObject.removeEffect(name)) {\n                this._logs.push({\n                  kind: 'error',\n                  message:\n                    'Effect ' +\n                    name +\n                    ' could not be removed from object' +\n                    runtimeObject.getName(),\n                });\n              }\n            }\n          });\n        } else {\n          if (!HotReloader.deepEqual(oldEffectData, newEffectData)) {\n            let hotReloadSucceeded = true;\n            runtimeObjects.forEach((runtimeObject) => {\n              if (oldEffectData.effectType === newEffectData.effectType) {\n                hotReloadSucceeded =\n                  runtimeObject.updateAllEffectParameters(newEffectData) &&\n                  hotReloadSucceeded;\n              } else {\n                // Another effect type was applied\n                runtimeObject.removeEffect(oldEffectData.name);\n                runtimeObject.addEffect(newEffectData);\n              }\n            });\n            if (!hotReloadSucceeded) {\n              this._logs.push({\n                kind: 'error',\n                message:\n                  newEffectData.name + ' effect could not be hot-reloaded.',\n              });\n            }\n          }\n        }\n      });\n      newEffects.forEach((newEffectData) => {\n        const name = newEffectData.name;\n        const oldEffectData = oldEffects.filter(\n          (oldEffectData) => oldEffectData.name === name\n        )[0];\n        if (!oldEffectData) {\n          // Effect was added\n          let hotReloadSucceeded = true;\n          runtimeObjects.forEach((runtimeObject) => {\n            hotReloadSucceeded =\n              runtimeObject.addEffect(newEffectData) && hotReloadSucceeded;\n          });\n          if (!hotReloadSucceeded) {\n            this._logs.push({\n              kind: 'error',\n              message:\n                newEffectData.name +\n                ' effect could not be added during hot-reload.',\n            });\n          }\n        }\n      });\n    }\n\n    /**\n     * @returns true if hot-reload succeeded, false otherwise.\n     */\n    _hotReloadRuntimeBehavior(\n      oldBehaviorData: BehaviorData,\n      newBehaviorData: BehaviorData,\n      runtimeBehavior: gdjs.RuntimeBehavior\n    ): boolean {\n      // Don't check here for deep equality between oldBehaviorData and newBehaviorData.\n      // This would be too costly to do for each runtime object.\n      // It's supposed to be done once by the caller.\n      return runtimeBehavior.updateFromBehaviorData(\n        oldBehaviorData,\n        newBehaviorData\n      );\n    }\n\n    _hotReloadRuntimeSceneLayers(\n      oldLayers: LayerData[],\n      newLayers: LayerData[],\n      runtimeScene: gdjs.RuntimeScene\n    ): void {\n      oldLayers.forEach((oldLayerData) => {\n        const name = oldLayerData.name;\n        const newLayerData = newLayers.filter(\n          (layerData) => layerData.name === name\n        )[0];\n        if (!newLayerData) {\n          // Layer was removed\n          runtimeScene.removeLayer(name);\n        } else {\n          if (runtimeScene.hasLayer(name)) {\n            const layer = runtimeScene.getLayer(name);\n            this._hotReloadRuntimeLayer(oldLayerData, newLayerData, layer);\n          }\n        }\n      });\n      newLayers.forEach((newLayerData) => {\n        const name = newLayerData.name;\n        const oldLayerData = oldLayers.filter(\n          (layerData) => layerData.name === name\n        )[0];\n        if (!oldLayerData && !runtimeScene.hasLayer(name)) {\n          // Layer was added\n          runtimeScene.addLayer(newLayerData);\n        }\n      });\n      newLayers.forEach((newLayerData, index) => {\n        runtimeScene.setLayerIndex(newLayerData.name, index);\n      });\n    }\n\n    _hotReloadRuntimeLayer(\n      oldLayer: LayerData,\n      newLayer: LayerData,\n      runtimeLayer: gdjs.RuntimeLayer\n    ): void {\n      // Properties\n      if (oldLayer.visibility !== newLayer.visibility) {\n        runtimeLayer.show(newLayer.visibility);\n      }\n      if (newLayer.isLightingLayer) {\n        if (\n          oldLayer.ambientLightColorR !== newLayer.ambientLightColorR ||\n          oldLayer.ambientLightColorG !== newLayer.ambientLightColorG ||\n          oldLayer.ambientLightColorB !== newLayer.ambientLightColorB\n        ) {\n          runtimeLayer.setClearColor(\n            newLayer.ambientLightColorR,\n            newLayer.ambientLightColorG,\n            newLayer.ambientLightColorB\n          );\n        }\n        if (oldLayer.followBaseLayerCamera !== newLayer.followBaseLayerCamera) {\n          runtimeLayer.setFollowBaseLayerCamera(newLayer.followBaseLayerCamera);\n        }\n      }\n\n      // Rendering type can't be easily changed at runtime.\n      if (oldLayer.renderingType !== newLayer.renderingType) {\n        this._logs.push({\n          kind: 'error',\n          message: `Could not change the rendering type (2D, 3D...) layer at runtime (for layer \"${newLayer.name}\").`,\n        });\n      }\n      if (newLayer.isLightingLayer !== oldLayer.isLightingLayer) {\n        this._logs.push({\n          kind: 'error',\n          message: `Could not add/remove a lighting layer at runtime (for layer \"${newLayer.name}\").`,\n        });\n      }\n\n      // Effects\n      this._hotReloadRuntimeLayerEffects(\n        oldLayer.effects,\n        newLayer.effects,\n        runtimeLayer\n      );\n    }\n\n    _hotReloadRuntimeLayerEffects(\n      oldEffectsData: EffectData[],\n      newEffectsData: EffectData[],\n      runtimeLayer: gdjs.RuntimeLayer\n    ): void {\n      oldEffectsData.forEach((oldEffectData) => {\n        const name = oldEffectData.name;\n        const newEffectData = newEffectsData.filter(\n          (effectData) => effectData.name === name\n        )[0];\n        if (!newEffectData) {\n          // Effect was removed\n          runtimeLayer.removeEffect(name);\n        } else {\n          if (runtimeLayer.hasEffect(name)) {\n            if (oldEffectData.effectType !== newEffectData.effectType) {\n              // Effect changed type, consider it was removed and added back.\n              runtimeLayer.removeEffect(name);\n              runtimeLayer.addEffect(newEffectData);\n            } else {\n              this._hotReloadRuntimeLayerEffect(\n                oldEffectData,\n                newEffectData,\n                runtimeLayer,\n                name\n              );\n            }\n          }\n        }\n      });\n      newEffectsData.forEach((newEffectData) => {\n        const name = newEffectData.name;\n        const oldEffectData = oldEffectsData.filter(\n          (layerData) => layerData.name === name\n        )[0];\n        if (!oldEffectData && !runtimeLayer.hasEffect(name)) {\n          // Effect was added\n          runtimeLayer.addEffect(newEffectData);\n        }\n      });\n    }\n\n    _hotReloadRuntimeLayerEffect(\n      oldEffectData: EffectData,\n      newEffectData: EffectData,\n      runtimeLayer: gdjs.RuntimeLayer,\n      effectName: string\n    ): void {\n      // We consider oldEffectData.effectType and newEffectData.effectType\n      // are the same - it's responsibility of the caller to verify this.\n      for (let parameterName in newEffectData.booleanParameters) {\n        const value = newEffectData.booleanParameters[parameterName];\n        if (value !== oldEffectData.booleanParameters[parameterName]) {\n          runtimeLayer.setEffectBooleanParameter(\n            effectName,\n            parameterName,\n            value\n          );\n        }\n      }\n      for (let parameterName in newEffectData.doubleParameters) {\n        const value = newEffectData.doubleParameters[parameterName];\n        if (value !== oldEffectData.doubleParameters[parameterName]) {\n          runtimeLayer.setEffectDoubleParameter(\n            effectName,\n            parameterName,\n            value\n          );\n        }\n      }\n      for (let parameterName in newEffectData.stringParameters) {\n        const value = newEffectData.stringParameters[parameterName];\n        if (value !== oldEffectData.stringParameters[parameterName]) {\n          runtimeLayer.setEffectStringParameter(\n            effectName,\n            parameterName,\n            value\n          );\n        }\n      }\n    }\n\n    _hotReloadRuntimeSceneInstances(\n      oldInstances: InstanceData[],\n      newInstances: InstanceData[],\n      runtimeScene: gdjs.RuntimeScene\n    ): void {\n      const runtimeObjects = runtimeScene.getAdhocListOfAllInstances();\n      const groupedOldInstances: {\n        [key: number]: InstanceData;\n      } = HotReloader.groupByPersistentUuid(oldInstances);\n      const groupedNewInstances: {\n        [key: number]: InstanceData;\n      } = HotReloader.groupByPersistentUuid(newInstances);\n      const groupedRuntimeObjects: {\n        [key: number]: gdjs.RuntimeObject;\n      } = HotReloader.groupByPersistentUuid(runtimeObjects);\n      for (let persistentUuid in groupedOldInstances) {\n        const oldInstance = groupedOldInstances[persistentUuid];\n        const newInstance = groupedNewInstances[persistentUuid];\n        const runtimeObject = groupedRuntimeObjects[persistentUuid];\n        if (\n          oldInstance &&\n          (!newInstance || oldInstance.name !== newInstance.name)\n        ) {\n          // Instance was deleted (or object name changed, in which case it will be re-created later)\n          if (runtimeObject) {\n            runtimeObject.deleteFromScene(runtimeScene);\n          }\n        } else {\n          if (oldInstance && newInstance && runtimeObject) {\n            // Instance was not deleted nor created, maybe modified (or not):\n            this._hotReloadRuntimeInstance(\n              oldInstance,\n              newInstance,\n              runtimeObject\n            );\n          }\n        }\n      }\n      for (let persistentUuid in groupedNewInstances) {\n        const oldInstance = groupedOldInstances[persistentUuid];\n        const newInstance = groupedNewInstances[persistentUuid];\n        const runtimeObject = groupedRuntimeObjects[persistentUuid];\n        if (\n          newInstance &&\n          (!oldInstance || oldInstance.name !== newInstance.name) &&\n          !runtimeObject\n        ) {\n          // Instance was created (or object name changed, in which case it was destroyed previously)\n          // and we verified that runtimeObject does not exist.\n          runtimeScene.createObjectsFrom(\n            [newInstance],\n            0,\n            0,\n            /*trackByPersistentUuid=*/\n            true\n          );\n        }\n      }\n    }\n\n    _hotReloadRuntimeInstance(\n      oldInstance: InstanceData,\n      newInstance: InstanceData,\n      runtimeObject: gdjs.RuntimeObject\n    ): void {\n      let somethingChanged = false;\n\n      // Check if default properties changed\n      if (oldInstance.x !== newInstance.x) {\n        runtimeObject.setX(newInstance.x);\n        somethingChanged = true;\n      }\n      if (oldInstance.y !== newInstance.y) {\n        runtimeObject.setY(newInstance.y);\n        somethingChanged = true;\n      }\n      if (oldInstance.angle !== newInstance.angle) {\n        runtimeObject.setAngle(newInstance.angle);\n        somethingChanged = true;\n      }\n      if (oldInstance.zOrder !== newInstance.zOrder) {\n        runtimeObject.setZOrder(newInstance.zOrder);\n        somethingChanged = true;\n      }\n      if (oldInstance.layer !== newInstance.layer) {\n        runtimeObject.setLayer(newInstance.layer);\n        somethingChanged = true;\n      }\n      if (\n        gdjs.RuntimeObject3D &&\n        runtimeObject instanceof gdjs.RuntimeObject3D\n      ) {\n        if (oldInstance.z !== newInstance.z && newInstance.z !== undefined) {\n          runtimeObject.setZ(newInstance.z);\n          somethingChanged = true;\n        }\n        if (\n          oldInstance.rotationX !== newInstance.rotationX &&\n          newInstance.rotationX !== undefined\n        ) {\n          runtimeObject.setRotationX(newInstance.rotationX);\n          somethingChanged = true;\n        }\n        if (\n          oldInstance.rotationY !== newInstance.rotationY &&\n          newInstance.rotationY !== undefined\n        ) {\n          runtimeObject.setRotationY(newInstance.rotationY);\n          somethingChanged = true;\n        }\n      }\n\n      // Check if size changed\n      let sizeChanged = false;\n      if (newInstance.customSize) {\n        if (!oldInstance.customSize) {\n          // A custom size was set\n          runtimeObject.setWidth(newInstance.width);\n          runtimeObject.setHeight(newInstance.height);\n          somethingChanged = true;\n          sizeChanged = true;\n        } else {\n          // The custom size was changed\n          if (oldInstance.width !== newInstance.width) {\n            runtimeObject.setWidth(newInstance.width);\n            somethingChanged = true;\n            sizeChanged = true;\n          }\n          if (oldInstance.height !== newInstance.height) {\n            runtimeObject.setHeight(newInstance.height);\n            somethingChanged = true;\n            sizeChanged = true;\n          }\n        }\n      } else {\n        if (!newInstance.customSize && oldInstance.customSize) {\n          // The custom size was removed. Just flag the size as changed\n          // and hope the object will handle this in\n          // `extraInitializationFromInitialInstance`.\n          sizeChanged = true;\n        }\n      }\n      if (\n        gdjs.RuntimeObject3D &&\n        runtimeObject instanceof gdjs.RuntimeObject3D\n      ) {\n        // A custom depth was set or changed\n        if (\n          oldInstance.depth !== newInstance.depth &&\n          newInstance.depth !== undefined\n        ) {\n          runtimeObject.setDepth(newInstance.depth);\n          somethingChanged = true;\n          sizeChanged = true;\n        } else if (\n          newInstance.depth === undefined &&\n          oldInstance.depth !== undefined\n        ) {\n          // The custom depth was removed. Just flag the depth as changed\n          // and hope the object will handle this in\n          // `extraInitializationFromInitialInstance`.\n          sizeChanged = true;\n        }\n      }\n\n      // Update variables\n      this._hotReloadVariablesContainer(\n        oldInstance.initialVariables as Required<VariableData>[],\n        newInstance.initialVariables as Required<VariableData>[],\n        runtimeObject.getVariables()\n      );\n\n      // Check if custom properties changed (specific to each object type)\n      const numberPropertiesChanged = newInstance.numberProperties.some(\n        (numberProperty) => {\n          const name = numberProperty.name;\n          const value = numberProperty.value;\n          const oldNumberProperty = oldInstance.numberProperties.filter(\n            (numberProperty) => numberProperty.name === name\n          )[0];\n          return !oldNumberProperty || oldNumberProperty.value !== value;\n        }\n      );\n      const stringPropertiesChanged = newInstance.stringProperties.some(\n        (stringProperty) => {\n          const name = stringProperty.name;\n          const value = stringProperty.value;\n          const oldStringProperty = oldInstance.stringProperties.filter(\n            (stringProperty) => stringProperty.name === name\n          )[0];\n          return !oldStringProperty || oldStringProperty.value !== value;\n        }\n      );\n      if (numberPropertiesChanged || stringPropertiesChanged || sizeChanged) {\n        runtimeObject.extraInitializationFromInitialInstance(newInstance);\n        somethingChanged = true;\n      }\n      if (somethingChanged) {\n        // If we changed the runtime object position/size/angle or another property,\n        // notify behaviors that the runtime object was reloaded.\n        // This is useful for behaviors like the physics engine that are watching the\n        // object position/size and need to be notified when changed (otherwise, they\n        // would continue using the previous position, so the object would not be moved\n        // or updated according to the changes made in the project instance).\n        runtimeObject.notifyBehaviorsObjectHotReloaded();\n      }\n    }\n\n    /**\n     * Deep check equality between the two objects/arrays/primitives.\n     *\n     * Inspired from https://github.com/epoberezkin/fast-deep-equal\n     * @param a The first object/array/primitive to compare\n     * @param b The second object/array/primitive to compare\n     */\n    static deepEqual(a: any, b: any): boolean {\n      if (a === b) {\n        return true;\n      }\n      if (a && b && typeof a == 'object' && typeof b == 'object') {\n        if (a.constructor !== b.constructor) {\n          return false;\n        }\n        let length, i, keys;\n        if (Array.isArray(a)) {\n          length = a.length;\n          if (length != b.length) {\n            return false;\n          }\n          for (i = length; i-- !== 0; ) {\n            if (!HotReloader.deepEqual(a[i], b[i])) {\n              return false;\n            }\n          }\n          return true;\n        }\n        if (a.valueOf !== Object.prototype.valueOf) {\n          return a.valueOf() === b.valueOf();\n        }\n        if (a.toString !== Object.prototype.toString) {\n          return a.toString() === b.toString();\n        }\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) {\n          return false;\n        }\n        for (i = length; i-- !== 0; ) {\n          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {\n            return false;\n          }\n        }\n        for (i = length; i-- !== 0; ) {\n          const key = keys[i];\n          if (!HotReloader.deepEqual(a[key], b[key])) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      // true if both NaN, false otherwise\n      return a !== a && b !== b;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
