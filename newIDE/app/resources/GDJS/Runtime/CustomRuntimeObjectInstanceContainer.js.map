{
  "version": 3,
  "sources": ["../../../../../GDJS/Runtime/CustomRuntimeObjectInstanceContainer.ts"],
  "sourcesContent": ["/*\n * GDevelop JS Platform\n * Copyright 2013-2022 Florian Rival (Florian.Rival@gmail.com). All rights reserved.\n * This project is released under the MIT License.\n */\nnamespace gdjs {\n  const logger = new gdjs.Logger('CustomRuntimeObject');\n\n  /**\n   * The instance container of a custom object, containing instances of objects rendered on screen.\n   *\n   * @see gdjs.CustomRuntimeObject\n   */\n  export class CustomRuntimeObjectInstanceContainer extends gdjs.RuntimeInstanceContainer {\n    _renderer: gdjs.CustomObjectRenderer;\n    _debuggerRenderer: gdjs.DebuggerRenderer;\n    _runtimeScene: gdjs.RuntimeScene;\n    /** The parent container that contains the object associated with this container. */\n    _parent: gdjs.RuntimeInstanceContainer;\n    /** The object that is built with the instances of this container. */\n    _customObject: gdjs.CustomRuntimeObject;\n    _isLoaded: boolean = false;\n\n    /**\n     * @param parent the parent container that contains the object associated\n     * with this container.\n     * @param customObject the object that is built with the instances of this\n     * container.\n     */\n    constructor(\n      parent: gdjs.RuntimeInstanceContainer,\n      customObject: gdjs.CustomRuntimeObject\n    ) {\n      super();\n      this._parent = parent;\n      this._customObject = customObject;\n      this._runtimeScene = parent.getScene();\n      this._renderer = new gdjs.CustomObjectRenderer(\n        customObject,\n        this,\n        parent\n      );\n      this._debuggerRenderer = new gdjs.DebuggerRenderer(this);\n    }\n\n    addLayer(layerData: LayerData) {\n      const layer = new gdjs.RuntimeCustomObjectLayer(layerData, this);\n      this._layers.put(layerData.name, layer);\n      this._orderedLayers.push(layer);\n    }\n\n    createObject(objectName: string): gdjs.RuntimeObject | null {\n      const result = super.createObject(objectName);\n      this._customObject.onChildrenLocationChanged();\n      return result;\n    }\n\n    /**\n     * Load the container from the given initial configuration.\n     * @param customObjectData An object containing the container data.\n     * @see gdjs.RuntimeGame#getSceneData\n     */\n    loadFrom(customObjectData: ObjectData & CustomObjectConfiguration) {\n      if (this._isLoaded) {\n        this.onDestroyFromScene(this._parent);\n      }\n\n      const eventsBasedObjectData = this._runtimeScene\n        .getGame()\n        .getEventsBasedObjectData(customObjectData.type);\n      if (!eventsBasedObjectData) {\n        logger.error('loadFrom was called without an events-based object');\n        return;\n      }\n\n      // Registering objects\n      for (\n        let i = 0, len = eventsBasedObjectData.objects.length;\n        i < len;\n        ++i\n      ) {\n        const childObjectData = eventsBasedObjectData.objects[i];\n        this.registerObject({\n          ...childObjectData,\n          ...customObjectData.childrenContent[childObjectData.name],\n        });\n      }\n\n      // TODO EBO Remove it when the instance editor is done.\n      // Add a default layer\n      this.addLayer({\n        name: '',\n        visibility: true,\n        cameras: [\n          {\n            defaultSize: true,\n            defaultViewport: true,\n            height: 0,\n            viewportBottom: 0,\n            viewportLeft: 0,\n            viewportRight: 0,\n            viewportTop: 0,\n            width: 0,\n          },\n        ],\n        effects: [],\n        ambientLightColorR: 0,\n        ambientLightColorG: 0,\n        ambientLightColorB: 0,\n        isLightingLayer: false,\n        followBaseLayerCamera: false,\n      });\n\n      // Set up the default z order (for objects created from events)\n      this._setLayerDefaultZOrders();\n\n      this._isLoaded = true;\n    }\n\n    /**\n     * Called when the container must be updated using the specified\n     * objectData. This is the case during hot-reload, and is only called if\n     * the object was modified.\n     *\n     * @param oldCustomObjectData The previous data for the object.\n     * @param newCustomObjectData The new data for the object.\n     * @returns true if the object was updated, false if it could not\n     * (i.e: hot-reload is not supported).\n     */\n    updateFrom(\n      oldCustomObjectData: ObjectData & CustomObjectConfiguration,\n      newCustomObjectData: ObjectData & CustomObjectConfiguration\n    ): boolean {\n      const eventsBasedObjectData = this._runtimeScene\n        .getGame()\n        .getEventsBasedObjectData(newCustomObjectData.type);\n      if (!eventsBasedObjectData) {\n        logger.error('updateFrom was called without an events-based object');\n        return false;\n      }\n\n      for (\n        let i = 0, len = eventsBasedObjectData.objects.length;\n        i < len;\n        ++i\n      ) {\n        const childName = eventsBasedObjectData.objects[i].name;\n        const oldChildData = {\n          ...eventsBasedObjectData.objects[i],\n          ...oldCustomObjectData.childrenContent[childName],\n        };\n        const newChildData = {\n          ...eventsBasedObjectData.objects[i],\n          ...newCustomObjectData.childrenContent[childName],\n        };\n        this.updateObject(newChildData);\n\n        for (const child of this.getInstancesOf(childName)) {\n          child.updateFromObjectData(oldChildData, newChildData);\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Called when the associated object is destroyed (because it is removed\n     * from its parent container or the scene is being unloaded).\n     *\n     * @param instanceContainer The container owning the object.\n     */\n    onDestroyFromScene(instanceContainer: gdjs.RuntimeInstanceContainer): void {\n      if (!this._isLoaded) {\n        return;\n      }\n\n      // Notify the objects they are being destroyed\n      const allInstancesList = this.getAdhocListOfAllInstances();\n      for (let i = 0, len = allInstancesList.length; i < len; ++i) {\n        const object = allInstancesList[i];\n        object.onDestroyFromScene(this);\n      }\n\n      this._destroy();\n\n      this._isLoaded = false;\n    }\n\n    _destroy() {\n      // It should not be necessary to reset these variables, but this help\n      // ensuring that all memory related to the container is released immediately.\n      super._destroy();\n      // @ts-ignore We are deleting the object\n      this._onceTriggers = null;\n    }\n\n    /**\n     * Called to update visibility of the renderers of objects\n     * rendered on the scene (\"culling\"), update effects (of visible objects)\n     * and give a last chance for objects to update before rendering.\n     *\n     * Visibility is set to false if object is hidden, or if\n     * object is too far from the camera of its layer (\"culling\").\n     */\n    _updateObjectsPreRender() {\n      const allInstancesList = this.getAdhocListOfAllInstances();\n      // TODO (3D) culling - add support for 3D object culling?\n      for (let i = 0, len = allInstancesList.length; i < len; ++i) {\n        const object = allInstancesList[i];\n        const rendererObject = object.getRendererObject();\n        if (rendererObject) {\n          rendererObject.visible = !object.isHidden();\n\n          // Update effects, only for visible objects.\n          if (rendererObject.visible) {\n            this.getGame()\n              .getEffectsManager()\n              .updatePreRender(object.getRendererEffects(), object);\n          }\n        }\n\n        // Set to true to enable debug rendering (look for the implementation in the renderer\n        // to see what is rendered).\n        if (this._debugDrawEnabled) {\n          this._debuggerRenderer.renderDebugDraw(\n            allInstancesList,\n            this._debugDrawShowHiddenInstances,\n            this._debugDrawShowPointsNames,\n            this._debugDrawShowCustomPoints\n          );\n        }\n\n        // Perform pre-render update.\n        object.updatePreRender(this);\n      }\n      return;\n    }\n\n    /**\n     * Update the objects before launching the events.\n     */\n    _updateObjectsPreEvents() {\n      const allInstancesList = this.getAdhocListOfAllInstances();\n      for (let i = 0, len = allInstancesList.length; i < len; ++i) {\n        const obj = allInstancesList[i];\n        const elapsedTime = obj.getElapsedTime();\n        if (!obj.hasNoForces()) {\n          const averageForce = obj.getAverageForce();\n          const elapsedTimeInSeconds = elapsedTime / 1000;\n          obj.setX(obj.getX() + averageForce.getX() * elapsedTimeInSeconds);\n          obj.setY(obj.getY() + averageForce.getY() * elapsedTimeInSeconds);\n          obj.update(this);\n          obj.updateForces(elapsedTimeInSeconds);\n        } else {\n          obj.update(this);\n        }\n        obj.updateTimers(elapsedTime);\n        obj.stepBehaviorsPreEvents(this);\n      }\n\n      // Some behaviors may have request objects to be deleted.\n      this._cacheOrClearRemovedInstances();\n    }\n\n    /**\n     * Get the renderer associated to the RuntimeScene.\n     */\n    getRenderer(): gdjs.CustomObjectRenderer {\n      return this._renderer;\n    }\n\n    getDebuggerRenderer() {\n      return this._debuggerRenderer;\n    }\n\n    getGame() {\n      return this._runtimeScene.getGame();\n    }\n\n    getScene() {\n      return this._runtimeScene;\n    }\n\n    getViewportWidth(): float {\n      return this._customObject.getUnscaledWidth();\n    }\n\n    getViewportHeight(): float {\n      return this._customObject.getUnscaledHeight();\n    }\n\n    getViewportOriginX(): float {\n      return this._customObject.getUnscaledCenterX();\n    }\n\n    getViewportOriginY(): float {\n      return this._customObject.getUnscaledCenterY();\n    }\n\n    onChildrenLocationChanged(): void {\n      this._customObject.onChildrenLocationChanged();\n    }\n\n    convertCoords(x: float, y: float, result: FloatPoint): FloatPoint {\n      // The result parameter used to be optional.\n      let position = result || [0, 0];\n      position = this._parent\n        .getLayer(this._customObject.getLayer())\n        .convertCoords(x, y, 0, position);\n      this._customObject.applyObjectInverseTransformation(\n        position[0],\n        position[1],\n        position\n      );\n      return position;\n    }\n\n    convertInverseCoords(\n      sceneX: float,\n      sceneY: float,\n      result: FloatPoint\n    ): FloatPoint {\n      const position = result || [0, 0];\n      this._customObject.applyObjectTransformation(sceneX, sceneY, position);\n      return this._parent.convertInverseCoords(\n        position[0],\n        position[1],\n        position\n      );\n    }\n\n    /**\n     * Return the time elapsed since the last frame,\n     * in milliseconds, for objects on the layer.\n     */\n    getElapsedTime(): float {\n      return this._parent.getElapsedTime();\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
