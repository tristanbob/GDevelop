{
  "version": 3,
  "sources": ["../../../../../../GDJS/Runtime/events-tools/runtimescenetools.ts"],
  "sourcesContent": ["/*\n * GDevelop JS Platform\n * Copyright 2013-2016 Florian Rival (Florian.Rival@gmail.com). All rights reserved.\n * This project is released under the MIT License.\n */\nnamespace gdjs {\n  export namespace evtTools {\n    export namespace runtimeScene {\n      export const sceneJustBegins = function (\n        runtimeScene: gdjs.RuntimeScene\n      ) {\n        return runtimeScene.getScene().getTimeManager().isFirstFrame();\n      };\n\n      export const sceneJustResumed = function (\n        runtimeScene: gdjs.RuntimeScene\n      ) {\n        return runtimeScene.getScene().sceneJustResumed();\n      };\n\n      export const getSceneName = function (runtimeScene: gdjs.RuntimeScene) {\n        return runtimeScene.getScene().getName();\n      };\n\n      export const setBackgroundColor = function (\n        runtimeScene: gdjs.RuntimeScene,\n        rgbColor: string\n      ) {\n        const colors = rgbColor.split(';');\n        if (colors.length < 3) {\n          return;\n        }\n        runtimeScene\n          .getScene()\n          .setBackgroundColor(\n            parseInt(colors[0]),\n            parseInt(colors[1]),\n            parseInt(colors[2])\n          );\n      };\n\n      export const getElapsedTimeInSeconds = function (\n        runtimeScene: gdjs.RuntimeScene\n      ) {\n        return runtimeScene.getScene().getTimeManager().getElapsedTime() / 1000;\n      };\n\n      export const setTimeScale = function (\n        runtimeScene: gdjs.RuntimeScene,\n        timeScale: float\n      ) {\n        return runtimeScene.getScene().getTimeManager().setTimeScale(timeScale);\n      };\n\n      export const getTimeScale = function (runtimeScene: gdjs.RuntimeScene) {\n        return runtimeScene.getScene().getTimeManager().getTimeScale();\n      };\n\n      /**\n       * Test a timer elapsed time, if the timer doesn't exist it is created.\n       *\n       * @deprecated prefer using getTimerElapsedTimeInSecondsOrNaN\n       *\n       * @param runtimeScene The scene owning the timer\n       * @param timeInSeconds The time value to check in seconds\n       * @param timerName The timer name\n       * @return True if the timer exists and its value is greater than or equal than the given time, false otherwise\n       */\n      export const timerElapsedTime = function (\n        runtimeScene: gdjs.RuntimeScene,\n        timeInSeconds: float,\n        timerName: string\n      ) {\n        const timeManager = runtimeScene.getScene().getTimeManager();\n        if (!timeManager.hasTimer(timerName)) {\n          timeManager.addTimer(timerName);\n          return false;\n        }\n        return (\n          timeManager.getTimer(timerName).getTime() / 1000 >= timeInSeconds\n        );\n      };\n\n      export const timerPaused = function (\n        runtimeScene: gdjs.RuntimeScene,\n        timerName: string\n      ) {\n        const timeManager = runtimeScene.getScene().getTimeManager();\n        if (!timeManager.hasTimer(timerName)) {\n          return false;\n        }\n        return timeManager.getTimer(timerName).isPaused();\n      };\n\n      export const resetTimer = function (\n        runtimeScene: gdjs.RuntimeScene,\n        timerName: string\n      ) {\n        const timeManager = runtimeScene.getScene().getTimeManager();\n        if (!timeManager.hasTimer(timerName)) {\n          timeManager.addTimer(timerName);\n        } else {\n          timeManager.getTimer(timerName).reset();\n        }\n      };\n\n      export const pauseTimer = function (\n        runtimeScene: gdjs.RuntimeScene,\n        timerName: string\n      ) {\n        const timeManager = runtimeScene.getScene().getTimeManager();\n        if (!timeManager.hasTimer(timerName)) {\n          timeManager.addTimer(timerName);\n        }\n        timeManager.getTimer(timerName).setPaused(true);\n      };\n\n      export const unpauseTimer = function (\n        runtimeScene: gdjs.RuntimeScene,\n        timerName: string\n      ) {\n        const timeManager = runtimeScene.getScene().getTimeManager();\n        if (!timeManager.hasTimer(timerName)) {\n          timeManager.addTimer(timerName);\n        }\n        return timeManager.getTimer(timerName).setPaused(false);\n      };\n\n      export const removeTimer = function (\n        runtimeScene: gdjs.RuntimeScene,\n        timerName: string\n      ) {\n        const timeManager = runtimeScene.getScene().getTimeManager();\n        timeManager.removeTimer(timerName);\n      };\n\n      export class WaitTask extends gdjs.AsyncTask {\n        private duration: float;\n        private timeElapsedOnScene = 0;\n\n        constructor(durationInMilliseconds: float) {\n          super();\n          this.duration = durationInMilliseconds;\n        }\n\n        update(runtimeScene: RuntimeScene): boolean {\n          this.timeElapsedOnScene += runtimeScene\n            .getScene()\n            .getTimeManager()\n            .getElapsedTime();\n          return this.timeElapsedOnScene >= this.duration;\n        }\n      }\n\n      export const wait = (durationInSeconds: float): AsyncTask =>\n        new WaitTask(\n          durationInSeconds * 1000 /* Convert from seconds to milliseconds */\n        );\n\n      /**\n       * This is used by expressions to return 0 when a timer doesn't exist,\n       * because numeric expressions must always return a number.\n       *\n       * @param runtimeScene The scene owning the timer.\n       * @param timerName The timer name.\n       * @returns The timer elapsed time in seconds or 0 if the timer doesn't exist.\n       */\n      export const getTimerElapsedTimeInSeconds = function (\n        runtimeScene: gdjs.RuntimeScene,\n        timerName: string\n      ) {\n        const timeManager = runtimeScene.getScene().getTimeManager();\n        if (!timeManager.hasTimer(timerName)) {\n          return 0;\n        }\n        return timeManager.getTimer(timerName).getTime() / 1000;\n      };\n\n      /**\n       * This is used by conditions to return false when a timer doesn't exist,\n       * no matter the relational operator.\n       *\n       * @param runtimeScene The scene owning the timer.\n       * @param timerName The timer name.\n       * @returns The timer elapsed time in seconds or NaN if the timer doesn't exist.\n       */\n      export const getTimerElapsedTimeInSecondsOrNaN = function (\n        runtimeScene: gdjs.RuntimeScene,\n        timerName: string\n      ) {\n        const timeManager = runtimeScene.getScene().getTimeManager();\n        if (!timeManager.hasTimer(timerName)) {\n          return Number.NaN;\n        }\n        return timeManager.getTimer(timerName).getTime() / 1000;\n      };\n\n      export const getTimeFromStartInSeconds = function (\n        runtimeScene: gdjs.RuntimeScene\n      ) {\n        return (\n          runtimeScene.getScene().getTimeManager().getTimeFromStart() / 1000\n        );\n      };\n\n      export const getTime = function (\n        runtimeScene: gdjs.RuntimeScene,\n        what: string\n      ) {\n        if (what === 'timestamp') {\n          return Date.now();\n        }\n        const now = new Date();\n        if (what === 'hour') {\n          return now.getHours();\n        } else if (what === 'min') {\n          return now.getMinutes();\n        } else if (what === 'sec') {\n          return now.getSeconds();\n        } else if (what === 'mday') {\n          return now.getDate();\n        } else if (what === 'mon') {\n          return now.getMonth();\n        } else if (what === 'year') {\n          //Conform to the C way of returning years.\n          return now.getFullYear() - 1900;\n        } else if (what === 'wday') {\n          return now.getDay();\n        } else if (what === 'yday') {\n          const start = new Date(now.getFullYear(), 0, 0);\n          const diff = now.getTime() - start.getTime();\n          const oneDay = 1000 * 60 * 60 * 24;\n          return Math.floor(diff / oneDay);\n        }\n        return 0;\n      };\n\n      export const replaceScene = function (\n        runtimeScene: gdjs.RuntimeScene,\n        newSceneName: string,\n        clearOthers: boolean\n      ) {\n        if (!runtimeScene.getGame().getSceneData(newSceneName)) {\n          return;\n        }\n        runtimeScene\n          .getScene()\n          .requestChange(\n            clearOthers\n              ? gdjs.SceneChangeRequest.CLEAR_SCENES\n              : gdjs.SceneChangeRequest.REPLACE_SCENE,\n            newSceneName\n          );\n      };\n\n      export const pushScene = function (\n        runtimeScene: gdjs.RuntimeScene,\n        newSceneName: string\n      ) {\n        if (!runtimeScene.getGame().getSceneData(newSceneName)) {\n          return;\n        }\n        runtimeScene\n          .getScene()\n          .requestChange(gdjs.SceneChangeRequest.PUSH_SCENE, newSceneName);\n      };\n\n      export const popScene = function (runtimeScene: gdjs.RuntimeScene) {\n        runtimeScene\n          .getScene()\n          .requestChange(gdjs.SceneChangeRequest.POP_SCENE);\n      };\n\n      export const stopGame = function (runtimeScene: gdjs.RuntimeScene) {\n        runtimeScene\n          .getScene()\n          .requestChange(gdjs.SceneChangeRequest.STOP_GAME);\n      };\n\n      export const createObjectsFromExternalLayout = function (\n        scene: gdjs.RuntimeInstanceContainer,\n        externalLayout: string,\n        xPos: float,\n        yPos: float\n      ) {\n        const externalLayoutData = scene\n          .getGame()\n          .getExternalLayoutData(externalLayout);\n        if (externalLayoutData === null) {\n          return;\n        }\n\n        // trackByPersistentUuid is set to false as we don't want external layouts\n        // instantiated at runtime to be hot-reloaded.\n        scene.getScene().createObjectsFrom(\n          externalLayoutData.instances,\n          xPos,\n          yPos,\n          /*trackByPersistentUuid=*/\n          false\n        );\n      };\n\n      /**\n       * Check if the game has just resumed from being hidden\n       */\n      export const hasGameJustResumed = (\n        instanceContainer: gdjs.RuntimeInstanceContainer\n      ): boolean => {\n        return instanceContainer.getGame().hasJustResumed();\n      };\n\n      /**\n       * Check if a scene exists.\n       */\n      export const doesSceneExist = (\n        runtimeScene: gdjs.RuntimeScene,\n        sceneName: string\n      ): boolean => {\n        return runtimeScene.getGame().hasScene(sceneName);\n      };\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
