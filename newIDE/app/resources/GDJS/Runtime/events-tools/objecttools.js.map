{
  "version": 3,
  "sources": ["../../../../../../GDJS/Runtime/events-tools/objecttools.ts"],
  "sourcesContent": ["/*\n * GDevelop JS Platform\n * Copyright 2013-2016 Florian Rival (Florian.Rival@gmail.com). All rights reserved.\n * This project is released under the MIT License.\n */\nnamespace gdjs {\n  export namespace evtTools {\n    export namespace object {\n      /**\n       * Keep only the specified object in the lists of picked objects.\n       *\n       * @param objectsLists The lists of objects to trim\n       * @param runtimeObject The object to keep in the lists\n       */\n      export const pickOnly = function (\n        objectsLists: ObjectsLists,\n        runtimeObject: gdjs.RuntimeObject\n      ) {\n        for (const listName in objectsLists.items) {\n          if (objectsLists.items.hasOwnProperty(listName)) {\n            const list = objectsLists.items[listName];\n\n            //Be sure not to lose the reference to the original array\n            if (list.indexOf(runtimeObject) === -1) {\n              list.length = 0;\n            } else {\n              list.length = 0;\n\n              //Be sure not to lose the reference to the original array\n              list.push(runtimeObject);\n            }\n          }\n        }\n      };\n\n      /**\n       * Do a test on two tables of objects so as to pick only the pair of objects for which the test is true.\n       *\n       * Note that the predicate method is not called strictly for each pair: When considering a pair of objects, if\n       * these objects have already been marked as picked, the predicate method won't be called again.\n       *\n       * Cost (Worst case, predicate being always false):\n       *    Cost(Setting property 'picked' of NbObjList1+NbObjList2 objects to false)\n       *  + Cost(predicate)*NbObjList1*NbObjList2\n       *  + Cost(Testing NbObjList1+NbObjList2 booleans)\n       *  + Cost(Removing NbObjList1+NbObjList2 objects from all the lists)\n       *\n       * Cost (Best case, predicate being always true):\n       *    Cost(Setting property 'picked' of NbObjList1+NbObjList2 objects to false)\n       *  + Cost(predicate)*(NbObjList1+NbObjList2)\n       *  + Cost(Testing NbObjList1+NbObjList2 booleans)\n       *\n       *\n       * @param predicate The predicate function is called with the two objects to compare, and an optional argument `extraArg`\n       * @param objectsLists1 The first lists of objects\n       * @param objectsLists2 The second lists of objects\n       * @param inverted If `inverted` == true, only the objects of the first table are filtered.\n       * @param extraArg (optional) This argument should be used to avoid declaring the predicate as a closure that would be created and destroyed at each call to twoListsTest (potentially multiple time per frame).\n       */\n      export const twoListsTest = function (\n        predicate: (\n          object1: gdjs.RuntimeObject,\n          object2: gdjs.RuntimeObject,\n          extraArg: any\n        ) => boolean,\n        objectsLists1: ObjectsLists,\n        objectsLists2: ObjectsLists,\n        inverted: boolean,\n        extraArg: any\n      ) {\n        let isTrue = false;\n        const objects1Lists = gdjs.staticArray(\n          gdjs.evtTools.object.twoListsTest\n        );\n        objectsLists1.values(objects1Lists);\n        const objects2Lists = gdjs.staticArray2(\n          gdjs.evtTools.object.twoListsTest\n        );\n        objectsLists2.values(objects2Lists);\n        for (let i = 0, leni = objects1Lists.length; i < leni; ++i) {\n          let arr = objects1Lists[i];\n          for (let k = 0, lenk = arr.length; k < lenk; ++k) {\n            arr[k].pick = false;\n          }\n        }\n        for (let i = 0, leni = objects2Lists.length; i < leni; ++i) {\n          let arr = objects2Lists[i];\n          for (let k = 0, lenk = arr.length; k < lenk; ++k) {\n            arr[k].pick = false;\n          }\n        }\n\n        //Launch the function for each object of the first list with each object\n        //of the second list.\n        for (let i = 0, leni = objects1Lists.length; i < leni; ++i) {\n          const arr1 = objects1Lists[i];\n          for (let k = 0, lenk = arr1.length; k < lenk; ++k) {\n            let atLeastOneObject = false;\n            for (let j = 0, lenj = objects2Lists.length; j < lenj; ++j) {\n              const arr2 = objects2Lists[j];\n              for (let l = 0, lenl = arr2.length; l < lenl; ++l) {\n                if (arr1[k].pick && arr2[l].pick) {\n                  continue;\n                }\n\n                //Avoid unnecessary costly call to predicate.\n                if (\n                  arr1[k].id !== arr2[l].id &&\n                  predicate(arr1[k], arr2[l], extraArg)\n                ) {\n                  if (!inverted) {\n                    isTrue = true;\n\n                    //Pick the objects\n                    arr1[k].pick = true;\n                    arr2[l].pick = true;\n                  }\n                  atLeastOneObject = true;\n                }\n              }\n            }\n            if (!atLeastOneObject && inverted) {\n              //For example, the object is not overlapping any other object.\n              isTrue = true;\n              arr1[k].pick = true;\n            }\n          }\n        }\n\n        //Trim not picked objects from lists.\n        for (let i = 0, leni = objects1Lists.length; i < leni; ++i) {\n          let arr = objects1Lists[i];\n          let finalSize = 0;\n          for (let k = 0, lenk = arr.length; k < lenk; ++k) {\n            let obj = arr[k];\n            if (arr[k].pick) {\n              arr[finalSize] = obj;\n              finalSize++;\n            }\n          }\n          arr.length = finalSize;\n        }\n        if (!inverted) {\n          for (let i = 0, leni = objects2Lists.length; i < leni; ++i) {\n            let arr = objects2Lists[i];\n            let finalSize = 0;\n            for (let k = 0, lenk = arr.length; k < lenk; ++k) {\n              let obj = arr[k];\n              if (arr[k].pick) {\n                arr[finalSize] = obj;\n                finalSize++;\n              }\n            }\n            arr.length = finalSize;\n          }\n        }\n        return isTrue;\n      };\n\n      /**\n       * Filter objects to keep only the one that fullfil the predicate\n       *\n       * Objects that do not fullfil the predicate are removed from objects lists.\n       *\n       * @param predicate The function applied to each object: must return true if the object fulfill the predicate.\n       * @param objectsLists The lists of objects to trim\n       * @param negatePredicate If set to true, the result of the predicate is negated.\n       * @param extraArg Argument passed to the predicate (along with the object). Useful for avoiding relying on temporary closures.\n       * @return true if at least one object fulfill the predicate.\n       */\n      export const pickObjectsIf = function (\n        predicate: Function,\n        objectsLists: ObjectsLists,\n        negatePredicate: boolean,\n        extraArg: any\n      ): boolean {\n        let isTrue = false;\n        const lists = gdjs.staticArray(gdjs.evtTools.object.pickObjectsIf);\n        objectsLists.values(lists);\n\n        // Pick only objects that are fulfilling the predicate.\n        for (let i = 0, leni = lists.length; i < leni; ++i) {\n          const arr = lists[i];\n          for (let k = 0, lenk = arr.length; k < lenk; ++k) {\n            const object = arr[k];\n            // @ts-ignore\n            if (negatePredicate ^ predicate(object, extraArg)) {\n              isTrue = true;\n              object.pick = true;\n            } else {\n              object.pick = false;\n            }\n          }\n        }\n\n        // Trim not picked objects from lists.\n        for (let i = 0, leni = lists.length; i < leni; ++i) {\n          gdjs.evtTools.object.filterPickedObjectsList(lists[i]);\n        }\n        return isTrue;\n      };\n\n      /**\n       * Filter in-place the specified array to remove objects for which\n       * `pick` property is set to false.\n       */\n      export const filterPickedObjectsList = function (\n        arr: gdjs.RuntimeObject[]\n      ) {\n        let finalSize = 0;\n        for (let k = 0, lenk = arr.length; k < lenk; ++k) {\n          const obj = arr[k];\n          if (obj.pick) {\n            arr[finalSize] = obj;\n            finalSize++;\n          }\n        }\n        arr.length = finalSize;\n      };\n\n      export const hitBoxesCollisionTest = function (\n        objectsLists1: ObjectsLists,\n        objectsLists2: ObjectsLists,\n        inverted: boolean,\n        instanceContainer: gdjs.RuntimeInstanceContainer,\n        ignoreTouchingEdges: boolean\n      ) {\n        return gdjs.evtTools.object.twoListsTest(\n          gdjs.RuntimeObject.collisionTest,\n          objectsLists1,\n          objectsLists2,\n          inverted,\n          ignoreTouchingEdges\n        );\n      };\n\n      export const _distanceBetweenObjects = function (obj1, obj2, distance) {\n        return obj1.getSqDistanceToObject(obj2) <= distance;\n      };\n\n      export const distanceTest = function (\n        objectsLists1: ObjectsLists,\n        objectsLists2: ObjectsLists,\n        distance: float,\n        inverted: boolean\n      ) {\n        return gdjs.evtTools.object.twoListsTest(\n          gdjs.evtTools.object._distanceBetweenObjects,\n          objectsLists1,\n          objectsLists2,\n          inverted,\n          distance * distance\n        );\n      };\n\n      export const _movesToward = function (obj1, obj2, tolerance) {\n        if (obj1.hasNoForces()) {\n          return false;\n        }\n        let objAngle = Math.atan2(\n          obj2.getDrawableY() +\n            obj2.getCenterY() -\n            (obj1.getDrawableY() + obj1.getCenterY()),\n          obj2.getDrawableX() +\n            obj2.getCenterX() -\n            (obj1.getDrawableX() + obj1.getCenterX())\n        );\n        objAngle *= 180 / 3.14159;\n        return (\n          Math.abs(\n            gdjs.evtTools.common.angleDifference(\n              obj1.getAverageForce().getAngle(),\n              objAngle\n            )\n          ) <=\n          tolerance / 2\n        );\n      };\n\n      export const movesTowardTest = function (\n        objectsLists1: ObjectsLists,\n        objectsLists2: ObjectsLists,\n        tolerance: float,\n        inverted: boolean\n      ) {\n        return gdjs.evtTools.object.twoListsTest(\n          gdjs.evtTools.object._movesToward,\n          objectsLists1,\n          objectsLists2,\n          inverted,\n          tolerance\n        );\n      };\n\n      export const _turnedToward = function (obj1, obj2, tolerance) {\n        let objAngle = Math.atan2(\n          obj2.getDrawableY() +\n            obj2.getCenterY() -\n            (obj1.getDrawableY() + obj1.getCenterY()),\n          obj2.getDrawableX() +\n            obj2.getCenterX() -\n            (obj1.getDrawableX() + obj1.getCenterX())\n        );\n        objAngle *= 180 / 3.14159;\n        return (\n          Math.abs(\n            gdjs.evtTools.common.angleDifference(obj1.getAngle(), objAngle)\n          ) <=\n          tolerance / 2\n        );\n      };\n\n      export const turnedTowardTest = function (\n        objectsLists1,\n        objectsLists2,\n        tolerance,\n        inverted\n      ) {\n        return gdjs.evtTools.object.twoListsTest(\n          gdjs.evtTools.object._turnedToward,\n          objectsLists1,\n          objectsLists2,\n          inverted,\n          tolerance\n        );\n      };\n\n      export const pickAllObjects = function (objectsContext, objectsLists) {\n        for (const name in objectsLists.items) {\n          if (objectsLists.items.hasOwnProperty(name)) {\n            const allObjects = objectsContext.getObjects(name);\n            const objectsList = objectsLists.items[name];\n            objectsList.length = 0;\n            objectsList.push.apply(objectsList, allObjects);\n          }\n        }\n        return true;\n      };\n\n      export const pickRandomObject = function (\n        instanceContainer: gdjs.RuntimeInstanceContainer,\n        objectsLists: ObjectsLists\n      ) {\n        // Compute one many objects we have\n        let objectsCount = 0;\n        for (let listName in objectsLists.items) {\n          if (objectsLists.items.hasOwnProperty(listName)) {\n            let list = objectsLists.items[listName];\n            objectsCount += list.length;\n          }\n        }\n        if (objectsCount === 0) {\n          return false;\n        }\n\n        // Pick one random object\n        let index = Math.floor(Math.random() * objectsCount);\n        if (index >= objectsCount) {\n          index = objectsCount - 1;\n        }\n\n        //Should never happen.\n\n        // Find the object\n        let startIndex = 0;\n        let theChosenOne: gdjs.RuntimeObject | null = null;\n        for (let listName in objectsLists.items) {\n          if (objectsLists.items.hasOwnProperty(listName)) {\n            let list = objectsLists.items[listName];\n            if (index - startIndex < list.length) {\n              theChosenOne = list[index - startIndex];\n              break;\n            }\n            startIndex += list.length;\n          }\n        }\n        // @ts-ignore\n        gdjs.evtTools.object.pickOnly(objectsLists, theChosenOne);\n        return true;\n      };\n\n      export const pickNearestObject = function (objectsLists, x, y, inverted) {\n        let bestObject = null;\n        let best = 0;\n        let first = true;\n        const lists = gdjs.staticArray(gdjs.evtTools.object.pickNearestObject);\n        objectsLists.values(lists);\n        for (let i = 0, len = lists.length; i < len; ++i) {\n          const list = lists[i];\n          for (let j = 0; j < list.length; ++j) {\n            const object = list[j];\n            const distance = object.getSqDistanceToPosition(x, y);\n            // @ts-ignore\n            if (first || (distance < best) ^ inverted) {\n              best = distance;\n              bestObject = object;\n            }\n            first = false;\n          }\n        }\n        if (!bestObject) {\n          return false;\n        }\n        gdjs.evtTools.object.pickOnly(objectsLists, bestObject);\n        return true;\n      };\n\n      export const raycastObject = function (\n        objectsLists: ObjectsLists,\n        x: float,\n        y: float,\n        angle: float,\n        dist: float,\n        varX: gdjs.Variable,\n        varY: gdjs.Variable,\n        inverted: boolean\n      ) {\n        return gdjs.evtTools.object.raycastObjectToPosition(\n          objectsLists,\n          x,\n          y,\n          x + dist * Math.cos((angle * Math.PI) / 180.0),\n          y + dist * Math.sin((angle * Math.PI) / 180.0),\n          varX,\n          varY,\n          inverted\n        );\n      };\n\n      export const raycastObjectToPosition = function (\n        objectsLists: ObjectsLists,\n        x: float,\n        y: float,\n        endX: float,\n        endY: float,\n        varX: gdjs.Variable,\n        varY: gdjs.Variable,\n        inverted: boolean\n      ) {\n        let matchObject: gdjs.RuntimeObject | null = null;\n        let testSqDist = inverted\n          ? 0\n          : (endX - x) * (endX - x) + (endY - y) * (endY - y);\n        let resultX = 0;\n        let resultY = 0;\n        const lists: RuntimeObject[][] = gdjs.staticArray(\n          gdjs.evtTools.object.raycastObjectToPosition\n        );\n        objectsLists.values(lists);\n        for (let i = 0; i < lists.length; i++) {\n          const list = lists[i];\n          for (let j = 0; j < list.length; j++) {\n            const object = list[j];\n            const result = object.raycastTest(x, y, endX, endY, !inverted);\n            if (result.collision) {\n              if (!inverted && result.closeSqDist <= testSqDist) {\n                testSqDist = result.closeSqDist;\n                matchObject = object;\n                resultX = result.closeX;\n                resultY = result.closeY;\n              } else {\n                if (inverted && result.farSqDist >= testSqDist) {\n                  testSqDist = result.farSqDist;\n                  matchObject = object;\n                  resultX = result.farX;\n                  resultY = result.farY;\n                }\n              }\n            }\n          }\n        }\n        if (!matchObject) {\n          return false;\n        }\n        gdjs.evtTools.object.pickOnly(objectsLists, matchObject);\n        varX.setNumber(resultX);\n        varY.setNumber(resultY);\n        return true;\n      };\n\n      /**\n       * Do the work of creating a new object\n       */\n      export const doCreateObjectOnScene = function (\n        objectsContext: EventsFunctionContext | gdjs.RuntimeScene,\n        objectName: string,\n        objectsLists: ObjectsLists,\n        x: float,\n        y: float,\n        layerName: string\n      ): gdjs.RuntimeObject | null {\n        // objectsContext will either be the gdjs.RuntimeScene or, in an events function, the\n        // eventsFunctionContext. We can't directly use runtimeScene because the object name could\n        // be different than the real object name (this is the case in a function. The eventsFunctionContext\n        // will take care of this in createObject).\n        const obj = objectsContext.createObject(objectName);\n        const layer = objectsContext.getLayer(layerName);\n        if (obj !== null) {\n          //Do some extra setup\n          obj.setPosition(x, y);\n          obj.setLayer(layerName);\n          obj.setZOrder(layer.getDefaultZOrder());\n\n          //Let the new object be picked by next actions/conditions.\n          if (objectsLists.containsKey(objectName)) {\n            objectsLists.get(objectName).push(obj);\n          }\n        }\n        return obj;\n      };\n\n      /**\n       * Allows events to create a new object on a scene.\n       */\n      export const createObjectOnScene = function (\n        objectsContext: EventsFunctionContext | gdjs.RuntimeScene,\n        objectsLists: ObjectsLists,\n        x: float,\n        y: float,\n        layerName: string\n      ): gdjs.RuntimeObject | null {\n        return gdjs.evtTools.object.doCreateObjectOnScene(\n          objectsContext,\n          objectsLists.firstKey() as string,\n          objectsLists,\n          x,\n          y,\n          layerName\n        );\n      };\n\n      /**\n       * Allows events to create a new object on a scene.\n       */\n      export const createObjectFromGroupOnScene = function (\n        objectsContext: EventsFunctionContext | gdjs.RuntimeScene,\n        objectsLists: ObjectsLists,\n        objectName: string,\n        x: float,\n        y: float,\n        layerName: string\n      ) {\n        gdjs.evtTools.object.doCreateObjectOnScene(\n          objectsContext,\n          objectName,\n          objectsLists,\n          x,\n          y,\n          layerName\n        );\n      };\n\n      /**\n       * Return the number of instances in the specified lists of objects.\n       */\n      export const getPickedInstancesCount = (objectsLists: ObjectsLists) => {\n        let count = 0;\n        const lists = gdjs.staticArray(\n          gdjs.evtTools.object.getPickedInstancesCount\n        );\n        objectsLists.values(lists);\n        for (let i = 0, len = lists.length; i < len; ++i) {\n          count += lists[i].length;\n        }\n        return count;\n      };\n\n      /**\n       * Return the number of instances of the specified objects living on the scene.\n       */\n      export const getSceneInstancesCount = (\n        objectsContext: EventsFunctionContext | gdjs.RuntimeScene,\n        objectsLists: ObjectsLists\n      ) => {\n        let count = 0;\n\n        const objectNames = gdjs.staticArray(\n          gdjs.evtTools.object.getSceneInstancesCount\n        );\n        objectsLists.keys(objectNames);\n\n        const uniqueObjectNames = new Set(objectNames);\n        for (const objectName of uniqueObjectNames) {\n          count += objectsContext.getInstancesCountOnScene(objectName);\n        }\n        return count;\n      };\n\n      /** @deprecated */\n      export const pickedObjectsCount = getPickedInstancesCount;\n    }\n  }\n\n  /**\n   * A container for objects lists that should last more than the current frame.\n   * It automatically removes objects that were destroyed from the objects lists.\n   */\n  export class LongLivedObjectsList {\n    private objectsLists = new Map<string, Array<RuntimeObject>>();\n    private callbacks = new Map<RuntimeObject, () => void>();\n    private parent: LongLivedObjectsList | null = null;\n\n    /**\n     * Create a new container for objects lists, inheriting from another one. This is\n     * useful should we get the objects that have not been saved in this context (using\n     * `addObject`) but saved in a parent context.\n     * This avoids to save all object lists every time we create a new `LongLivedObjectsList`,\n     * despite not all objects lists being used.\n     *\n     * @param parent\n     * @returns\n     */\n    static from(parent: LongLivedObjectsList): LongLivedObjectsList {\n      const newList = new LongLivedObjectsList();\n      newList.parent = parent;\n      return newList;\n    }\n\n    private getOrCreateList(objectName: string): RuntimeObject[] {\n      if (!this.objectsLists.has(objectName))\n        this.objectsLists.set(objectName, []);\n      return this.objectsLists.get(objectName)!;\n    }\n\n    getObjects(objectName: string): RuntimeObject[] {\n      if (!this.objectsLists.has(objectName) && this.parent)\n        return this.parent.getObjects(objectName);\n      return this.objectsLists.get(objectName) || [];\n    }\n\n    addObject(objectName: string, runtimeObject: gdjs.RuntimeObject): void {\n      const list = this.getOrCreateList(objectName);\n      if (list.includes(runtimeObject)) return;\n      list.push(runtimeObject);\n\n      // Register callbacks for when the object is destroyed\n      const onDestroy = () => this.removeObject(objectName, runtimeObject);\n      this.callbacks.set(runtimeObject, onDestroy);\n      runtimeObject.registerDestroyCallback(onDestroy);\n    }\n\n    removeObject(objectName: string, runtimeObject: gdjs.RuntimeObject): void {\n      const list = this.getOrCreateList(objectName);\n      const index = list.indexOf(runtimeObject);\n      if (index === -1) return;\n      list.splice(index, 1);\n\n      // Properly remove callbacks to not leak the object\n      runtimeObject.unregisterDestroyCallback(\n        this.callbacks.get(runtimeObject)!\n      );\n      this.callbacks.delete(runtimeObject);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
