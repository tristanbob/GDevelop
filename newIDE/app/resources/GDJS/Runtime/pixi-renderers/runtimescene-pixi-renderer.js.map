{
  "version": 3,
  "sources": ["../../../../../../GDJS/Runtime/pixi-renderers/runtimescene-pixi-renderer.ts"],
  "sourcesContent": ["namespace gdjs {\n  import PIXI = GlobalPIXIModule.PIXI;\n\n  /**\n   * The renderer for a gdjs.RuntimeScene using Pixi.js.\n   */\n  export class RuntimeScenePixiRenderer\n    implements gdjs.RuntimeInstanceContainerPixiRenderer {\n    private _runtimeGameRenderer: gdjs.RuntimeGamePixiRenderer | null;\n    private _runtimeScene: gdjs.RuntimeScene;\n    private _pixiContainer: PIXI.Container;\n    private _profilerText: PIXI.Text | null = null;\n    private _showCursorAtNextRender: boolean = false;\n    private _threeRenderer: THREE.WebGLRenderer | null = null;\n    private _layerRenderingMetrics: {\n      rendered2DLayersCount: number;\n      rendered3DLayersCount: number;\n    } = {\n      rendered2DLayersCount: 0,\n      rendered3DLayersCount: 0,\n    };\n\n    constructor(\n      runtimeScene: gdjs.RuntimeScene,\n      runtimeGameRenderer: gdjs.RuntimeGamePixiRenderer | null\n    ) {\n      this._runtimeGameRenderer = runtimeGameRenderer;\n      this._runtimeScene = runtimeScene;\n      this._pixiContainer = new PIXI.Container();\n\n      // Contains the layers of the scene (and, optionally, debug PIXI objects).\n      this._pixiContainer.sortableChildren = true;\n\n      this._threeRenderer = this._runtimeGameRenderer\n        ? this._runtimeGameRenderer.getThreeRenderer()\n        : null;\n    }\n\n    onGameResolutionResized() {\n      const pixiRenderer = this._runtimeGameRenderer\n        ? this._runtimeGameRenderer.getPIXIRenderer()\n        : null;\n      if (!pixiRenderer) {\n        return;\n      }\n      const runtimeGame = this._runtimeScene.getGame();\n\n      // TODO (3D): should this be done for each individual layer?\n      // Especially if we remove _pixiContainer entirely.\n      this._pixiContainer.scale.x =\n        pixiRenderer.width / runtimeGame.getGameResolutionWidth();\n      this._pixiContainer.scale.y =\n        pixiRenderer.height / runtimeGame.getGameResolutionHeight();\n\n      for (const runtimeLayer of this._runtimeScene._orderedLayers) {\n        runtimeLayer.getRenderer().onGameResolutionResized();\n      }\n    }\n\n    onSceneUnloaded() {\n      // TODO (3D): call the method with the same name on RuntimeLayers so they can dispose?\n    }\n\n    render() {\n      const runtimeGameRenderer = this._runtimeGameRenderer;\n      if (!runtimeGameRenderer) return;\n\n      const pixiRenderer = runtimeGameRenderer.getPIXIRenderer();\n      if (!pixiRenderer) return;\n\n      const threeRenderer = this._threeRenderer;\n\n      this._layerRenderingMetrics.rendered2DLayersCount = 0;\n      this._layerRenderingMetrics.rendered3DLayersCount = 0;\n\n      if (threeRenderer) {\n        // Layered 2D, 3D or 2D+3D rendering.\n        threeRenderer.info.autoReset = false;\n        threeRenderer.info.reset();\n\n        /** Useful to render the background color. */\n        let isFirstRender = true;\n\n        /**\n         * true if the last layer rendered 3D objects using Three.js, false otherwise.\n         * Useful to avoid needlessly resetting the WebGL states between layers (which can be expensive).\n         */\n        let lastRenderWas3D = true;\n\n        // Even if no rendering at all has been made already, setting up the Three.js/PixiJS renderers\n        // might have changed some WebGL states already. Reset the state for the very first frame.\n        // And, out of caution, keep doing it for every frame.\n        // TODO (3D): optimization - check if this can be done only on the very first frame.\n        threeRenderer.resetState();\n\n        // Render each layer one by one.\n        for (let i = 0; i < this._runtimeScene._orderedLayers.length; ++i) {\n          const runtimeLayer = this._runtimeScene._orderedLayers[i];\n          if (!runtimeLayer.isVisible()) continue;\n\n          const runtimeLayerRenderer = runtimeLayer.getRenderer();\n          const runtimeLayerRenderingType = runtimeLayer.getRenderingType();\n          const layerHas3DObjectsToRender = runtimeLayerRenderer.has3DObjects();\n          if (\n            runtimeLayerRenderingType ===\n              gdjs.RuntimeLayerRenderingType.TWO_D ||\n            !layerHas3DObjectsToRender\n          ) {\n            // Render a layer with 2D rendering (PixiJS) only if layer is configured as is\n            // or if there is no 3D object to render.\n\n            if (lastRenderWas3D) {\n              // Ensure the state is clean for PixiJS to render.\n              threeRenderer.resetState();\n              pixiRenderer.reset();\n            }\n\n            if (isFirstRender) {\n              // Render the background color.\n              pixiRenderer.backgroundColor = this._runtimeScene.getBackgroundColor();\n              pixiRenderer.backgroundAlpha = 1;\n              pixiRenderer.clear();\n\n              isFirstRender = false;\n            }\n\n            if (runtimeLayer.isLightingLayer()) {\n              // Render the lights on the render texture used then by the lighting Sprite.\n              runtimeLayerRenderer.renderOnPixiRenderTexture(pixiRenderer);\n            }\n\n            // TODO (2d lights): refactor to remove the need for `getLightingSprite`.\n            const pixiContainer =\n              (runtimeLayer.isLightingLayer() &&\n                runtimeLayerRenderer.getLightingSprite()) ||\n              runtimeLayerRenderer.getRendererObject();\n\n            pixiRenderer.render(pixiContainer, { clear: false });\n            this._layerRenderingMetrics.rendered2DLayersCount++;\n\n            lastRenderWas3D = false;\n          } else {\n            // Render a layer with 3D rendering, and possibly some 2D rendering too.\n            const threeScene = runtimeLayerRenderer.getThreeScene();\n            const threeCamera = runtimeLayerRenderer.getThreeCamera();\n\n            // Render the 3D objects of this layer.\n            if (threeScene && threeCamera) {\n              // TODO (3D) - optimization: do this at the beginning for all layers that are 2d+3d?\n              // So the second pass is clearer (just rendering 2d or 3d layers without doing PixiJS renders in between).\n              if (\n                runtimeLayerRenderingType ===\n                gdjs.RuntimeLayerRenderingType.TWO_D_PLUS_THREE_D\n              ) {\n                const layerHas2DObjectsToRender = runtimeLayerRenderer.has2DObjects();\n\n                if (layerHas2DObjectsToRender) {\n                  if (lastRenderWas3D) {\n                    // Ensure the state is clean for PixiJS to render.\n                    threeRenderer.resetState();\n                    pixiRenderer.reset();\n                  }\n\n                  // Do the rendering of the PixiJS objects of the layer on the render texture.\n                  // Then, update the texture of the plane showing the PixiJS rendering,\n                  // so that the 2D rendering made by PixiJS can be shown in the 3D world.\n                  runtimeLayerRenderer.renderOnPixiRenderTexture(pixiRenderer);\n                  runtimeLayerRenderer.updateThreePlaneTextureFromPixiRenderTexture(\n                    // The renderers are needed to find the internal WebGL texture.\n                    threeRenderer,\n                    pixiRenderer\n                  );\n                  this._layerRenderingMetrics.rendered2DLayersCount++;\n\n                  lastRenderWas3D = false;\n                }\n                runtimeLayerRenderer.show2DRenderingPlane(\n                  layerHas2DObjectsToRender\n                );\n              }\n\n              if (!lastRenderWas3D) {\n                // It's important to reset the internal WebGL state of PixiJS, then Three.js\n                // to ensure the 3D rendering is made properly by Three.js\n                pixiRenderer.reset();\n                threeRenderer.resetState();\n              }\n\n              if (isFirstRender) {\n                // Render the background color.\n                threeRenderer.setClearColor(\n                  this._runtimeScene.getBackgroundColor()\n                );\n                threeRenderer.resetState();\n                threeRenderer.clear();\n                threeScene.background = new THREE.Color(\n                  this._runtimeScene.getBackgroundColor()\n                );\n\n                isFirstRender = false;\n              } else {\n                // It's important to set the background to null, as maybe the first rendered\n                // layer has changed and so the Three.js scene background must be reset.\n                threeScene.background = null;\n              }\n\n              // Clear the depth as each layer is independent and display on top of the previous one,\n              // even 3D objects.\n              threeRenderer.clearDepth();\n              threeRenderer.render(threeScene, threeCamera);\n              this._layerRenderingMetrics.rendered3DLayersCount++;\n\n              lastRenderWas3D = true;\n            }\n          }\n        }\n\n        const debugContainer = this._runtimeScene\n          .getDebuggerRenderer()\n          .getRendererObject();\n\n        if (debugContainer) {\n          threeRenderer.resetState();\n          pixiRenderer.reset();\n          pixiRenderer.render(debugContainer);\n          lastRenderWas3D = false;\n        }\n\n        if (!lastRenderWas3D) {\n          // Out of caution, reset the WebGL states from PixiJS to start again\n          // with a 3D rendering on the next frame.\n          pixiRenderer.reset();\n        }\n\n        // Uncomment to display some debug metrics from Three.js.\n        // console.log(threeRenderer.info);\n      } else {\n        // 2D only rendering.\n\n        // Render lights in render textures first.\n        for (const runtimeLayer of this._runtimeScene._orderedLayers) {\n          if (runtimeLayer.isLightingLayer()) {\n            // Render the lights on the render texture used then by the lighting Sprite.\n            const runtimeLayerRenderer = runtimeLayer.getRenderer();\n            runtimeLayerRenderer.renderOnPixiRenderTexture(pixiRenderer);\n          }\n        }\n\n        // this._renderProfileText(); //Uncomment to display profiling times\n\n        // Render all the layers then.\n        // TODO: replace by a loop like in 3D?\n        pixiRenderer.backgroundColor = this._runtimeScene.getBackgroundColor();\n        pixiRenderer.render(this._pixiContainer);\n        this._layerRenderingMetrics.rendered2DLayersCount++;\n      }\n\n      // synchronize showing the cursor with rendering (useful to reduce\n      // blinking while switching from in-game cursor)\n      if (this._showCursorAtNextRender) {\n        const canvas = runtimeGameRenderer.getCanvas();\n        if (canvas) canvas.style.cursor = '';\n        this._showCursorAtNextRender = false;\n      }\n\n      // Uncomment to check the number of 2D&3D rendering done\n      // console.log(this._layerRenderingMetrics);\n    }\n\n    _renderProfileText() {\n      const profiler = this._runtimeScene.getProfiler();\n      if (!profiler) {\n        return;\n      }\n      if (!this._profilerText) {\n        this._profilerText = new PIXI.Text(' ', {\n          align: 'left',\n          stroke: '#FFF',\n          strokeThickness: 1,\n        });\n\n        // Add on top of all layers:\n        this._pixiContainer.addChild(this._profilerText);\n      }\n      const average = profiler.getFramesAverageMeasures();\n      const outputs = [];\n      gdjs.Profiler.getProfilerSectionTexts('All', average, outputs);\n      this._profilerText.text = outputs.join('\\n');\n    }\n\n    hideCursor(): void {\n      this._showCursorAtNextRender = false;\n\n      const canvas = this._runtimeGameRenderer\n        ? this._runtimeGameRenderer.getCanvas()\n        : null;\n      if (canvas) canvas.style.cursor = 'none';\n    }\n\n    showCursor(): void {\n      this._showCursorAtNextRender = true;\n    }\n\n    getPIXIContainer() {\n      return this._pixiContainer;\n    }\n\n    getRendererObject() {\n      return this._pixiContainer;\n    }\n\n    get3DRendererObject() {\n      // There is no notion of a container for all 3D objects. Each 3D object is\n      // added to their layer container.\n      return null;\n    }\n\n    /** @deprecated use `runtimeGame.getRenderer().getPIXIRenderer()` instead */\n    getPIXIRenderer() {\n      return this._runtimeGameRenderer\n        ? this._runtimeGameRenderer.getPIXIRenderer()\n        : null;\n    }\n\n    setLayerIndex(layer: gdjs.RuntimeLayer, index: float): void {\n      const layerPixiRenderer: gdjs.LayerPixiRenderer = layer.getRenderer();\n      let layerPixiObject:\n        | PIXI.Container\n        | PIXI.Sprite\n        | null = layerPixiRenderer.getRendererObject();\n      if (layer.isLightingLayer()) {\n        // TODO (2d lights): refactor to remove the need for `getLightingSprite`.\n        layerPixiObject = layerPixiRenderer.getLightingSprite();\n      }\n      if (!layerPixiObject) {\n        return;\n      }\n      if (this._pixiContainer.children.indexOf(layerPixiObject) === index) {\n        return;\n      }\n      this._pixiContainer.removeChild(layerPixiObject);\n      this._pixiContainer.addChildAt(layerPixiObject, index);\n    }\n  }\n\n  // Register the class to let the engine use it.\n  export type RuntimeSceneRenderer = gdjs.RuntimeScenePixiRenderer;\n  export const RuntimeSceneRenderer = gdjs.RuntimeScenePixiRenderer;\n}\n"],
  "mappings": "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",
  "names": []
}
