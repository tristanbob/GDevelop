{
  "version": 3,
  "sources": ["../../../../../../GDJS/Runtime/pixi-renderers/pixi-image-manager.ts"],
  "sourcesContent": ["/*\n * GDevelop JS Platform\n * Copyright 2013-2016 Florian Rival (Florian.Rival@gmail.com). All rights reserved.\n * This project is released under the MIT License.\n */\nnamespace gdjs {\n  const logger = new gdjs.Logger('PIXI Image manager');\n  import PIXI = GlobalPIXIModule.PIXI;\n\n  const logFileLoadingError = (file: string, error: Error | undefined) => {\n    logger.error(\n      'Unable to load file ' + file + ' with error:',\n      error ? error : '(unknown error)'\n    );\n  };\n\n  const applyTextureSettings = (\n    texture: PIXI.Texture | undefined,\n    resourceData: ResourceData\n  ) => {\n    if (!texture) return;\n\n    if (!resourceData.smoothed) {\n      texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;\n    }\n  };\n\n  const applyThreeTextureSettings = (\n    threeTexture: THREE.Texture,\n    resourceData: ResourceData | null\n  ) => {\n    if (resourceData && !resourceData.smoothed) {\n      threeTexture.magFilter = THREE.NearestFilter;\n      threeTexture.minFilter = THREE.NearestFilter;\n    }\n  };\n\n  const findResourceWithNameAndKind = (\n    resources: ResourceData[],\n    resourceName: string,\n    kind: ResourceKind\n  ): ResourceData | null => {\n    for (let i = 0, len = resources.length; i < len; ++i) {\n      const res = resources[i];\n      if (res.name === resourceName && res.kind === kind) {\n        return res;\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * PixiImageManager loads and stores textures that can be used by the Pixi.js renderers.\n   */\n  export class PixiImageManager {\n    _resources: ResourceData[];\n\n    /**\n     * The invalid texture is a 8x8 PNG file filled with magenta (#ff00ff), to be\n     * easily spotted if rendered on screen.\n     */\n    private _invalidTexture: PIXI.Texture;\n\n    /**\n     * Map associating a resource name to the loaded PixiJS texture.\n     */\n    private _loadedTextures: Hashtable<PIXI.Texture<PIXI.Resource>>;\n\n    /**\n     * Map associating a resource name to the loaded Three.js texture.\n     */\n    private _loadedThreeTextures: Hashtable<THREE.Texture>;\n    private _loadedThreeMaterials: Hashtable<THREE.Material>;\n\n    private _resourcesLoader: RuntimeGameResourcesLoader;\n\n    /**\n     * @param resources The resources data of the game.\n     * @param resourcesLoader The resources loader of the game.\n     */\n    constructor(\n      resources: ResourceData[],\n      resourcesLoader: RuntimeGameResourcesLoader\n    ) {\n      this._resources = resources;\n      this._resourcesLoader = resourcesLoader;\n      this._invalidTexture = PIXI.Texture.from(\n        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAFElEQVQoU2P8z/D/PwMewDgyFAAApMMX8Zi0uXAAAAAASUVORK5CYIIA'\n      );\n      this._loadedTextures = new Hashtable();\n      this._loadedThreeTextures = new Hashtable();\n      this._loadedThreeMaterials = new Hashtable();\n    }\n\n    /**\n     * Update the resources data of the game. Useful for hot-reloading, should not be used otherwise.\n     *\n     * @param resources The resources data of the game.\n     */\n    setResources(resources: ResourceData[]): void {\n      this._resources = resources;\n    }\n\n    /**\n     * Return the PIXI texture associated to the specified resource name.\n     * Returns a placeholder texture if not found.\n     * @param resourceName The name of the resource\n     * @returns The requested texture, or a placeholder if not found.\n     */\n    getPIXITexture(resourceName: string): PIXI.Texture {\n      if (this._loadedTextures.containsKey(resourceName)) {\n        const texture = this._loadedTextures.get(resourceName);\n        if (texture.valid) {\n          return texture;\n        } else {\n          logger.error(\n            'Texture for ' +\n              resourceName +\n              ' is not valid anymore (or never was).'\n          );\n        }\n      }\n      if (resourceName === '') {\n        return this._invalidTexture;\n      }\n\n      // Texture is not loaded, load it now from the resources list.\n      const resource = findResourceWithNameAndKind(\n        this._resources,\n        resourceName,\n        'image'\n      );\n\n      if (!resource) {\n        logger.warn(\n          'Unable to find texture for resource \"' + resourceName + '\".'\n        );\n        return this._invalidTexture;\n      }\n\n      logger.log('Loading texture for resource \"' + resourceName + '\"...');\n      const file = resource.file;\n      const texture = PIXI.Texture.from(\n        this._resourcesLoader.getFullUrl(file),\n        {\n          resourceOptions: {\n            // Note that using `false`\n            // to not having `crossorigin` at all would NOT work because the browser would taint the\n            // loaded resource so that it can't be read/used in a canvas (it's only working for display `<img>` on screen).\n            crossorigin: this._resourcesLoader.checkIfCredentialsRequired(file)\n              ? 'use-credentials'\n              : 'anonymous',\n          },\n        }\n      ).on('error', (error) => {\n        logFileLoadingError(file, error);\n      });\n      applyTextureSettings(texture, resource);\n\n      this._loadedTextures.put(resourceName, texture);\n      return texture;\n    }\n\n    /**\n     * Return the three.js texture associated to the specified resource name.\n     * Returns a placeholder texture if not found.\n     * @param resourceName The name of the resource\n     * @returns The requested texture, or a placeholder if not found.\n     */\n    getThreeTexture(resourceName: string): THREE.Texture {\n      const loadedThreeTexture = this._loadedThreeTextures.get(resourceName);\n      if (loadedThreeTexture) return loadedThreeTexture;\n\n      // Texture is not loaded, load it now from the PixiJS texture.\n      // TODO (3D) - optimization: don't load the PixiJS Texture if not used by PixiJS.\n      // TODO (3D) - optimization: Ideally we could even share the same WebGL texture.\n      const pixiTexture = this.getPIXITexture(resourceName);\n      const pixiRenderer = this._resourcesLoader._runtimeGame\n        .getRenderer()\n        .getPIXIRenderer();\n      if (!pixiRenderer) throw new Error('No PIXI renderer was found.');\n\n      // @ts-ignore - source does exist on resource.\n      const image = pixiTexture.baseTexture.resource.source;\n      if (!(image instanceof HTMLImageElement)) {\n        throw new Error(\n          `Can't load texture for resource \"${resourceName}\" as it's not an image.`\n        );\n      }\n\n      const threeTexture = new THREE.Texture(image);\n      threeTexture.magFilter = THREE.LinearFilter;\n      threeTexture.minFilter = THREE.LinearFilter;\n      threeTexture.wrapS = THREE.RepeatWrapping;\n      threeTexture.wrapT = THREE.RepeatWrapping;\n      threeTexture.colorSpace = THREE.SRGBColorSpace;\n      threeTexture.needsUpdate = true;\n\n      const resource = findResourceWithNameAndKind(\n        this._resources,\n        resourceName,\n        'image'\n      );\n\n      applyThreeTextureSettings(threeTexture, resource);\n      this._loadedThreeTextures.put(resourceName, threeTexture);\n\n      return threeTexture;\n    }\n\n    /**\n     * Return the three.js material associated to the specified resource name.\n     * @param resourceName The name of the resource\n     * @param options\n     * @returns The requested material.\n     */\n    getThreeMaterial(\n      resourceName: string,\n      {\n        useTransparentTexture,\n        forceBasicMaterial,\n      }: { useTransparentTexture: boolean; forceBasicMaterial: boolean }\n    ) {\n      const cacheKey = `${resourceName}|${useTransparentTexture ? 1 : 0}|${\n        forceBasicMaterial ? 1 : 0\n      }`;\n\n      const loadedThreeMaterial = this._loadedThreeMaterials.get(cacheKey);\n      if (loadedThreeMaterial) return loadedThreeMaterial;\n\n      const material = forceBasicMaterial\n        ? new THREE.MeshBasicMaterial({\n            map: this.getThreeTexture(resourceName),\n            side: useTransparentTexture ? THREE.DoubleSide : THREE.FrontSide,\n            transparent: useTransparentTexture,\n          })\n        : new THREE.MeshStandardMaterial({\n            map: this.getThreeTexture(resourceName),\n            side: useTransparentTexture ? THREE.DoubleSide : THREE.FrontSide,\n            transparent: useTransparentTexture,\n            metalness: 0,\n          });\n      this._loadedThreeMaterials.put(cacheKey, material);\n      return material;\n    }\n\n    /**\n     * Return the PIXI video texture associated to the specified resource name.\n     * Returns a placeholder texture if not found.\n     * @param resourceName The name of the resource to get.\n     */\n    getPIXIVideoTexture(resourceName: string) {\n      if (this._loadedTextures.containsKey(resourceName)) {\n        return this._loadedTextures.get(resourceName);\n      }\n      if (resourceName === '') {\n        return this._invalidTexture;\n      }\n\n      // Texture is not loaded, load it now from the resources list.\n      const resource = findResourceWithNameAndKind(\n        this._resources,\n        resourceName,\n        'video'\n      );\n\n      if (!resource) {\n        logger.warn(\n          'Unable to find video texture for resource \"' + resourceName + '\".'\n        );\n        return this._invalidTexture;\n      }\n\n      const file = resource.file;\n      logger.log(\n        'Loading video texture for resource \"' + resourceName + '\"...'\n      );\n      const texture = PIXI.Texture.from(\n        this._resourcesLoader.getFullUrl(file),\n        {\n          resourceOptions: {\n            // Note that using `false`\n            // to not having `crossorigin` at all would NOT work because the browser would taint the\n            // loaded resource so that it can't be read/used in a canvas (it's only working for display `<img>` on screen).\n            crossorigin: this._resourcesLoader.checkIfCredentialsRequired(file)\n              ? 'use-credentials'\n              : 'anonymous',\n          },\n        }\n      ).on('error', (error) => {\n        logFileLoadingError(file, error);\n      });\n\n      this._loadedTextures.put(resourceName, texture);\n      return texture;\n    }\n\n    /**\n     * Return a PIXI texture which can be used as a placeholder when no\n     * suitable texture can be found.\n     */\n    getInvalidPIXITexture() {\n      return this._invalidTexture;\n    }\n\n    /**\n     * Load the specified resources, so that textures are loaded and can then be\n     * used by calling `getPIXITexture`.\n     * @param onProgress Callback called each time a new file is loaded.\n     * @param onComplete Callback called when loading is done.\n     */\n    loadTextures(onProgress, onComplete) {\n      const resources = this._resources;\n\n      // Construct the list of files to be loaded.\n      // For one loaded file, it can have one or more resources\n      // that use it.\n      const resourceFiles: Record<string, ResourceData[]> = {};\n      for (let i = 0, len = resources.length; i < len; ++i) {\n        const res = resources[i];\n        if (res.file && res.kind === 'image') {\n          if (this._loadedTextures.containsKey(res.name)) {\n            // This resource is already loaded.\n            continue;\n          }\n          resourceFiles[res.file] = resourceFiles[res.file]\n            ? resourceFiles[res.file].concat(res)\n            : [res];\n        }\n      }\n      const totalCount = Object.keys(resourceFiles).length;\n      if (totalCount === 0) {\n        // Nothing to load.\n        return onComplete(totalCount);\n      }\n\n      const loader = PIXI.Loader.shared;\n      let loadingCount = 0;\n      const progressCallbackId = loader.onProgress.add(function () {\n        loadingCount++;\n        onProgress(loadingCount, totalCount);\n      });\n      for (const file in resourceFiles) {\n        if (resourceFiles.hasOwnProperty(file)) {\n          loader.add({\n            name: file,\n            url: this._resourcesLoader.getFullUrl(file),\n            loadType: PIXI.LoaderResource.LOAD_TYPE.IMAGE,\n            crossOrigin: this._resourcesLoader.checkIfCredentialsRequired(file)\n              ? 'use-credentials'\n              : 'anonymous',\n          });\n        }\n      }\n      loader.load((loader, loadedPixiResources) => {\n        loader.onProgress.detach(progressCallbackId);\n\n        // Store the loaded textures so that they are ready to use.\n        for (const file in loadedPixiResources) {\n          if (loadedPixiResources.hasOwnProperty(file)) {\n            if (!resourceFiles.hasOwnProperty(file)) {\n              continue;\n            }\n\n            resourceFiles[file].forEach((resource) => {\n              const loadedTexture = loadedPixiResources[file].texture;\n              if (!loadedTexture) {\n                const error = loadedPixiResources[file].error;\n                logFileLoadingError(file, error);\n                return;\n              }\n\n              this._loadedTextures.put(resource.name, loadedTexture);\n              applyTextureSettings(loadedTexture, resource);\n            });\n          }\n        }\n        onComplete(totalCount);\n      });\n    }\n  }\n\n  //Register the class to let the engine use it.\n  export const ImageManager = gdjs.PixiImageManager;\n  export type ImageManager = gdjs.PixiImageManager;\n}\n"],
  "mappings": "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",
  "names": []
}
