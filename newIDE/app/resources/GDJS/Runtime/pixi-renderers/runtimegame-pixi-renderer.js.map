{
  "version": 3,
  "sources": ["../../../../../../GDJS/Runtime/pixi-renderers/runtimegame-pixi-renderer.ts"],
  "sourcesContent": ["namespace gdjs {\n  const logger = new gdjs.Logger('PIXI game renderer');\n\n  import PIXI = GlobalPIXIModule.PIXI;\n\n  /**\n   * Codes (as in `event.code`) of keys that should have their event `preventDefault`\n   * called. This is used to avoid scrolling in a webpage when these keys are pressed\n   * in the game.\n   */\n  const defaultPreventedKeyCodes = [\n    37, // ArrowLeft\n    38, // ArrowUp\n    39, // ArrowRight\n    40, // ArrowDown\n  ];\n\n  /**\n   * The renderer for a gdjs.RuntimeGame using Pixi.js.\n   */\n  export class RuntimeGamePixiRenderer {\n    _game: gdjs.RuntimeGame;\n    _isFullPage: boolean = true;\n\n    //Used to track if the canvas is displayed on the full page.\n    _isFullscreen: boolean = false;\n\n    //Used to track if the window is displayed as fullscreen (see setFullscreen method).\n    _forceFullscreen: any;\n\n    _pixiRenderer: PIXI.Renderer | null = null;\n    private _threeRenderer: THREE.WebGLRenderer | null = null;\n    private _gameCanvas: HTMLCanvasElement | null = null;\n    private _domElementsContainer: HTMLDivElement | null = null;\n\n    // Current width of the canvas (might be scaled down/up compared to renderer)\n    _canvasWidth: float = 0;\n    // Current height of the canvas (might be scaled down/up compared to renderer)\n    _canvasHeight: float = 0;\n\n    _keepRatio: boolean = true;\n    _marginLeft: any;\n    _marginTop: any;\n    _marginRight: any;\n    _marginBottom: any;\n\n    _nextFrameId: integer = 0;\n\n    /**\n     * @param game The game that is being rendered\n     * @param forceFullscreen If fullscreen should be always activated\n     */\n    constructor(game: gdjs.RuntimeGame, forceFullscreen: boolean) {\n      this._game = game;\n      this._forceFullscreen = forceFullscreen;\n\n      //If set to true, the canvas will always be displayed as fullscreen, even if _isFullscreen == false.\n      this._marginLeft = this._marginTop = this._marginRight = this._marginBottom = 0;\n      this._setupOrientation();\n    }\n\n    /**\n     * Create a standard canvas inside canvasArea.\n     *\n     */\n    createStandardCanvas(parentElement: HTMLElement) {\n      let gameCanvas: HTMLCanvasElement;\n      if (typeof THREE !== 'undefined') {\n        gameCanvas = document.createElement('canvas');\n        this._threeRenderer = new THREE.WebGLRenderer({\n          canvas: gameCanvas,\n          antialias:\n            this._game.getAntialiasingMode() !== 'none' &&\n            (this._game.isAntialisingEnabledOnMobile() ||\n              !gdjs.evtTools.common.isMobile()),\n        });\n        this._threeRenderer.autoClear = false;\n        this._threeRenderer.setSize(\n          this._game.getGameResolutionWidth(),\n          this._game.getGameResolutionHeight()\n        );\n\n        // Create a PixiJS renderer that use the same GL context as Three.js\n        // so that both can render to the canvas and even have PixiJS rendering\n        // reused in Three.js (by using a RenderTexture and the same internal WebGL texture).\n        this._pixiRenderer = new PIXI.Renderer({\n          width: this._game.getGameResolutionWidth(),\n          height: this._game.getGameResolutionHeight(),\n          view: gameCanvas,\n          // @ts-ignore - reuse the context from Three.js.\n          context: this._threeRenderer.getContext(),\n          clearBeforeRender: false,\n          preserveDrawingBuffer: true,\n          antialias: false,\n          backgroundAlpha: 0,\n          // TODO (3D): add a setting for pixel ratio (`resolution: window.devicePixelRatio`)\n        });\n\n        gameCanvas = this._threeRenderer.domElement;\n      } else {\n        // Create the renderer and setup the rendering area.\n        // \"preserveDrawingBuffer: true\" is needed to avoid flickering\n        // and background issues on some mobile phones (see #585 #572 #566 #463).\n        this._pixiRenderer = PIXI.autoDetectRenderer({\n          width: this._game.getGameResolutionWidth(),\n          height: this._game.getGameResolutionHeight(),\n          preserveDrawingBuffer: true,\n          antialias: false,\n        }) as PIXI.Renderer;\n\n        gameCanvas = this._pixiRenderer.view;\n      }\n\n      // Add the renderer view element to the DOM\n      parentElement.appendChild(gameCanvas);\n      this._gameCanvas = gameCanvas;\n\n      gameCanvas.style.position = 'absolute';\n\n      // Ensure that the canvas has the focus.\n      gameCanvas.tabIndex = 1;\n\n      // Ensure long press can't create a selection\n      gameCanvas.style.userSelect = 'none';\n      gameCanvas.style.outline = 'none'; // No selection/focus ring on the canvas.\n\n      // Set up the container for HTML elements on top of the game canvas.\n      const domElementsContainer = document.createElement('div');\n      domElementsContainer.style.position = 'absolute';\n      domElementsContainer.style.overflow = 'hidden'; // Never show anything outside the container.\n      domElementsContainer.style.outline = 'none'; // No selection/focus ring on this container.\n      domElementsContainer.style.pointerEvents = 'none'; // Clicks go through the container.\n\n      // The container should *never* scroll.\n      // Elements are put inside with the same coordinates (with a scaling factor)\n      // as on the game canvas.\n      domElementsContainer.addEventListener('scroll', (event) => {\n        domElementsContainer.scrollLeft = 0;\n        domElementsContainer.scrollTop = 0;\n        event.preventDefault();\n      });\n\n      // When clicking outside an input, (or other HTML element),\n      // give back focus to the game canvas so that this element is blurred.\n      gameCanvas.addEventListener('pointerdown', () => {\n        gameCanvas.focus();\n      });\n\n      // Prevent magnifying glass on iOS with a long press.\n      // Note that there are related bugs on iOS 15 (see https://bugs.webkit.org/show_bug.cgi?id=231161)\n      // but it seems not to affect us as the `domElementsContainer` has `pointerEvents` set to `none`.\n      domElementsContainer.style['-webkit-user-select'] = 'none';\n\n      parentElement.appendChild(domElementsContainer);\n      this._domElementsContainer = domElementsContainer;\n\n      this._resizeCanvas();\n\n      // Handle scale mode.\n      if (this._game.getScaleMode() === 'nearest') {\n        gameCanvas.style['image-rendering'] = '-moz-crisp-edges';\n        gameCanvas.style['image-rendering'] = '-webkit-optimize-contrast';\n        gameCanvas.style['image-rendering'] = '-webkit-crisp-edges';\n        gameCanvas.style['image-rendering'] = 'pixelated';\n      }\n\n      // Handle pixels rounding.\n      if (this._game.getPixelsRounding()) {\n        PIXI.settings.ROUND_PIXELS = true;\n      }\n\n      // Handle resize: immediately adjust the game canvas (and dom element container)\n      // and notify the game (that may want to adjust to the new size of the window).\n      window.addEventListener('resize', () => {\n        this._game.onWindowInnerSizeChanged();\n        this._resizeCanvas();\n      });\n\n      // Focus the canvas when created.\n      gameCanvas.focus();\n    }\n\n    static getWindowInnerWidth() {\n      return typeof window !== 'undefined' ? window.innerWidth : 800;\n    }\n\n    static getWindowInnerHeight() {\n      return typeof window !== 'undefined' ? window.innerHeight : 800;\n    }\n\n    /**\n     * Update the game renderer size according to the \"game resolution\".\n     * Called when game resolution changes.\n     *\n     * Note that if the canvas is fullscreen, it won't be resized, but when going back to\n     * non fullscreen mode, the requested size will be used.\n     */\n    updateRendererSize(): void {\n      this._resizeCanvas();\n    }\n\n    /**\n     * Set the proper screen orientation from the project properties.\n     */\n    private _setupOrientation() {\n      if (\n        typeof window === 'undefined' ||\n        !window.screen ||\n        !window.screen.orientation\n      ) {\n        return;\n      }\n      const gameOrientation = this._game.getGameData().properties.orientation;\n      try {\n        // We ignore the error as some platforms may not supporting locking (i.e: desktop).\n        if (gameOrientation === 'default') {\n          const promise = window.screen.orientation.unlock();\n          // @ts-ignore\n          if (promise) {\n            // @ts-ignore\n            promise.catch(() => {});\n          }\n        } else {\n          // @ts-ignore\n          window.screen.orientation.lock(gameOrientation).catch(() => {});\n        }\n      } catch (error) {\n        logger.error('Unexpected error while setting up orientation: ', error);\n      }\n    }\n\n    /**\n     * Resize the renderer (the \"game resolution\") and the canvas (which can be larger\n     * or smaller to fill the page, with optional margins).\n     *\n     */\n    private _resizeCanvas() {\n      if (!this._pixiRenderer || !this._domElementsContainer) return;\n\n      // Set the Pixi (and/or Three) renderer size to the game size.\n      // There is no \"smart\" resizing to be done here: the rendering of the game\n      // should be done with the size set on the game.\n      if (\n        this._pixiRenderer.width !== this._game.getGameResolutionWidth() ||\n        this._pixiRenderer.height !== this._game.getGameResolutionHeight()\n      ) {\n        // TODO (3D): It might be useful to resize pixi view in 3D depending on FOV value\n        // to enable a mode where pixi always fills the whole screen.\n        this._pixiRenderer.resize(\n          this._game.getGameResolutionWidth(),\n          this._game.getGameResolutionHeight()\n        );\n\n        if (this._threeRenderer) {\n          this._threeRenderer.setSize(\n            this._game.getGameResolutionWidth(),\n            this._game.getGameResolutionHeight()\n          );\n        }\n      }\n\n      // Set the canvas size.\n      // Resizing is done according to the settings. This is a \"CSS\" resize\n      // only, so won't create visual artifacts during the rendering.\n      const isFullPage =\n        this._forceFullscreen || this._isFullPage || this._isFullscreen;\n      let canvasWidth = this._game.getGameResolutionWidth();\n      let canvasHeight = this._game.getGameResolutionHeight();\n      let maxWidth = window.innerWidth - this._marginLeft - this._marginRight;\n      let maxHeight = window.innerHeight - this._marginTop - this._marginBottom;\n      if (maxWidth < 0) {\n        maxWidth = 0;\n      }\n      if (maxHeight < 0) {\n        maxHeight = 0;\n      }\n      if (isFullPage && !this._keepRatio) {\n        canvasWidth = maxWidth;\n        canvasHeight = maxHeight;\n      } else {\n        if (\n          (isFullPage && this._keepRatio) ||\n          canvasWidth > maxWidth ||\n          canvasHeight > maxHeight\n        ) {\n          let factor = maxWidth / canvasWidth;\n          if (canvasHeight * factor > maxHeight) {\n            factor = maxHeight / canvasHeight;\n          }\n          canvasWidth *= factor;\n          canvasHeight *= factor;\n        }\n      }\n\n      // Apply the calculations to the canvas element...\n      if (this._gameCanvas) {\n        this._gameCanvas.style.top =\n          this._marginTop + (maxHeight - canvasHeight) / 2 + 'px';\n        this._gameCanvas.style.left =\n          this._marginLeft + (maxWidth - canvasWidth) / 2 + 'px';\n        this._gameCanvas.style.width = canvasWidth + 'px';\n        this._gameCanvas.style.height = canvasHeight + 'px';\n      }\n\n      // ...and to the div on top of it showing DOM elements (like inputs).\n      this._domElementsContainer.style.top =\n        this._marginTop + (maxHeight - canvasHeight) / 2 + 'px';\n      this._domElementsContainer.style.left =\n        this._marginLeft + (maxWidth - canvasWidth) / 2 + 'px';\n      this._domElementsContainer.style.width = canvasWidth + 'px';\n      this._domElementsContainer.style.height = canvasHeight + 'px';\n\n      // Store the canvas size for fast access to it.\n      this._canvasWidth = canvasWidth;\n      this._canvasHeight = canvasHeight;\n    }\n\n    /**\n     * Set if the aspect ratio must be kept when the game canvas is resized to fill\n     * the page.\n     */\n    keepAspectRatio(enable) {\n      if (this._keepRatio === enable) {\n        return;\n      }\n      this._keepRatio = enable;\n      this._resizeCanvas();\n    }\n\n    /**\n     * Change the margin that must be preserved around the game canvas.\n     */\n    setMargins(top, right, bottom, left): void {\n      if (\n        this._marginTop === top &&\n        this._marginRight === right &&\n        this._marginBottom === bottom &&\n        this._marginLeft === left\n      ) {\n        return;\n      }\n      this._marginTop = top;\n      this._marginRight = right;\n      this._marginBottom = bottom;\n      this._marginLeft = left;\n      this._resizeCanvas();\n    }\n\n    /**\n     * Update the window size, if possible.\n     * @param width The new width, in pixels.\n     * @param height The new height, in pixels.\n     */\n    setWindowSize(width: float, height: float): void {\n      const remote = this.getElectronRemote();\n      if (remote) {\n        // Use Electron BrowserWindow API\n        const browserWindow = remote.getCurrentWindow();\n        if (browserWindow) {\n          browserWindow.setContentSize(width, height);\n        }\n      } else {\n        logger.warn(\"Window size can't be changed on this platform.\");\n      }\n    }\n\n    /**\n     * Center the window on screen.\n     */\n    centerWindow() {\n      const remote = this.getElectronRemote();\n      if (remote) {\n        // Use Electron BrowserWindow API\n        const browserWindow = remote.getCurrentWindow();\n        if (browserWindow) {\n          browserWindow.center();\n        }\n      } else {\n      }\n    }\n\n    // Not supported\n    /**\n     * De/activate fullscreen for the game.\n     */\n    setFullScreen(enable): void {\n      if (this._forceFullscreen) {\n        return;\n      }\n      if (this._isFullscreen !== enable) {\n        this._isFullscreen = !!enable;\n        const remote = this.getElectronRemote();\n        if (remote) {\n          // Use Electron BrowserWindow API\n          const browserWindow = remote.getCurrentWindow();\n          if (browserWindow) {\n            browserWindow.setFullScreen(this._isFullscreen);\n          }\n        } else {\n          // Use HTML5 Fullscreen API\n          //TODO: Do this on a user gesture, otherwise most browsers won't activate fullscreen\n          if (this._isFullscreen) {\n            // @ts-ignore\n            if (document.documentElement.requestFullscreen) {\n              // @ts-ignore\n              document.documentElement.requestFullscreen();\n            } else {\n              // @ts-ignore\n              if (document.documentElement.mozRequestFullScreen) {\n                // @ts-ignore\n                document.documentElement.mozRequestFullScreen();\n              } else {\n                // @ts-ignore\n                if (document.documentElement.webkitRequestFullScreen) {\n                  // @ts-ignore\n                  document.documentElement.webkitRequestFullScreen();\n                }\n              }\n            }\n          } else {\n            // @ts-ignore\n            if (document.exitFullscreen) {\n              // @ts-ignore\n              document.exitFullscreen();\n            } else {\n              // @ts-ignore\n              if (document.mozCancelFullScreen) {\n                // @ts-ignore\n                document.mozCancelFullScreen();\n              } else {\n                // @ts-ignore\n                if (document.webkitCancelFullScreen) {\n                  // @ts-ignore\n                  document.webkitCancelFullScreen();\n                }\n              }\n            }\n          }\n        }\n        this._resizeCanvas();\n      }\n    }\n\n    /**\n     * Checks if the game is in full screen.\n     */\n    isFullScreen(): boolean {\n      const remote = this.getElectronRemote();\n      if (remote) {\n        return remote.getCurrentWindow().isFullScreen();\n      }\n\n      // Height check is used to detect user triggered full screen (for example F11 shortcut).\n      return this._isFullscreen || window.screen.height === window.innerHeight;\n    }\n\n    /**\n     * Convert a point from the canvas coordinates to the dom element container coordinates.\n     *\n     * @param canvasCoords The point in the canvas coordinates.\n     * @param result The point to return.\n     * @returns The point in the dom element container coordinates.\n     */\n    convertCanvasToDomElementContainerCoords(\n      canvasCoords: FloatPoint,\n      result: FloatPoint\n    ): FloatPoint {\n      const pageCoords = result || [0, 0];\n\n      // Handle the fact that the game is stretched to fill the canvas.\n      pageCoords[0] =\n        (canvasCoords[0] * this._canvasWidth) /\n        this._game.getGameResolutionWidth();\n      pageCoords[1] =\n        (canvasCoords[1] * this._canvasHeight) /\n        this._game.getGameResolutionHeight();\n\n      return pageCoords;\n    }\n\n    /**\n     * Return the scale factor between the renderer height and the actual canvas height,\n     * which is also the height of the container for DOM elements to be superimposed on top of it.\n     *\n     * Useful to scale font sizes of DOM elements so that they follow the size of the game.\n     */\n    getCanvasToDomElementContainerHeightScale(): float {\n      return (this._canvasHeight || 1) / this._game.getGameResolutionHeight();\n    }\n\n    /**\n     * Add the standard events handler.\n     */\n    bindStandardEvents(\n      manager: gdjs.InputManager,\n      window: Window,\n      document: Document\n    ) {\n      const canvas = this._gameCanvas;\n      if (!canvas) return;\n\n      //Translate an event (mouse or touch) made on the canvas on the page\n      //to game coordinates.\n      const getEventPosition = (e: MouseEvent | Touch) => {\n        const pos = [e.pageX - canvas.offsetLeft, e.pageY - canvas.offsetTop];\n\n        // Handle the fact that the game is stretched to fill the canvas.\n        pos[0] *=\n          this._game.getGameResolutionWidth() / (this._canvasWidth || 1);\n        pos[1] *=\n          this._game.getGameResolutionHeight() / (this._canvasHeight || 1);\n        return pos;\n      };\n\n      const isInsideCanvas = (e: MouseEvent | Touch) => {\n        const x = e.pageX - canvas.offsetLeft;\n        const y = e.pageY - canvas.offsetTop;\n\n        return (\n          0 <= x &&\n          x < (this._canvasWidth || 1) &&\n          0 <= y &&\n          y < (this._canvasHeight || 1)\n        );\n      };\n\n      //Some browsers lacks definition of some variables used to do calculations\n      //in getEventPosition. They are defined to 0 as they are useless.\n\n      (function ensureOffsetsExistence() {\n        if (isNaN(canvas.offsetLeft)) {\n          // @ts-ignore\n          canvas.offsetLeft = 0;\n          // @ts-ignore\n          canvas.offsetTop = 0;\n        }\n        if (isNaN(document.body.scrollLeft)) {\n          document.body.scrollLeft = 0;\n          document.body.scrollTop = 0;\n        }\n        if (\n          document.documentElement === undefined ||\n          document.documentElement === null\n        ) {\n          // @ts-ignore\n          document.documentElement = {};\n        }\n        if (isNaN(document.documentElement.scrollLeft)) {\n          document.documentElement.scrollLeft = 0;\n          document.documentElement.scrollTop = 0;\n        }\n        if (isNaN(canvas.offsetLeft)) {\n          // @ts-ignore\n          canvas.offsetLeft = 0;\n          // @ts-ignore\n          canvas.offsetTop = 0;\n        }\n      })();\n\n      // Keyboard: listen at the document level to capture even when the canvas\n      // is not focused.\n\n      const isFocusingDomElement = () => {\n        // Fast bailout when the game canvas should receive the inputs (i.e: almost always).\n        // Also check the document body or null for activeElement, as all of these should go\n        // to the game.\n        if (\n          document.activeElement === canvas ||\n          document.activeElement === document.body ||\n          document.activeElement === null\n        )\n          return false;\n\n        return true;\n      };\n      const isTargetDomElement = (event: TouchEvent) => {\n        // Fast bailout when the game canvas should receive the inputs (i.e: almost always).\n        // Any event with a target that is not the body or the canvas should\n        // not go to the game (<input> or <a> elements for instances).\n        if (event.target === canvas || event.target === document.body)\n          return false;\n        return true;\n      };\n      document.onkeydown = function (e) {\n        if (isFocusingDomElement()) {\n          // Bail out if the game canvas is not focused. For example,\n          // an `<input>` element can be focused, and needs to receive\n          // arrow keys events.\n          return;\n        }\n\n        if (defaultPreventedKeyCodes.includes(e.keyCode)) {\n          // Some keys are \"default prevented\" to avoid scrolling when the game\n          // is integrated in a page as an iframe.\n          e.preventDefault();\n        }\n\n        manager.onKeyPressed(e.keyCode, e.location);\n      };\n      document.onkeyup = function (e) {\n        if (isFocusingDomElement()) {\n          // Bail out if the game canvas is not focused. For example,\n          // an `<input>` element can be focused, and needs to receive\n          // arrow keys events.\n          return;\n        }\n\n        if (defaultPreventedKeyCodes.includes(e.keyCode)) {\n          // Some keys are \"default prevented\" to avoid scrolling when the game\n          // is integrated in a page as an iframe.\n          e.preventDefault();\n        }\n\n        manager.onKeyReleased(e.keyCode, e.location);\n      };\n\n      // Mouse:\n\n      // Converts HTML mouse button to InputManager mouse button.\n      // This function is used to align HTML button values with GDevelop 3 C++ SFML Mouse button enum values,\n      // notably the middle and right buttons.\n      function convertHtmlMouseButtonToInputManagerMouseButton(button: number) {\n        switch (button) {\n          case 1: // Middle button\n            return gdjs.InputManager.MOUSE_MIDDLE_BUTTON;\n          case 2: // Right button\n            return gdjs.InputManager.MOUSE_RIGHT_BUTTON;\n        }\n        return button;\n      }\n      canvas.onmousemove = function (e) {\n        const pos = getEventPosition(e);\n        manager.onMouseMove(pos[0], pos[1]);\n      };\n      canvas.onmousedown = function (e) {\n        manager.onMouseButtonPressed(\n          convertHtmlMouseButtonToInputManagerMouseButton(e.button)\n        );\n        if (window.focus !== undefined) {\n          window.focus();\n        }\n        return false;\n      };\n      canvas.onmouseup = function (e) {\n        manager.onMouseButtonReleased(\n          convertHtmlMouseButtonToInputManagerMouseButton(e.button)\n        );\n        return false;\n      };\n      canvas.onmouseleave = function (e) {\n        manager.onMouseLeave();\n      };\n      canvas.onmouseenter = function (e) {\n        manager.onMouseEnter();\n        // There is no mouse event when the cursor is outside of the canvas.\n        // We catchup what happened.\n        const buttons = [\n          gdjs.InputManager.MOUSE_LEFT_BUTTON,\n          gdjs.InputManager.MOUSE_RIGHT_BUTTON,\n          gdjs.InputManager.MOUSE_MIDDLE_BUTTON,\n          gdjs.InputManager.MOUSE_BACK_BUTTON,\n          gdjs.InputManager.MOUSE_FORWARD_BUTTON,\n        ];\n        for (let i = 0, len = buttons.length; i < len; ++i) {\n          const button = buttons[i];\n          const buttonIsPressed = (e.buttons & (1 << i)) !== 0;\n          const buttonWasPressed = manager.isMouseButtonPressed(button);\n          if (buttonIsPressed && !buttonWasPressed) {\n            manager.onMouseButtonPressed(button);\n          } else if (!buttonIsPressed && buttonWasPressed) {\n            manager.onMouseButtonReleased(button);\n          }\n        }\n      };\n      window.addEventListener(\n        'click',\n        function (e) {\n          if (window.focus !== undefined) {\n            window.focus();\n          }\n          return false;\n        },\n        false\n      );\n      canvas.oncontextmenu = function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n        return false;\n      };\n      // @ts-ignore\n      canvas.onwheel = function (event) {\n        manager.onMouseWheel(-event.deltaY);\n      };\n\n      // Touches:\n      window.addEventListener('touchmove', function (e) {\n        if (isTargetDomElement(e)) {\n          // Bail out if the game canvas is not focused. For example,\n          // an `<input>` element can be focused, and needs to receive\n          // touch events to move the selection (and do other native gestures).\n          return;\n        }\n\n        e.preventDefault();\n        if (e.changedTouches) {\n          for (let i = 0; i < e.changedTouches.length; ++i) {\n            const pos = getEventPosition(e.changedTouches[i]);\n            manager.onTouchMove(e.changedTouches[i].identifier, pos[0], pos[1]);\n            // This works because touch events are sent\n            // when they continue outside of the canvas.\n            if (manager.isSimulatingMouseWithTouch()) {\n              if (isInsideCanvas(e.changedTouches[i])) {\n                manager.onMouseEnter();\n              } else {\n                manager.onMouseLeave();\n              }\n            }\n          }\n        }\n      });\n      window.addEventListener('touchstart', function (e) {\n        if (isTargetDomElement(e)) {\n          // Bail out if the game canvas is not focused. For example,\n          // an `<input>` element can be focused, and needs to receive\n          // touch events to move the selection (and do other native gestures).\n          return;\n        }\n\n        e.preventDefault();\n        if (e.changedTouches) {\n          for (let i = 0; i < e.changedTouches.length; ++i) {\n            const pos = getEventPosition(e.changedTouches[i]);\n            manager.onTouchStart(\n              e.changedTouches[i].identifier,\n              pos[0],\n              pos[1]\n            );\n          }\n        }\n        return false;\n      });\n      window.addEventListener('touchend', function (e) {\n        if (isTargetDomElement(e)) {\n          // Bail out if the game canvas is not focused. For example,\n          // an `<input>` element can be focused, and needs to receive\n          // touch events to move the selection (and do other native gestures).\n          return;\n        }\n\n        e.preventDefault();\n        if (e.changedTouches) {\n          for (let i = 0; i < e.changedTouches.length; ++i) {\n            manager.onTouchEnd(e.changedTouches[i].identifier);\n          }\n        }\n        return false;\n      });\n      window.addEventListener('touchcancel', function (e) {\n        if (isTargetDomElement(e)) {\n          // Bail out if the game canvas is not focused. For example,\n          // an `<input>` element can be focused, and needs to receive\n          // touch events to move the selection (and do other native gestures).\n          return;\n        }\n\n        e.preventDefault();\n        if (e.changedTouches) {\n          for (let i = 0; i < e.changedTouches.length; ++i) {\n            manager.onTouchCancel(e.changedTouches[i].identifier);\n          }\n        }\n        return false;\n      });\n    }\n\n    setWindowTitle(title): void {\n      if (typeof document !== 'undefined') {\n        document.title = title;\n      }\n    }\n\n    getWindowTitle() {\n      return typeof document !== 'undefined' ? document.title : '';\n    }\n\n    startGameLoop(fn) {\n      let oldTime = 0;\n      const gameLoop = (time: float) => {\n        // Schedule the next frame now to be sure it's called as soon\n        // as possible after this one is finished.\n        this._nextFrameId = requestAnimationFrame(gameLoop);\n\n        const dt = oldTime ? time - oldTime : 0;\n        oldTime = time;\n        if (!fn(dt)) {\n          // Stop the game loop if requested.\n          cancelAnimationFrame(this._nextFrameId);\n        }\n      };\n\n      requestAnimationFrame(gameLoop);\n    }\n\n    getPIXIRenderer() {\n      return this._pixiRenderer;\n    }\n\n    /**\n     * Get the Three.js renderer for the game - if any.\n     */\n    getThreeRenderer(): THREE.WebGLRenderer | null {\n      return this._threeRenderer;\n    }\n\n    /**\n     * Get the DOM element used as a container for HTML elements to display\n     * on top of the game.\n     */\n    getDomElementContainer() {\n      return this._domElementsContainer;\n    }\n\n    /**\n     * Open the given URL in the system browser (or a new tab)\n     */\n    openURL(url: string) {\n      // Try to detect the environment to use the most adapted\n      // way of opening an URL.\n\n      if (typeof window !== 'undefined') {\n        const electron = this.getElectron();\n        if (electron) {\n          electron.shell.openExternal(url);\n        } else {\n          // @ts-ignore\n          const target = window.cordova ? '_system' : '_blank';\n          window.open(url, target);\n        }\n      }\n    }\n\n    /**\n     * Close the game, if applicable\n     */\n    stopGame() {\n      // Try to detect the environment to use the most adapted\n      // way of closing the app\n      const remote = this.getElectronRemote();\n      if (remote) {\n        const browserWindow = remote.getCurrentWindow();\n        if (browserWindow) {\n          browserWindow.close();\n        }\n      } else {\n        if (\n          typeof navigator !== 'undefined' &&\n          // @ts-ignore\n          navigator.app &&\n          // @ts-ignore\n          navigator.app.exitApp\n        ) {\n          // @ts-ignore\n          navigator.app.exitApp();\n        }\n      }\n      // HTML5 games on mobile/browsers don't have a way to close their window/page.\n    }\n\n    /**\n     * Get the canvas DOM element.\n     */\n    getCanvas(): HTMLCanvasElement | null {\n      return this._gameCanvas;\n    }\n\n    /**\n     * Check if the device supports WebGL.\n     * @returns true if WebGL is supported\n     */\n    isWebGLSupported(): boolean {\n      return (\n        !!this._pixiRenderer &&\n        this._pixiRenderer.type === PIXI.RENDERER_TYPE.WEBGL\n      );\n    }\n\n    /**\n     * Get the electron module, if running as a electron renderer process.\n     */\n    getElectron() {\n      if (typeof require === 'function') {\n        return require('electron');\n      }\n      return null;\n    }\n\n    /**\n     * Helper to get the electron remote module, if running on Electron.\n     * Note that is not guaranteed to be supported in the future - avoid if possible.\n     */\n    getElectronRemote = () => {\n      if (typeof require === 'function') {\n        const runtimeGameOptions = this._game.getAdditionalOptions();\n        const moduleId =\n          runtimeGameOptions && runtimeGameOptions.electronRemoteRequirePath\n            ? runtimeGameOptions.electronRemoteRequirePath\n            : '@electron/remote';\n\n        try {\n          return require(moduleId);\n        } catch (requireError) {\n          console.error(\n            `Could not load @electron/remote from \"${moduleId}\". Error is:`,\n            requireError\n          );\n        }\n      }\n\n      return null;\n    };\n  }\n\n  //Register the class to let the engine use it.\n  export type RuntimeGameRenderer = RuntimeGamePixiRenderer;\n  export const RuntimeGameRenderer = RuntimeGamePixiRenderer;\n}\n"],
  "mappings": "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",
  "names": []
}
