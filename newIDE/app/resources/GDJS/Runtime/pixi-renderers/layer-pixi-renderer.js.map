{
  "version": 3,
  "sources": ["../../../../../../GDJS/Runtime/pixi-renderers/layer-pixi-renderer.ts"],
  "sourcesContent": ["/*\n * GDevelop JS Platform\n * Copyright 2013-2016 Florian Rival (Florian.Rival@gmail.com). All rights reserved.\n * This project is released under the MIT License.\n */\n\nnamespace gdjs {\n  import PIXI = GlobalPIXIModule.PIXI;\n\n  const logger = new gdjs.Logger('LayerPixiRenderer');\n\n  /**\n   * The renderer for a gdjs.Layer using Pixi.js.\n   */\n  export class LayerPixiRenderer {\n    private _pixiContainer: PIXI.Container;\n\n    private _layer: gdjs.RuntimeLayer;\n\n    /** For a lighting layer, the sprite used to display the render texture. */\n    private _lightingSprite: PIXI.Sprite | null = null;\n    private _isLightingLayer: boolean;\n    private _clearColor: Array<integer>;\n\n    /**\n     * The render texture where the whole 2D layer is rendered.\n     * The render texture is then used for lighting (if it's a light layer)\n     * or to be rendered in a 3D scene (for a 2D+3D layer).\n     */\n    private _renderTexture: PIXI.RenderTexture | null = null;\n\n    // Width and height are tracked when a render texture is used.\n    private _oldWidth: float | null = null;\n    private _oldHeight: float | null = null;\n\n    // For a 3D (or 2D+3D) layer:\n    private _threeGroup: THREE.Group | null = null;\n    private _threeScene: THREE.Scene | null = null;\n    private _threeCamera: THREE.PerspectiveCamera | null = null;\n    private _threeCameraDirty: boolean = false;\n\n    // For a 2D+3D layer, the 2D rendering is done on the render texture\n    // and then must be displayed on a plane in the 3D world:\n    private _threePlaneTexture: THREE.Texture | null = null;\n    private _threePlaneGeometry: THREE.PlaneGeometry | null = null;\n    private _threePlaneMaterial: THREE.ShaderMaterial | null = null;\n    private _threePlaneMesh: THREE.Mesh | null = null;\n\n    /**\n     * Pixi doesn't sort children with zIndex == 0.\n     */\n    private static readonly zeroZOrderForPixi = Math.pow(2, -24);\n\n    private static vectorForProjections: THREE.Vector3 | null = null;\n\n    /**\n     * @param layer The layer\n     * @param runtimeInstanceContainerRenderer The scene renderer\n     */\n    constructor(\n      layer: gdjs.RuntimeLayer,\n      runtimeInstanceContainerRenderer: gdjs.RuntimeInstanceContainerRenderer,\n      runtimeGameRenderer: gdjs.RuntimeGameRenderer\n    ) {\n      this._pixiContainer = new PIXI.Container();\n      this._pixiContainer.sortableChildren = true;\n      this._layer = layer;\n      this._isLightingLayer = layer.isLightingLayer();\n      runtimeInstanceContainerRenderer\n        .getRendererObject()\n        .addChild(this._pixiContainer);\n      this._pixiContainer.filters = [];\n\n      // Setup rendering for lighting or 3D rendering:\n      const pixiRenderer = runtimeGameRenderer.getPIXIRenderer();\n      if (this._isLightingLayer) {\n        this._clearColor = layer.getClearColor();\n        this._setupLightingRendering(\n          pixiRenderer,\n          runtimeInstanceContainerRenderer\n        );\n      } else {\n        // Clear color is used as background color of transparent sprites.\n        this._clearColor = [\n          ...gdjs.hexNumberToRGBArray(\n            this._layer.getRuntimeScene().getBackgroundColor()\n          ),\n          0,\n        ];\n        this._setup3DRendering(pixiRenderer, runtimeInstanceContainerRenderer);\n      }\n    }\n\n    onCreated() {\n      // The layer is now fully initialized. Adapt the 3D camera position\n      // (which we could not do before in `_setup3DRendering`).\n      this._update3DCameraAspectAndPosition();\n    }\n\n    onGameResolutionResized() {\n      // Ensure the 3D camera aspect is updated:\n      this._update3DCameraAspectAndPosition();\n    }\n\n    private _update3DCameraAspectAndPosition() {\n      if (this._threeCamera) {\n        this._threeCamera.aspect =\n          this._layer.getWidth() / this._layer.getHeight();\n        this._threeCamera.updateProjectionMatrix();\n\n        this.updatePosition();\n      }\n    }\n\n    getRendererObject(): PIXI.Container {\n      return this._pixiContainer;\n    }\n\n    getThreeScene(): THREE.Scene | null {\n      return this._threeScene;\n    }\n\n    getThreeCamera(): THREE.PerspectiveCamera | null {\n      return this._threeCamera;\n    }\n\n    /**\n     * The sprite, displaying the \"render texture\" of the layer, to display\n     * for a lighting layer.\n     */\n    getLightingSprite(): PIXI.Sprite | null {\n      return this._lightingSprite;\n    }\n\n    /**\n     * Create, or re-create, Three.js objects for 3D rendering of this layer.\n     */\n    private _setup3DRendering(\n      pixiRenderer: PIXI.Renderer | null,\n      runtimeInstanceContainerRenderer: gdjs.RuntimeInstanceContainerRenderer\n    ): void {\n      if (typeof THREE === 'undefined') {\n        return;\n      }\n      // TODO (3D): ideally we would avoid the need for this check at all,\n      // maybe by having separate rendering classes for custom object layers and scene layers.\n      if (this._layer instanceof gdjs.Layer) {\n        if (\n          this._layer.getRenderingType() ===\n            gdjs.RuntimeLayerRenderingType.THREE_D ||\n          this._layer.getRenderingType() ===\n            gdjs.RuntimeLayerRenderingType.TWO_D_PLUS_THREE_D\n        ) {\n          if (this._threeScene || this._threeGroup || this._threeCamera) {\n            throw new Error(\n              'Tried to setup 3D rendering for a layer that is already set up.'\n            );\n          }\n\n          this._threeScene = new THREE.Scene();\n\n          // Use a mirroring on the Y axis to follow the same axis as in the 2D, PixiJS, rendering.\n          // We use a mirroring rather than a camera rotation so that the Z order is not changed.\n          this._threeScene.scale.y = -1;\n\n          this._threeGroup = new THREE.Group();\n          this._threeScene.add(this._threeGroup);\n\n          this._threeCamera = new THREE.PerspectiveCamera(\n            this._layer.getInitialCamera3DFieldOfView(),\n            1,\n            this._layer.getInitialCamera3DNearPlaneDistance(),\n            this._layer.getInitialCamera3DFarPlaneDistance()\n          );\n          this._threeCamera.rotation.order = 'ZYX';\n\n          if (\n            this._layer.getRenderingType() ===\n            gdjs.RuntimeLayerRenderingType.TWO_D_PLUS_THREE_D\n          ) {\n            if (\n              this._renderTexture ||\n              this._threePlaneGeometry ||\n              this._threePlaneMaterial ||\n              this._threePlaneTexture ||\n              this._threePlaneMesh\n            )\n              throw new Error(\n                'Tried to setup PixiJS plane for 2D rendering in 3D for a layer that is already set up.'\n              );\n\n            // If we have both 2D and 3D objects to be rendered, create a render texture that PixiJS will use\n            // to render, and that will be projected on a plane by Three.js\n            this._createPixiRenderTexture(pixiRenderer);\n\n            // Create the plane that will show this texture.\n            this._threePlaneGeometry = new THREE.PlaneGeometry(1, 1);\n\n            // Create the texture to project on the plane.\n            // Use a buffer to create a \"fake\" DataTexture, just so the texture\n            // is considered initialized by Three.js.\n            const width = 1;\n            const height = 1;\n            const size = width * height;\n            const data = new Uint8Array(4 * size);\n            const texture = new THREE.DataTexture(data, width, height);\n            texture.needsUpdate = true;\n\n            this._threePlaneTexture = texture;\n            this._threePlaneTexture.generateMipmaps = false;\n            const filter =\n              this._layer.getRuntimeScene().getGame().getScaleMode() ===\n              'nearest'\n                ? THREE.NearestFilter\n                : THREE.LinearFilter;\n            this._threePlaneTexture.minFilter = filter;\n            this._threePlaneTexture.magFilter = filter;\n            this._threePlaneTexture.wrapS = THREE.ClampToEdgeWrapping;\n            this._threePlaneTexture.wrapT = THREE.ClampToEdgeWrapping;\n            // This disable the gamma correction done by THREE as PIXI is already doing it.\n            const noGammaCorrectionShader: THREE.ShaderMaterialParameters = {\n              vertexShader: `\n                varying vec2 vUv;\n                void main() {\n                  vUv = uv;\n                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n              `,\n              fragmentShader: `\n                uniform sampler2D map;\n                varying vec2 vUv;\n                void main() {\n                  vec4 texel = texture2D(map, vUv);\n                  gl_FragColor = texel;\n                }\n              `,\n              uniforms: {\n                map: { value: this._threePlaneTexture },\n              },\n              side: THREE.FrontSide,\n              transparent: true,\n            };\n            this._threePlaneMaterial = new THREE.ShaderMaterial(\n              noGammaCorrectionShader\n            );\n            this._threePlaneMaterial;\n\n            // Finally, create the mesh shown in the scene.\n            this._threePlaneMesh = new THREE.Mesh(\n              this._threePlaneGeometry,\n              this._threePlaneMaterial\n            );\n\n            // Force to render the mesh last (after the rest of 3D objects, including\n            // transparent ones). In most cases, the 2D rendering is composed of a lot\n            // of transparent areas, and we can't risk it being displayed first and wrongly\n            // occluding 3D objects shown behind.\n            this._threePlaneMesh.renderOrder = Number.MAX_SAFE_INTEGER;\n            this._threeScene.add(this._threePlaneMesh);\n          }\n\n          // Note: we can not update the position of the camera at this point,\n          // because the layer might not be fully constructed.\n          // See `onCreated`.\n        }\n      } else {\n        // This is a layer of a custom object.\n\n        const parentThreeObject = runtimeInstanceContainerRenderer.get3DRendererObject();\n        if (!parentThreeObject) {\n          // No parent 3D renderer object, 3D is disabled.\n          return;\n        }\n\n        if (!this._threeGroup) {\n          // TODO (3D) - optimization: do not create a THREE.Group if no 3D object are contained inside.\n          this._threeGroup = new THREE.Group();\n          parentThreeObject.add(this._threeGroup);\n        }\n      }\n    }\n\n    setThreeCameraDirty(enable: boolean) {\n      this._threeCameraDirty = enable;\n    }\n\n    show2DRenderingPlane(enable: boolean) {\n      if (!this._threePlaneMesh) return;\n      if (this._threePlaneMesh.visible === enable) return;\n      this._threePlaneMesh.visible = enable;\n    }\n\n    /**\n     * Update the position of the PIXI container. To be called after each change\n     * made to position, zoom or rotation of the camera.\n     */\n    updatePosition(): void {\n      const angle = -gdjs.toRad(this._layer.getCameraRotation());\n      const zoomFactor = this._layer.getCameraZoom();\n      this._pixiContainer.rotation = angle;\n      this._pixiContainer.scale.x = zoomFactor;\n      this._pixiContainer.scale.y = zoomFactor;\n      const cosValue = Math.cos(angle);\n      const sinValue = Math.sin(angle);\n      const centerX =\n        this._layer.getCameraX() * zoomFactor * cosValue -\n        this._layer.getCameraY() * zoomFactor * sinValue;\n      const centerY =\n        this._layer.getCameraX() * zoomFactor * sinValue +\n        this._layer.getCameraY() * zoomFactor * cosValue;\n      this._pixiContainer.position.x = this._layer.getWidth() / 2 - centerX;\n      this._pixiContainer.position.y = this._layer.getHeight() / 2 - centerY;\n\n      if (\n        this._layer.getRuntimeScene().getGame().getPixelsRounding() &&\n        (cosValue === 0 || sinValue === 0) &&\n        Number.isInteger(zoomFactor)\n      ) {\n        // Camera rounding is important for pixel perfect games.\n        // Otherwise, the camera position fractional part is added to\n        // the sprite one and it changes in which direction sprites are rounded.\n        // It makes sprites rounding inconsistent with each other\n        // and they seem to move on pixel left and right.\n        //\n        // PIXI uses a floor function on sprites position on the screen,\n        // so a floor must be applied on the camera position too.\n        // According to the above calculus,\n        // _pixiContainer.position is the opposite of the camera,\n        // this is why the ceil function is used floor(x) = -ceil(-x).\n        //\n        // When the camera directly follows an object,\n        // given this object dimension is even,\n        // the decimal part of onScenePosition and cameraPosition are the same.\n        //\n        // Doing the calculus without rounding:\n        // onScreenPosition = onScenePosition - cameraPosition\n        // onScreenPosition = 980.75 - 200.75\n        // onScreenPosition = 780\n        //\n        // Doing the calculus with rounding:\n        // onScreenPosition = floor(onScenePosition + ceil(-cameraPosition))\n        // onScreenPosition = floor(980.75 + ceil(-200.75))\n        // onScreenPosition = floor(980.75 - 200)\n        // onScreenPosition = floor(780.75)\n        // onScreenPosition = 780\n        this._pixiContainer.position.x = Math.ceil(\n          this._pixiContainer.position.x\n        );\n        this._pixiContainer.position.y = Math.ceil(\n          this._pixiContainer.position.y\n        );\n      }\n\n      if (this._threeCamera) {\n        // TODO (3D) - improvement: handle camera rounding like down for PixiJS?\n        this._threeCamera.position.x = this._layer.getCameraX();\n        this._threeCamera.position.y = -this._layer.getCameraY(); // Inverted because the scene is mirrored on Y axis.\n        this._threeCamera.rotation.z = angle;\n\n        this._threeCamera.position.z = this._layer.getCameraZ(\n          this._threeCamera.fov\n        );\n\n        if (this._threePlaneMesh) {\n          // Adapt the plane size so that it covers the whole screen.\n          this._threePlaneMesh.scale.x = this._layer.getWidth() / zoomFactor;\n          this._threePlaneMesh.scale.y = this._layer.getHeight() / zoomFactor;\n\n          // Adapt the plane position so that it's always displayed on the whole screen.\n          this._threePlaneMesh.position.x = this._threeCamera.position.x;\n          this._threePlaneMesh.position.y = -this._threeCamera.position.y; // Inverted because the scene is mirrored on Y axis.\n          this._threePlaneMesh.rotation.z = -angle;\n        }\n      }\n    }\n\n    isCameraRotatedIn3D() {\n      return (\n        this._threeCamera &&\n        (this._threeCamera.rotation.x !== 0 ||\n          this._threeCamera.rotation.y !== 0)\n      );\n    }\n\n    transformTo3DWorld(\n      screenX: float,\n      screenY: float,\n      worldZ: float,\n      cameraId: integer,\n      result: FloatPoint\n    ): FloatPoint {\n      const camera = this._threeCamera;\n      if (!camera) {\n        result[0] = 0;\n        result[1] = 0;\n        return result;\n      }\n      const width = this._layer.getWidth();\n      const height = this._layer.getHeight();\n\n      let vector = LayerPixiRenderer.vectorForProjections;\n      if (!vector) {\n        vector = new THREE.Vector3();\n        LayerPixiRenderer.vectorForProjections = vector;\n      }\n\n      // https://stackoverflow.com/questions/13055214/mouse-canvas-x-y-to-three-js-world-x-y-z\n      vector.set((screenX / width) * 2 - 1, -(screenY / height) * 2 + 1, 0.5);\n      vector.unproject(camera);\n      vector.sub(camera.position).normalize();\n      const distance = (worldZ - camera.position.z) / vector.z;\n      vector.multiplyScalar(distance);\n\n      // The plane z == worldZ may not be visible on the camera.\n      if (!Number.isFinite(vector.x) || !Number.isFinite(vector.y)) {\n        result[0] = 0;\n        result[1] = 0;\n        return result;\n      }\n\n      result[0] = camera.position.x + vector.x;\n      result[1] = -(camera.position.y + vector.y);\n      return result;\n    }\n\n    updateVisibility(visible: boolean): void {\n      this._pixiContainer.visible = !!visible;\n      if (this._threeGroup) this._threeGroup.visible = !!visible;\n    }\n\n    updatePreRender(): void {\n      if (this._threeCameraDirty) {\n        const camera = this.getThreeCamera();\n        if (camera) {\n          camera.updateProjectionMatrix();\n        }\n        this._threeCameraDirty = false;\n      }\n    }\n\n    /**\n     * Add a child to the pixi container associated to the layer.\n     * All objects which are on this layer must be children of this container.\n     *\n     * @param pixiChild The child (PIXI object) to be added.\n     * @param zOrder The z order of the associated object.\n     */\n    addRendererObject(pixiChild, zOrder: float): void {\n      const child = pixiChild as PIXI.DisplayObject;\n      child.zIndex = zOrder || LayerPixiRenderer.zeroZOrderForPixi;\n      this._pixiContainer.addChild(child);\n    }\n\n    /**\n     * Change the z order of a child associated to an object.\n     *\n     * @param pixiChild The child (PIXI object) to be modified.\n     * @param newZOrder The z order of the associated object.\n     */\n    changeRendererObjectZOrder(pixiChild, newZOrder: float): void {\n      const child = pixiChild as PIXI.DisplayObject;\n      child.zIndex = newZOrder;\n    }\n\n    /**\n     * Remove a child from the internal pixi container.\n     * Should be called when an object is deleted or removed from the layer.\n     *\n     * @param child The child (PIXI object) to be removed.\n     */\n    removeRendererObject(child): void {\n      this._pixiContainer.removeChild(child);\n    }\n\n    has3DObjects(): boolean {\n      return !!this._threeGroup && this._threeGroup.children.length > 0;\n    }\n\n    has2DObjects(): boolean {\n      return this._pixiContainer.children.length > 0;\n    }\n\n    add3DRendererObject(object: THREE.Object3D): void {\n      if (!this._threeGroup) return;\n\n      this._threeGroup.add(object);\n    }\n\n    remove3DRendererObject(object: THREE.Object3D): void {\n      if (!this._threeGroup) return;\n\n      this._threeGroup.remove(object);\n    }\n\n    updateClearColor(): void {\n      this._clearColor = this._layer.getClearColor();\n      // this._createPixiRenderTexture(); // TODO: Check this was useless\n    }\n\n    /**\n     * Create the PixiJS RenderTexture used to display the whole layer.\n     * Can be used either for lighting or for rendering the layer in a texture\n     * so it can then be consumed by Three.js to render it in 3D.\n     */\n    private _createPixiRenderTexture(pixiRenderer: PIXI.Renderer | null): void {\n      if (!pixiRenderer || pixiRenderer.type !== PIXI.RENDERER_TYPE.WEBGL) {\n        return;\n      }\n      if (this._renderTexture) {\n        logger.error(\n          'Tried to create a PixiJS RenderTexture for a layer that already has one.'\n        );\n        return;\n      }\n\n      this._oldWidth = pixiRenderer.screen.width;\n      this._oldHeight = pixiRenderer.screen.height;\n      const width = this._oldWidth;\n      const height = this._oldHeight;\n      const resolution = pixiRenderer.resolution;\n      this._renderTexture = PIXI.RenderTexture.create({\n        width,\n        height,\n        resolution,\n      });\n      this._renderTexture.baseTexture.scaleMode = PIXI.SCALE_MODES.LINEAR;\n      logger.info(`RenderTexture created for layer ${this._layer.getName()}.`);\n    }\n\n    /**\n     * Render the layer of the PixiJS RenderTexture, so that it can be then displayed\n     * with a blend mode (for a lighting layer) or consumed by Three.js (for 2D+3D layers).\n     */\n    renderOnPixiRenderTexture(pixiRenderer: PIXI.Renderer) {\n      if (!this._renderTexture) {\n        return;\n      }\n      if (\n        this._oldWidth !== pixiRenderer.screen.width ||\n        this._oldHeight !== pixiRenderer.screen.height\n      ) {\n        this._renderTexture.resize(\n          pixiRenderer.screen.width,\n          pixiRenderer.screen.height\n        );\n        this._oldWidth = pixiRenderer.screen.width;\n        this._oldHeight = pixiRenderer.screen.height;\n      }\n      const oldRenderTexture = pixiRenderer.renderTexture.current;\n      const oldSourceFrame = pixiRenderer.renderTexture.sourceFrame;\n      pixiRenderer.renderTexture.bind(this._renderTexture);\n\n      // The background is the ambient color for lighting layers\n      // and transparent for 2D+3D layers.\n      this._clearColor[3] = this._isLightingLayer ? 1 : 0;\n      pixiRenderer.renderTexture.clear(this._clearColor);\n\n      pixiRenderer.render(this._pixiContainer, {\n        renderTexture: this._renderTexture,\n        clear: false,\n      });\n      pixiRenderer.renderTexture.bind(\n        oldRenderTexture,\n        oldSourceFrame,\n        undefined\n      );\n    }\n\n    /**\n     * Set the texture of the 2D plane in the 3D world to be the same WebGL texture\n     * as the PixiJS RenderTexture - so that the 2D rendering can be shown in the 3D world.\n     */\n    updateThreePlaneTextureFromPixiRenderTexture(\n      threeRenderer: THREE.WebGLRenderer,\n      pixiRenderer: PIXI.Renderer\n    ): void {\n      if (!this._threePlaneTexture || !this._renderTexture) {\n        return;\n      }\n\n      const glTexture = this._renderTexture.baseTexture._glTextures[\n        pixiRenderer.CONTEXT_UID\n      ];\n      if (glTexture) {\n        // \"Hack\" into the Three.js renderer by getting the internal WebGL texture for the PixiJS plane,\n        // and set it so that it's the same as the WebGL texture for the PixiJS RenderTexture.\n        // This works because PixiJS and Three.js are using the same WebGL context.\n        const texture = threeRenderer.properties.get(this._threePlaneTexture);\n        texture.__webglTexture = glTexture.texture;\n      }\n    }\n\n    /**\n     * Enable the use of a PIXI.RenderTexture to render the PIXI.Container\n     * of the layer and, in the scene PIXI container, replace the container\n     * of the layer by a sprite showing this texture.\n     * used only in lighting for now as the sprite could have MULTIPLY blend mode.\n     */\n    private _setupLightingRendering(\n      pixiRenderer: PIXI.Renderer | null,\n      runtimeInstanceContainerRenderer: gdjs.RuntimeInstanceContainerRenderer\n    ): void {\n      this._createPixiRenderTexture(pixiRenderer);\n      if (!this._renderTexture) {\n        return;\n      }\n\n      this._lightingSprite = new PIXI.Sprite(this._renderTexture);\n      this._lightingSprite.blendMode = PIXI.BLEND_MODES.MULTIPLY;\n      const parentPixiContainer = runtimeInstanceContainerRenderer.getRendererObject();\n      const index = parentPixiContainer.getChildIndex(this._pixiContainer);\n      parentPixiContainer.addChildAt(this._lightingSprite, index);\n      parentPixiContainer.removeChild(this._pixiContainer);\n    }\n  }\n\n  //Register the class to let the engine use it.\n  export type LayerRenderer = gdjs.LayerPixiRenderer;\n  export const LayerRenderer = gdjs.LayerPixiRenderer;\n}\n"],
  "mappings": "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",
  "names": []
}
