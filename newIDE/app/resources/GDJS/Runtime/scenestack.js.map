{
  "version": 3,
  "sources": ["../../../../../GDJS/Runtime/scenestack.ts"],
  "sourcesContent": ["namespace gdjs {\n  const logger = new gdjs.Logger('Scene stack');\n\n  /**\n   * Hold the stack of scenes ({@link gdjs.RuntimeScene}) being played.\n   */\n  export class SceneStack {\n    _runtimeGame: gdjs.RuntimeGame;\n    _stack: gdjs.RuntimeScene[] = [];\n    _wasFirstSceneLoaded: boolean = false;\n\n    /**\n     * @param runtimeGame The runtime game that is using the scene stack\n     */\n    constructor(runtimeGame: gdjs.RuntimeGame) {\n      if (!runtimeGame) {\n        throw 'SceneStack must be constructed with a gdjs.RuntimeGame.';\n      }\n      this._runtimeGame = runtimeGame;\n    }\n\n    /**\n     * Called by the RuntimeGame when the game resolution is changed.\n     * Useful to notify scene and layers that resolution is changed, as they\n     * might be caching it.\n     */\n    onGameResolutionResized(): void {\n      for (let i = 0; i < this._stack.length; ++i) {\n        this._stack[i].onGameResolutionResized();\n      }\n    }\n\n    step(elapsedTime: float): boolean {\n      if (this._stack.length === 0) {\n        return false;\n      }\n      const currentScene = this._stack[this._stack.length - 1];\n      if (currentScene.renderAndStep(elapsedTime)) {\n        const request = currentScene.getRequestedChange();\n\n        //Something special was requested by the current scene.\n        if (request === gdjs.SceneChangeRequest.STOP_GAME) {\n          this._runtimeGame.getRenderer().stopGame();\n          return true;\n        } else if (request === gdjs.SceneChangeRequest.POP_SCENE) {\n          this.pop();\n        } else if (request === gdjs.SceneChangeRequest.PUSH_SCENE) {\n          this.push(currentScene.getRequestedScene());\n        } else if (request === gdjs.SceneChangeRequest.REPLACE_SCENE) {\n          this.replace(currentScene.getRequestedScene());\n        } else if (request === gdjs.SceneChangeRequest.CLEAR_SCENES) {\n          this.replace(currentScene.getRequestedScene(), true);\n        } else {\n          logger.error('Unrecognized change in scene stack: ' + request);\n          return false;\n        }\n      }\n      return true;\n    }\n\n    renderWithoutStep(): boolean {\n      if (this._stack.length === 0) {\n        return false;\n      }\n      const currentScene = this._stack[this._stack.length - 1];\n      currentScene.render();\n      return true;\n    }\n\n    pop(): gdjs.RuntimeScene | null {\n      if (this._stack.length <= 1) {\n        return null;\n      }\n\n      // Unload the current scene\n      const scene = this._stack.pop();\n      if (!scene) {\n        return null;\n      }\n      scene.unloadScene();\n\n      // Tell the new current scene it's being resumed\n      const currentScene = this._stack[this._stack.length - 1];\n      if (currentScene) {\n        currentScene.onResume();\n      }\n      return scene;\n    }\n\n    /**\n     * Pause the scene currently being played and start the new scene that is specified.\n     * If `externalLayoutName` is set, also instantiate the objects from this external layout.\n     */\n    push(newSceneName: string, externalLayoutName?: string): gdjs.RuntimeScene {\n      // Tell the scene it's being paused\n      const currentScene = this._stack[this._stack.length - 1];\n      if (currentScene) {\n        currentScene.onPause();\n      }\n\n      // Load the new one\n      const newScene = new gdjs.RuntimeScene(this._runtimeGame);\n      newScene.loadFromScene(this._runtimeGame.getSceneData(newSceneName));\n      this._wasFirstSceneLoaded = true;\n\n      // Optionally create the objects from an external layout.\n      if (externalLayoutName) {\n        const externalLayoutData = this._runtimeGame.getExternalLayoutData(\n          externalLayoutName\n        );\n        if (externalLayoutData) {\n          newScene.createObjectsFrom(\n            externalLayoutData.instances,\n            0,\n            0,\n            /*trackByPersistentUuid=*/\n            true\n          );\n        }\n      }\n      this._stack.push(newScene);\n      return newScene;\n    }\n\n    /**\n     * Start the specified scene, replacing the one currently being played.\n     * If `clear` is set to true, all running scenes are also removed from the stack of scenes.\n     */\n    replace(newSceneName: string, clear?: boolean): gdjs.RuntimeScene {\n      if (!!clear) {\n        // Unload all the scenes\n        while (this._stack.length !== 0) {\n          let scene = this._stack.pop();\n          if (scene) {\n            scene.unloadScene();\n          }\n        }\n      } else {\n        // Unload the current scene\n        if (this._stack.length !== 0) {\n          let scene = this._stack.pop();\n          if (scene) {\n            scene.unloadScene();\n          }\n        }\n      }\n      return this.push(newSceneName);\n    }\n\n    /**\n     * Return the current gdjs.RuntimeScene being played, or null if none is run.\n     */\n    getCurrentScene(): gdjs.RuntimeScene | null {\n      if (this._stack.length === 0) {\n        return null;\n      }\n      return this._stack[this._stack.length - 1];\n    }\n\n    /**\n     * Return true if a scene was loaded, false otherwise (i.e: game not yet started).\n     */\n    wasFirstSceneLoaded(): boolean {\n      return this._wasFirstSceneLoaded;\n    }\n  }\n}\n"],
  "mappings": "AAAA,GAAU,MAAV,UAAU,EAAV,CACE,KAAM,GAAS,GAAI,GAAK,OAAO,eAKxB,OAAiB,CAQtB,YAAY,EAA+B,CAN3C,YAA8B,GAC9B,0BAAgC,GAM9B,GAAI,CAAC,EACH,KAAM,0DAER,KAAK,aAAe,EAQtB,yBAAgC,CAC9B,OAAS,GAAI,EAAG,EAAI,KAAK,OAAO,OAAQ,EAAE,EACxC,KAAK,OAAO,GAAG,0BAInB,KAAK,EAA6B,CAChC,GAAI,KAAK,OAAO,SAAW,EACzB,MAAO,GAET,KAAM,GAAe,KAAK,OAAO,KAAK,OAAO,OAAS,GACtD,GAAI,EAAa,cAAc,GAAc,CAC3C,KAAM,GAAU,EAAa,qBAG7B,GAAI,IAAY,EAAK,mBAAmB,UACtC,YAAK,aAAa,cAAc,WACzB,GACF,GAAI,IAAY,EAAK,mBAAmB,UAC7C,KAAK,cACI,IAAY,EAAK,mBAAmB,WAC7C,KAAK,KAAK,EAAa,6BACd,IAAY,EAAK,mBAAmB,cAC7C,KAAK,QAAQ,EAAa,6BACjB,IAAY,EAAK,mBAAmB,aAC7C,KAAK,QAAQ,EAAa,oBAAqB,QAE/C,UAAO,MAAM,uCAAyC,GAC/C,GAGX,MAAO,GAGT,mBAA6B,CAC3B,MAAI,MAAK,OAAO,SAAW,EAClB,GAGT,CADqB,KAAK,OAAO,KAAK,OAAO,OAAS,GACzC,SACN,IAGT,KAAgC,CAC9B,GAAI,KAAK,OAAO,QAAU,EACxB,MAAO,MAIT,KAAM,GAAQ,KAAK,OAAO,MAC1B,GAAI,CAAC,EACH,MAAO,MAET,EAAM,cAGN,KAAM,GAAe,KAAK,OAAO,KAAK,OAAO,OAAS,GACtD,MAAI,IACF,EAAa,WAER,EAOT,KAAK,EAAsB,EAAgD,CAEzE,KAAM,GAAe,KAAK,OAAO,KAAK,OAAO,OAAS,GACtD,AAAI,GACF,EAAa,UAIf,KAAM,GAAW,GAAI,GAAK,aAAa,KAAK,cAK5C,GAJA,EAAS,cAAc,KAAK,aAAa,aAAa,IACtD,KAAK,qBAAuB,GAGxB,EAAoB,CACtB,KAAM,GAAqB,KAAK,aAAa,sBAC3C,GAEF,AAAI,GACF,EAAS,kBACP,EAAmB,UACnB,EACA,EAEA,IAIN,YAAK,OAAO,KAAK,GACV,EAOT,QAAQ,EAAsB,EAAoC,CAChE,GAAM,EAEJ,KAAO,KAAK,OAAO,SAAW,GAAG,CAC/B,GAAI,GAAQ,KAAK,OAAO,MACxB,AAAI,GACF,EAAM,sBAKN,KAAK,OAAO,SAAW,EAAG,CAC5B,GAAI,GAAQ,KAAK,OAAO,MACxB,AAAI,GACF,EAAM,cAIZ,MAAO,MAAK,KAAK,GAMnB,iBAA4C,CAC1C,MAAI,MAAK,OAAO,SAAW,EAClB,KAEF,KAAK,OAAO,KAAK,OAAO,OAAS,GAM1C,qBAA+B,CAC7B,MAAO,MAAK,sBA7JT,EAAM,eANL",
  "names": []
}
