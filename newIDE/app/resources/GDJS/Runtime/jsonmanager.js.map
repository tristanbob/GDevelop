{
  "version": 3,
  "sources": ["../../../../../GDJS/Runtime/jsonmanager.ts"],
  "sourcesContent": ["/*\n * GDevelop JS Platform\n * Copyright 2013-present Florian Rival (Florian.Rival@gmail.com). All rights reserved.\n * This project is released under the MIT License.\n */\nnamespace gdjs {\n  const logger = new gdjs.Logger('JSON Manager');\n  type JsonManagerOnProgressCallback = (\n    loadedCount: integer,\n    totalCount: integer\n  ) => void;\n  type JsonManagerOnCompleteCallback = (totalCount: integer) => void;\n\n  /** The callback called when a json that was requested is loaded (or an error occurred). */\n  export type JsonManagerRequestCallback = (\n    error: Error | null,\n    content: Object | null\n  ) => void;\n\n  /**\n   * JsonManager loads json files (using `XMLHttpRequest`), using the \"json\" resources\n   * registered in the game resources.\n   *\n   * Contrary to audio/fonts, json files are loaded asynchronously, when requested.\n   * You should properly handle errors, and give the developer/player a way to know\n   * that loading failed.\n   */\n  export class JsonManager {\n    _resourcesLoader: RuntimeGameResourcesLoader;\n    _resources: ResourceData[];\n\n    _loadedJsons: { [key: string]: Object } = {};\n    _callbacks: { [key: string]: Array<JsonManagerRequestCallback> } = {};\n\n    /**\n     * @param resources The resources data of the game.\n     * @param resourcesLoader The resources loader of the game.\n     */\n    constructor(\n      resources: ResourceData[],\n      resourcesLoader: RuntimeGameResourcesLoader\n    ) {\n      this._resources = resources;\n      this._resourcesLoader = resourcesLoader;\n    }\n\n    /**\n     * Update the resources data of the game. Useful for hot-reloading, should not be used otherwise.\n     *\n     * @param resources The resources data of the game.\n     */\n    setResources(resources: ResourceData[]): void {\n      this._resources = resources;\n    }\n\n    /**\n     * Request all the json resources to be preloaded (unless they are marked as not preloaded).\n     *\n     * Note that even if a JSON is already loaded, it will be reloaded (useful for hot-reloading,\n     * as JSON files can have been modified without the editor knowing).\n     *\n     * @param onProgress The function called after each json is loaded.\n     * @param onComplete The function called when all jsons are loaded.\n     */\n    preloadJsons(\n      onProgress: JsonManagerOnProgressCallback,\n      onComplete: JsonManagerOnCompleteCallback\n    ): void {\n      const resources = this._resources;\n      const jsonResources = resources.filter(function (resource) {\n        return (\n          (resource.kind === 'json' ||\n            resource.kind === 'tilemap' ||\n            resource.kind === 'tileset') &&\n          !resource.disablePreload\n        );\n      });\n      if (jsonResources.length === 0) {\n        return onComplete(jsonResources.length);\n      }\n      let loaded = 0;\n\n      const onLoad: JsonManagerRequestCallback = function (error) {\n        if (error) {\n          logger.error('Error while preloading a json resource:' + error);\n        }\n        loaded++;\n        if (loaded === jsonResources.length) {\n          onComplete(jsonResources.length);\n        } else {\n          onProgress(loaded, jsonResources.length);\n        }\n      };\n      for (let i = 0; i < jsonResources.length; ++i) {\n        this.loadJson(jsonResources[i].name, onLoad);\n      }\n    }\n\n    /**\n     * Request the json file from the given resource name.\n     * This method is asynchronous. When loaded, the `callback` is called with the error\n     * (null if none) and the loaded json (a JS Object).\n     *\n     * @param resourceName The resource pointing to the json file to load.\n     * @param callback The callback function called when json is loaded (or an error occurred).\n     */\n    loadJson(resourceName: string, callback: JsonManagerRequestCallback): void {\n      const resource = this._resources.find(function (resource) {\n        return (\n          (resource.kind === 'json' ||\n            resource.kind === 'tilemap' ||\n            resource.kind === 'tileset') &&\n          resource.name === resourceName\n        );\n      });\n      if (!resource) {\n        callback(\n          new Error(\n            'Can\\'t find resource with name: \"' +\n              resourceName +\n              '\" (or is not a json resource).'\n          ),\n          null\n        );\n        return;\n      }\n\n      // Don't fetch again an object that is already in memory\n      if (this._loadedJsons[resourceName]) {\n        callback(null, this._loadedJsons[resourceName]);\n        return;\n      }\n      // Don't fetch again an object that is already being fetched.\n      {\n        const callbacks = this._callbacks[resourceName];\n        if (callbacks) {\n          callbacks.push(callback);\n          return;\n        } else {\n          this._callbacks[resourceName] = [callback];\n        }\n      }\n      const that = this;\n      const xhr = new XMLHttpRequest();\n      xhr.responseType = 'json';\n      xhr.withCredentials = this._resourcesLoader.checkIfCredentialsRequired(\n        resource.file\n      );\n      xhr.open('GET', this._resourcesLoader.getFullUrl(resource.file));\n      xhr.onload = function () {\n        const callbacks = that._callbacks[resourceName];\n        if (!callbacks) {\n          return;\n        }\n        if (xhr.status !== 200) {\n          for (const callback of callbacks) {\n            callback(\n              new Error(\n                'HTTP error: ' + xhr.status + '(' + xhr.statusText + ')'\n              ),\n              null\n            );\n          }\n          delete that._callbacks[resourceName];\n          return;\n        }\n\n        // Cache the result\n        that._loadedJsons[resourceName] = xhr.response;\n        for (const callback of callbacks) {\n          callback(null, xhr.response);\n        }\n        delete that._callbacks[resourceName];\n      };\n      xhr.onerror = function () {\n        const callbacks = that._callbacks[resourceName];\n        if (!callbacks) {\n          return;\n        }\n        for (const callback of callbacks) {\n          callback(new Error('Network error'), null);\n        }\n        delete that._callbacks[resourceName];\n      };\n      xhr.onabort = function () {\n        const callbacks = that._callbacks[resourceName];\n        if (!callbacks) {\n          return;\n        }\n        for (const callback of callbacks) {\n          callback(new Error('Request aborted'), null);\n        }\n        delete that._callbacks[resourceName];\n      };\n      xhr.send();\n    }\n\n    /**\n     * Check if the given json resource was loaded (preloaded or loaded with `loadJson`).\n     * @param resourceName The name of the json resource.\n     * @returns true if the content of the json resource is loaded. false otherwise.\n     */\n    isJsonLoaded(resourceName: string): boolean {\n      return !!this._loadedJsons[resourceName];\n    }\n\n    /**\n     * Get the object for the given resource that is already loaded (preloaded or loaded with `loadJson`).\n     * If the resource is not loaded, `null` will be returned.\n     *\n     * @param resourceName The name of the json resource.\n     * @returns the content of the json resource, if loaded. `null` otherwise.\n     */\n    getLoadedJson(resourceName: string): Object | null {\n      return this._loadedJsons[resourceName] || null;\n    }\n  }\n}\n"],
  "mappings": "AAKA,GAAU,MAAV,UAAU,EAAV,CACE,KAAM,GAAS,GAAI,GAAK,OAAO,gBAqBxB,OAAkB,CAWvB,YACE,EACA,EACA,CAVF,kBAA0C,GAC1C,gBAAmE,GAUjE,KAAK,WAAa,EAClB,KAAK,iBAAmB,EAQ1B,aAAa,EAAiC,CAC5C,KAAK,WAAa,EAYpB,aACE,EACA,EACM,CAEN,KAAM,GAAgB,AADJ,KAAK,WACS,OAAO,SAAU,EAAU,CACzD,MACG,GAAS,OAAS,QACjB,EAAS,OAAS,WAClB,EAAS,OAAS,YACpB,CAAC,EAAS,iBAGd,GAAI,EAAc,SAAW,EAC3B,MAAO,GAAW,EAAc,QAElC,GAAI,GAAS,EAEb,KAAM,GAAqC,SAAU,EAAO,CAC1D,AAAI,GACF,EAAO,MAAM,0CAA4C,GAE3D,IACA,AAAI,IAAW,EAAc,OAC3B,EAAW,EAAc,QAEzB,EAAW,EAAQ,EAAc,SAGrC,OAAS,GAAI,EAAG,EAAI,EAAc,OAAQ,EAAE,EAC1C,KAAK,SAAS,EAAc,GAAG,KAAM,GAYzC,SAAS,EAAsB,EAA4C,CACzE,KAAM,GAAW,KAAK,WAAW,KAAK,SAAU,EAAU,CACxD,MACG,GAAS,OAAS,QACjB,EAAS,OAAS,WAClB,EAAS,OAAS,YACpB,EAAS,OAAS,IAGtB,GAAI,CAAC,EAAU,CACb,EACE,GAAI,OACF,mCACE,EACA,kCAEJ,MAEF,OAIF,GAAI,KAAK,aAAa,GAAe,CACnC,EAAS,KAAM,KAAK,aAAa,IACjC,OAGF,CACE,KAAM,GAAY,KAAK,WAAW,GAClC,GAAI,EAAW,CACb,EAAU,KAAK,GACf,WAEA,MAAK,WAAW,GAAgB,CAAC,GAGrC,KAAM,GAAO,KACP,EAAM,GAAI,gBAChB,EAAI,aAAe,OACnB,EAAI,gBAAkB,KAAK,iBAAiB,2BAC1C,EAAS,MAEX,EAAI,KAAK,MAAO,KAAK,iBAAiB,WAAW,EAAS,OAC1D,EAAI,OAAS,UAAY,CACvB,KAAM,GAAY,EAAK,WAAW,GAClC,GAAI,EAAC,EAGL,IAAI,EAAI,SAAW,IAAK,CACtB,SAAW,KAAY,GACrB,EACE,GAAI,OACF,eAAiB,EAAI,OAAS,IAAM,EAAI,WAAa,KAEvD,MAGJ,MAAO,GAAK,WAAW,GACvB,OAIF,EAAK,aAAa,GAAgB,EAAI,SACtC,SAAW,KAAY,GACrB,EAAS,KAAM,EAAI,UAErB,MAAO,GAAK,WAAW,KAEzB,EAAI,QAAU,UAAY,CACxB,KAAM,GAAY,EAAK,WAAW,GAClC,GAAI,EAAC,EAGL,UAAW,KAAY,GACrB,EAAS,GAAI,OAAM,iBAAkB,MAEvC,MAAO,GAAK,WAAW,KAEzB,EAAI,QAAU,UAAY,CACxB,KAAM,GAAY,EAAK,WAAW,GAClC,GAAI,EAAC,EAGL,UAAW,KAAY,GACrB,EAAS,GAAI,OAAM,mBAAoB,MAEzC,MAAO,GAAK,WAAW,KAEzB,EAAI,OAQN,aAAa,EAA+B,CAC1C,MAAO,CAAC,CAAC,KAAK,aAAa,GAU7B,cAAc,EAAqC,CACjD,MAAO,MAAK,aAAa,IAAiB,MA3LvC,EAAM,gBAtBL",
  "names": []
}
